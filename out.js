var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __glob = (map) => (path) => {
  var fn = map[path];
  if (fn) return fn();
  throw new Error("Module not found in bundle: " + path);
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/logform/format.js
var require_format = __commonJS({
  "node_modules/logform/format.js"(exports2, module2) {
    "use strict";
    var InvalidFormatError = class _InvalidFormatError extends Error {
      constructor(formatFn) {
        super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${formatFn.toString().split("\n")[0]}
`);
        Error.captureStackTrace(this, _InvalidFormatError);
      }
    };
    module2.exports = (formatFn) => {
      if (formatFn.length > 2) {
        throw new InvalidFormatError(formatFn);
      }
      function Format(options = {}) {
        this.options = options;
      }
      Format.prototype.transform = formatFn;
      function createFormatWrap(opts) {
        return new Format(opts);
      }
      createFormatWrap.Format = Format;
      return createFormatWrap;
    };
  }
});

// node_modules/logform/node_modules/@colors/colors/lib/styles.js
var require_styles = __commonJS({
  "node_modules/logform/node_modules/@colors/colors/lib/styles.js"(exports2, module2) {
    var styles = {};
    module2["exports"] = styles;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      brightRed: [91, 39],
      brightGreen: [92, 39],
      brightYellow: [93, 39],
      brightBlue: [94, 39],
      brightMagenta: [95, 39],
      brightCyan: [96, 39],
      brightWhite: [97, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgBrightRed: [101, 49],
      bgBrightGreen: [102, 49],
      bgBrightYellow: [103, 49],
      bgBrightBlue: [104, 49],
      bgBrightMagenta: [105, 49],
      bgBrightCyan: [106, 49],
      bgBrightWhite: [107, 49],
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  }
});

// node_modules/logform/node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag = __commonJS({
  "node_modules/logform/node_modules/@colors/colors/lib/system/has-flag.js"(exports2, module2) {
    "use strict";
    module2.exports = function(flag, argv) {
      argv = argv || process.argv || [];
      var terminatorPos = argv.indexOf("--");
      var prefix = /^-{1,2}/.test(flag) ? "" : "--";
      var pos = argv.indexOf(prefix + flag);
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/logform/node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  "node_modules/logform/node_modules/@colors/colors/lib/system/supports-colors.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor = void 0;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      var min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        var osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
          return sign in env;
        }) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if ("TERM_PROGRAM" in env) {
        var version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Hyper":
            return 3;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      var level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/logform/node_modules/@colors/colors/lib/custom/trap.js
var require_trap = __commonJS({
  "node_modules/logform/node_modules/@colors/colors/lib/custom/trap.js"(exports2, module2) {
    module2["exports"] = function runTheTrap(text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: [
          "\xCB",
          "\u0115",
          "\u018E",
          "\u0258",
          "\u03A3",
          "\u03BE",
          "\u04BC",
          "\u0A6C"
        ],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: [
          "\xD8",
          "\xF5",
          "\xF8",
          "\u01FE",
          "\u0298",
          "\u047A",
          "\u05DD",
          "\u06DD",
          "\u0E4F"
        ],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
  }
});

// node_modules/logform/node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  "node_modules/logform/node_modules/@colors/colors/lib/custom/zalgo.js"(exports2, module2) {
    module2["exports"] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      };
      var all = [].concat(soul.up, soul.down, soul.mid);
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      function isChar(character) {
        var bool = false;
        all.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      function heComes(text2, options2) {
        var result = "";
        var counts;
        var l;
        options2 = options2 || {};
        options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
        options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
        options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
        options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (isChar(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options2.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.mid = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.mid = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0; i <= counts[index]; i++) {
              if (options2[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text, options);
    };
  }
});

// node_modules/logform/node_modules/@colors/colors/lib/maps/america.js
var require_america = __commonJS({
  "node_modules/logform/node_modules/@colors/colors/lib/maps/america.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        if (letter === " ") return letter;
        switch (i % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    };
  }
});

// node_modules/logform/node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  "node_modules/logform/node_modules/@colors/colors/lib/maps/zebra.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        return i % 2 === 0 ? letter : colors.inverse(letter);
      };
    };
  }
});

// node_modules/logform/node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  "node_modules/logform/node_modules/@colors/colors/lib/maps/rainbow.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    };
  }
});

// node_modules/logform/node_modules/@colors/colors/lib/maps/random.js
var require_random = __commonJS({
  "node_modules/logform/node_modules/@colors/colors/lib/maps/random.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var available = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta",
        "brightYellow",
        "brightRed",
        "brightGreen",
        "brightBlue",
        "brightWhite",
        "brightCyan",
        "brightMagenta"
      ];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
      };
    };
  }
});

// node_modules/logform/node_modules/@colors/colors/lib/colors.js
var require_colors = __commonJS({
  "node_modules/logform/node_modules/@colors/colors/lib/colors.js"(exports2, module2) {
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var util = require("util");
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    var newLineRegex = new RegExp(/[\r\n]+/g);
    colors.supportsColor = require_supports_colors().supportsColor;
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor() !== false;
    }
    colors.enable = function() {
      colors.enabled = true;
    };
    colors.disable = function() {
      colors.enabled = false;
    };
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style) {
      if (!colors.enabled) {
        return str + "";
      }
      var styleMap = ansiStyles[style];
      if (!styleMap && style in colors) {
        return colors[style](str);
      }
      return styleMap.open + str + styleMap.close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles);
    function applyStyle() {
      var args = Array.prototype.slice.call(arguments);
      var str = args.map(function(arg) {
        if (arg != null && arg.constructor === String) {
          return arg;
        } else {
          return util.inspect(arg);
        }
      }).join(" ");
      if (!colors.enabled || !str) {
        return str;
      }
      var newLinesPresent = str.indexOf("\n") != -1;
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
          str = str.replace(newLineRegex, function(match) {
            return code.close + match + code.open;
          });
        }
      }
      return str;
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
        return;
      }
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            if (typeof theme[style2] === "object") {
              var out = str;
              for (var i in theme[style2]) {
                out = colors[theme[style2][i]](out);
              }
              return out;
            }
            return colors[theme[style2]](str);
          };
        })(style);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles).forEach(function(name) {
        ret[name] = {
          get: function() {
            return build([name]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map2, str) {
      var exploded = str.split("");
      exploded = exploded.map(map2);
      return exploded.join("");
    };
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america()(colors);
    colors.maps.zebra = require_zebra()(colors);
    colors.maps.rainbow = require_rainbow()(colors);
    colors.maps.random = require_random()(colors);
    for (map in colors.maps) {
      (function(map2) {
        colors[map2] = function(str) {
          return sequencer(colors.maps[map2], str);
        };
      })(map);
    }
    var map;
    defineProps(colors, init());
  }
});

// node_modules/logform/node_modules/@colors/colors/safe.js
var require_safe = __commonJS({
  "node_modules/logform/node_modules/@colors/colors/safe.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = colors;
  }
});

// node_modules/triple-beam/config/cli.js
var require_cli = __commonJS({
  "node_modules/triple-beam/config/cli.js"(exports2) {
    "use strict";
    exports2.levels = {
      error: 0,
      warn: 1,
      help: 2,
      data: 3,
      info: 4,
      debug: 5,
      prompt: 6,
      verbose: 7,
      input: 8,
      silly: 9
    };
    exports2.colors = {
      error: "red",
      warn: "yellow",
      help: "cyan",
      data: "grey",
      info: "green",
      debug: "blue",
      prompt: "grey",
      verbose: "cyan",
      input: "grey",
      silly: "magenta"
    };
  }
});

// node_modules/triple-beam/config/npm.js
var require_npm = __commonJS({
  "node_modules/triple-beam/config/npm.js"(exports2) {
    "use strict";
    exports2.levels = {
      error: 0,
      warn: 1,
      info: 2,
      http: 3,
      verbose: 4,
      debug: 5,
      silly: 6
    };
    exports2.colors = {
      error: "red",
      warn: "yellow",
      info: "green",
      http: "green",
      verbose: "cyan",
      debug: "blue",
      silly: "magenta"
    };
  }
});

// node_modules/triple-beam/config/syslog.js
var require_syslog = __commonJS({
  "node_modules/triple-beam/config/syslog.js"(exports2) {
    "use strict";
    exports2.levels = {
      emerg: 0,
      alert: 1,
      crit: 2,
      error: 3,
      warning: 4,
      notice: 5,
      info: 6,
      debug: 7
    };
    exports2.colors = {
      emerg: "red",
      alert: "yellow",
      crit: "red",
      error: "red",
      warning: "red",
      notice: "yellow",
      info: "green",
      debug: "blue"
    };
  }
});

// node_modules/triple-beam/config/index.js
var require_config = __commonJS({
  "node_modules/triple-beam/config/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "cli", {
      value: require_cli()
    });
    Object.defineProperty(exports2, "npm", {
      value: require_npm()
    });
    Object.defineProperty(exports2, "syslog", {
      value: require_syslog()
    });
  }
});

// node_modules/triple-beam/index.js
var require_triple_beam = __commonJS({
  "node_modules/triple-beam/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "LEVEL", {
      value: Symbol.for("level")
    });
    Object.defineProperty(exports2, "MESSAGE", {
      value: Symbol.for("message")
    });
    Object.defineProperty(exports2, "SPLAT", {
      value: Symbol.for("splat")
    });
    Object.defineProperty(exports2, "configs", {
      value: require_config()
    });
  }
});

// node_modules/logform/colorize.js
var require_colorize = __commonJS({
  "node_modules/logform/colorize.js"(exports2, module2) {
    "use strict";
    var colors = require_safe();
    var { LEVEL, MESSAGE } = require_triple_beam();
    colors.enabled = true;
    var hasSpace = /\s+/;
    var Colorizer = class _Colorizer {
      constructor(opts = {}) {
        if (opts.colors) {
          this.addColors(opts.colors);
        }
        this.options = opts;
      }
      /*
       * Adds the colors Object to the set of allColors
       * known by the Colorizer
       *
       * @param {Object} colors Set of color mappings to add.
       */
      static addColors(clrs) {
        const nextColors = Object.keys(clrs).reduce((acc, level) => {
          acc[level] = hasSpace.test(clrs[level]) ? clrs[level].split(hasSpace) : clrs[level];
          return acc;
        }, {});
        _Colorizer.allColors = Object.assign({}, _Colorizer.allColors || {}, nextColors);
        return _Colorizer.allColors;
      }
      /*
       * Adds the colors Object to the set of allColors
       * known by the Colorizer
       *
       * @param {Object} colors Set of color mappings to add.
       */
      addColors(clrs) {
        return _Colorizer.addColors(clrs);
      }
      /*
       * function colorize (lookup, level, message)
       * Performs multi-step colorization using @colors/colors/safe
       */
      colorize(lookup, level, message) {
        if (typeof message === "undefined") {
          message = level;
        }
        if (!Array.isArray(_Colorizer.allColors[lookup])) {
          return colors[_Colorizer.allColors[lookup]](message);
        }
        for (let i = 0, len = _Colorizer.allColors[lookup].length; i < len; i++) {
          message = colors[_Colorizer.allColors[lookup][i]](message);
        }
        return message;
      }
      /*
       * function transform (info, opts)
       * Attempts to colorize the { level, message } of the given
       * `logform` info object.
       */
      transform(info, opts) {
        if (opts.all && typeof info[MESSAGE] === "string") {
          info[MESSAGE] = this.colorize(info[LEVEL], info.level, info[MESSAGE]);
        }
        if (opts.level || opts.all || !opts.message) {
          info.level = this.colorize(info[LEVEL], info.level);
        }
        if (opts.all || opts.message) {
          info.message = this.colorize(info[LEVEL], info.level, info.message);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Colorizer(opts);
    module2.exports.Colorizer = module2.exports.Format = Colorizer;
  }
});

// node_modules/logform/levels.js
var require_levels = __commonJS({
  "node_modules/logform/levels.js"(exports2, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    module2.exports = (config) => {
      Colorizer.addColors(config.colors || config);
      return config;
    };
  }
});

// node_modules/logform/align.js
var require_align = __commonJS({
  "node_modules/logform/align.js"(exports2, module2) {
    "use strict";
    var format = require_format();
    module2.exports = format((info) => {
      info.message = `	${info.message}`;
      return info;
    });
  }
});

// node_modules/logform/errors.js
var require_errors = __commonJS({
  "node_modules/logform/errors.js"(exports2, module2) {
    "use strict";
    var format = require_format();
    var { LEVEL, MESSAGE } = require_triple_beam();
    module2.exports = format((einfo, { stack, cause }) => {
      if (einfo instanceof Error) {
        const info = Object.assign({}, einfo, {
          level: einfo.level,
          [LEVEL]: einfo[LEVEL] || einfo.level,
          message: einfo.message,
          [MESSAGE]: einfo[MESSAGE] || einfo.message
        });
        if (stack) info.stack = einfo.stack;
        if (cause) info.cause = einfo.cause;
        return info;
      }
      if (!(einfo.message instanceof Error)) return einfo;
      const err = einfo.message;
      Object.assign(einfo, err);
      einfo.message = err.message;
      einfo[MESSAGE] = err.message;
      if (stack) einfo.stack = err.stack;
      if (cause) einfo.cause = err.cause;
      return einfo;
    });
  }
});

// node_modules/logform/pad-levels.js
var require_pad_levels = __commonJS({
  "node_modules/logform/pad-levels.js"(exports2, module2) {
    "use strict";
    var { configs, LEVEL, MESSAGE } = require_triple_beam();
    var Padder = class _Padder {
      constructor(opts = { levels: configs.npm.levels }) {
        this.paddings = _Padder.paddingForLevels(opts.levels, opts.filler);
        this.options = opts;
      }
      /**
       * Returns the maximum length of keys in the specified `levels` Object.
       * @param  {Object} levels Set of all levels to calculate longest level against.
       * @returns {Number} Maximum length of the longest level string.
       */
      static getLongestLevel(levels) {
        const lvls = Object.keys(levels).map((level) => level.length);
        return Math.max(...lvls);
      }
      /**
       * Returns the padding for the specified `level` assuming that the
       * maximum length of all levels it's associated with is `maxLength`.
       * @param  {String} level Level to calculate padding for.
       * @param  {String} filler Repeatable text to use for padding.
       * @param  {Number} maxLength Length of the longest level
       * @returns {String} Padding string for the `level`
       */
      static paddingForLevel(level, filler, maxLength) {
        const targetLen = maxLength + 1 - level.length;
        const rep = Math.floor(targetLen / filler.length);
        const padding = `${filler}${filler.repeat(rep)}`;
        return padding.slice(0, targetLen);
      }
      /**
       * Returns an object with the string paddings for the given `levels`
       * using the specified `filler`.
       * @param  {Object} levels Set of all levels to calculate padding for.
       * @param  {String} filler Repeatable text to use for padding.
       * @returns {Object} Mapping of level to desired padding.
       */
      static paddingForLevels(levels, filler = " ") {
        const maxLength = _Padder.getLongestLevel(levels);
        return Object.keys(levels).reduce((acc, level) => {
          acc[level] = _Padder.paddingForLevel(level, filler, maxLength);
          return acc;
        }, {});
      }
      /**
       * Prepends the padding onto the `message` based on the `LEVEL` of
       * the `info`. This is based on the behavior of `winston@2` which also
       * prepended the level onto the message.
       *
       * See: https://github.com/winstonjs/winston/blob/2.x/lib/winston/logger.js#L198-L201
       *
       * @param  {Info} info Logform info object
       * @param  {Object} opts Options passed along to this instance.
       * @returns {Info} Modified logform info object.
       */
      transform(info, opts) {
        info.message = `${this.paddings[info[LEVEL]]}${info.message}`;
        if (info[MESSAGE]) {
          info[MESSAGE] = `${this.paddings[info[LEVEL]]}${info[MESSAGE]}`;
        }
        return info;
      }
    };
    module2.exports = (opts) => new Padder(opts);
    module2.exports.Padder = module2.exports.Format = Padder;
  }
});

// node_modules/logform/cli.js
var require_cli2 = __commonJS({
  "node_modules/logform/cli.js"(exports2, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    var { Padder } = require_pad_levels();
    var { configs, MESSAGE } = require_triple_beam();
    var CliFormat = class {
      constructor(opts = {}) {
        if (!opts.levels) {
          opts.levels = configs.cli.levels;
        }
        this.colorizer = new Colorizer(opts);
        this.padder = new Padder(opts);
        this.options = opts;
      }
      /*
       * function transform (info, opts)
       * Attempts to both:
       * 1. Pad the { level }
       * 2. Colorize the { level, message }
       * of the given `logform` info object depending on the `opts`.
       */
      transform(info, opts) {
        this.colorizer.transform(
          this.padder.transform(info, opts),
          opts
        );
        info[MESSAGE] = `${info.level}:${info.message}`;
        return info;
      }
    };
    module2.exports = (opts) => new CliFormat(opts);
    module2.exports.Format = CliFormat;
  }
});

// node_modules/logform/combine.js
var require_combine = __commonJS({
  "node_modules/logform/combine.js"(exports2, module2) {
    "use strict";
    var format = require_format();
    function cascade(formats) {
      if (!formats.every(isValidFormat)) {
        return;
      }
      return (info) => {
        let obj = info;
        for (let i = 0; i < formats.length; i++) {
          obj = formats[i].transform(obj, formats[i].options);
          if (!obj) {
            return false;
          }
        }
        return obj;
      };
    }
    function isValidFormat(fmt) {
      if (typeof fmt.transform !== "function") {
        throw new Error([
          "No transform function found on format. Did you create a format instance?",
          "const myFormat = format(formatFn);",
          "const instance = myFormat();"
        ].join("\n"));
      }
      return true;
    }
    module2.exports = (...formats) => {
      const combinedFormat = format(cascade(formats));
      const instance = combinedFormat();
      instance.Format = combinedFormat.Format;
      return instance;
    };
    module2.exports.cascade = cascade;
  }
});

// node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "node_modules/safe-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    var { hasOwnProperty } = Object.prototype;
    var stringify2 = configure();
    stringify2.configure = configure;
    stringify2.stringify = stringify2;
    stringify2.default = stringify2;
    exports2.stringify = stringify2;
    exports2.configure = configure;
    module2.exports = stringify2;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function sort(array, comparator) {
      if (array.length > 200 || comparator) {
        return array.sort(comparator);
      }
      for (let i = 1; i < array.length; i++) {
        const currentValue = array[i];
        let position = i;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res += `${separator}"${i}":${whitespace}${array[i]}`;
      }
      return res;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getDeterministicOption(options) {
      let value;
      if (hasOwnProperty.call(options, "deterministic")) {
        value = options.deterministic;
        if (typeof value !== "boolean" && typeof value !== "function") {
          throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
      }
      return value === void 0 ? true : value;
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function") message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, "bigint");
      const deterministic = getDeterministicOption(options);
      const comparator = typeof deterministic === "function" ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join2 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join2;
              }
              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join;
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            const hasLength = value.length !== void 0;
            if (hasLength && Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i), value[i], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify3(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify3;
    }
  }
});

// node_modules/logform/json.js
var require_json = __commonJS({
  "node_modules/logform/json.js"(exports2, module2) {
    "use strict";
    var format = require_format();
    var { MESSAGE } = require_triple_beam();
    var stringify2 = require_safe_stable_stringify();
    function replacer(key, value) {
      if (typeof value === "bigint")
        return value.toString();
      return value;
    }
    module2.exports = format((info, opts) => {
      const jsonStringify = stringify2.configure(opts);
      info[MESSAGE] = jsonStringify(info, opts.replacer || replacer, opts.space);
      return info;
    });
  }
});

// node_modules/logform/label.js
var require_label = __commonJS({
  "node_modules/logform/label.js"(exports2, module2) {
    "use strict";
    var format = require_format();
    module2.exports = format((info, opts) => {
      if (opts.message) {
        info.message = `[${opts.label}] ${info.message}`;
        return info;
      }
      info.label = opts.label;
      return info;
    });
  }
});

// node_modules/logform/logstash.js
var require_logstash = __commonJS({
  "node_modules/logform/logstash.js"(exports2, module2) {
    "use strict";
    var format = require_format();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format((info) => {
      const logstash = {};
      if (info.message) {
        logstash["@message"] = info.message;
        delete info.message;
      }
      if (info.timestamp) {
        logstash["@timestamp"] = info.timestamp;
        delete info.timestamp;
      }
      logstash["@fields"] = info;
      info[MESSAGE] = jsonStringify(logstash);
      return info;
    });
  }
});

// node_modules/logform/metadata.js
var require_metadata = __commonJS({
  "node_modules/logform/metadata.js"(exports2, module2) {
    "use strict";
    var format = require_format();
    function fillExcept(info, fillExceptKeys, metadataKey) {
      const savedKeys = fillExceptKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      const metadata = Object.keys(info).reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      Object.assign(info, savedKeys, {
        [metadataKey]: metadata
      });
      return info;
    }
    function fillWith(info, fillWithKeys, metadataKey) {
      info[metadataKey] = fillWithKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      return info;
    }
    module2.exports = format((info, opts = {}) => {
      let metadataKey = "metadata";
      if (opts.key) {
        metadataKey = opts.key;
      }
      let fillExceptKeys = [];
      if (!opts.fillExcept && !opts.fillWith) {
        fillExceptKeys.push("level");
        fillExceptKeys.push("message");
      }
      if (opts.fillExcept) {
        fillExceptKeys = opts.fillExcept;
      }
      if (fillExceptKeys.length > 0) {
        return fillExcept(info, fillExceptKeys, metadataKey);
      }
      if (opts.fillWith) {
        return fillWith(info, opts.fillWith, metadataKey);
      }
      return info;
    });
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/logform/ms.js
var require_ms2 = __commonJS({
  "node_modules/logform/ms.js"(exports2, module2) {
    "use strict";
    var format = require_format();
    var ms = require_ms();
    module2.exports = format((info) => {
      const curr = +/* @__PURE__ */ new Date();
      exports2.diff = curr - (exports2.prevTime || curr);
      exports2.prevTime = curr;
      info.ms = `+${ms(exports2.diff)}`;
      return info;
    });
  }
});

// node_modules/logform/pretty-print.js
var require_pretty_print = __commonJS({
  "node_modules/logform/pretty-print.js"(exports2, module2) {
    "use strict";
    var inspect = require("util").inspect;
    var format = require_format();
    var { LEVEL, MESSAGE, SPLAT } = require_triple_beam();
    module2.exports = format((info, opts = {}) => {
      const stripped = Object.assign({}, info);
      delete stripped[LEVEL];
      delete stripped[MESSAGE];
      delete stripped[SPLAT];
      info[MESSAGE] = inspect(stripped, false, opts.depth || null, opts.colorize);
      return info;
    });
  }
});

// node_modules/logform/printf.js
var require_printf = __commonJS({
  "node_modules/logform/printf.js"(exports2, module2) {
    "use strict";
    var { MESSAGE } = require_triple_beam();
    var Printf = class {
      constructor(templateFn) {
        this.template = templateFn;
      }
      transform(info) {
        info[MESSAGE] = this.template(info);
        return info;
      }
    };
    module2.exports = (opts) => new Printf(opts);
    module2.exports.Printf = module2.exports.Format = Printf;
  }
});

// node_modules/logform/simple.js
var require_simple = __commonJS({
  "node_modules/logform/simple.js"(exports2, module2) {
    "use strict";
    var format = require_format();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format((info) => {
      const stringifiedRest = jsonStringify(Object.assign({}, info, {
        level: void 0,
        message: void 0,
        splat: void 0
      }));
      const padding = info.padding && info.padding[info.level] || "";
      if (stringifiedRest !== "{}") {
        info[MESSAGE] = `${info.level}:${padding} ${info.message} ${stringifiedRest}`;
      } else {
        info[MESSAGE] = `${info.level}:${padding} ${info.message}`;
      }
      return info;
    });
  }
});

// node_modules/logform/splat.js
var require_splat = __commonJS({
  "node_modules/logform/splat.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var { SPLAT } = require_triple_beam();
    var formatRegExp = /%[scdjifoO%]/g;
    var escapedPercent = /%%/g;
    var Splatter = class {
      constructor(opts) {
        this.options = opts;
      }
      /**
         * Check to see if tokens <= splat.length, assign { splat, meta } into the
         * `info` accordingly, and write to this instance.
         *
         * @param  {Info} info Logform info message.
         * @param  {String[]} tokens Set of string interpolation tokens.
         * @returns {Info} Modified info message
         * @private
         */
      _splat(info, tokens) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat || [];
        const percents = msg.match(escapedPercent);
        const escapes = percents && percents.length || 0;
        const expectedSplat = tokens.length - escapes;
        const extraSplat = expectedSplat - splat.length;
        const metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : [];
        const metalen = metas.length;
        if (metalen) {
          for (let i = 0; i < metalen; i++) {
            Object.assign(info, metas[i]);
          }
        }
        info.message = util.format(msg, ...splat);
        return info;
      }
      /**
        * Transforms the `info` message by using `util.format` to complete
        * any `info.message` provided it has string interpolation tokens.
        * If no tokens exist then `info` is immutable.
        *
        * @param  {Info} info Logform info message.
        * @param  {Object} opts Options for this instance.
        * @returns {Info} Modified info message
        */
      transform(info) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat;
        if (!splat || !splat.length) {
          return info;
        }
        const tokens = msg && msg.match && msg.match(formatRegExp);
        if (!tokens && (splat || splat.length)) {
          const metas = splat.length > 1 ? splat.splice(0) : splat;
          const metalen = metas.length;
          if (metalen) {
            for (let i = 0; i < metalen; i++) {
              Object.assign(info, metas[i]);
            }
          }
          return info;
        }
        if (tokens) {
          return this._splat(info, tokens);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Splatter(opts);
  }
});

// node_modules/fecha/lib/fecha.umd.js
var require_fecha_umd = __commonJS({
  "node_modules/fecha/lib/fecha.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.fecha = {});
    })(exports2, function(exports3) {
      "use strict";
      var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
      var twoDigitsOptional = "\\d\\d?";
      var twoDigits = "\\d\\d";
      var threeDigits = "\\d{3}";
      var fourDigits = "\\d{4}";
      var word = "[^\\s]+";
      var literal = /\[([^]*?)\]/gm;
      function shorten(arr, sLen) {
        var newArr = [];
        for (var i = 0, len = arr.length; i < len; i++) {
          newArr.push(arr[i].substr(0, sLen));
        }
        return newArr;
      }
      var monthUpdate = function(arrName) {
        return function(v, i18n) {
          var lowerCaseArr = i18n[arrName].map(function(v2) {
            return v2.toLowerCase();
          });
          var index = lowerCaseArr.indexOf(v.toLowerCase());
          if (index > -1) {
            return index;
          }
          return null;
        };
      };
      function assign(origObj) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
          var obj = args_1[_a];
          for (var key in obj) {
            origObj[key] = obj[key];
          }
        }
        return origObj;
      }
      var dayNames = [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ];
      var monthNames = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ];
      var monthNamesShort = shorten(monthNames, 3);
      var dayNamesShort = shorten(dayNames, 3);
      var defaultI18n = {
        dayNamesShort,
        dayNames,
        monthNamesShort,
        monthNames,
        amPm: ["am", "pm"],
        DoFn: function(dayOfMonth) {
          return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
        }
      };
      var globalI18n = assign({}, defaultI18n);
      var setGlobalDateI18n = function(i18n) {
        return globalI18n = assign(globalI18n, i18n);
      };
      var regexEscape = function(str) {
        return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
      };
      var pad = function(val, len) {
        if (len === void 0) {
          len = 2;
        }
        val = String(val);
        while (val.length < len) {
          val = "0" + val;
        }
        return val;
      };
      var formatFlags = {
        D: function(dateObj) {
          return String(dateObj.getDate());
        },
        DD: function(dateObj) {
          return pad(dateObj.getDate());
        },
        Do: function(dateObj, i18n) {
          return i18n.DoFn(dateObj.getDate());
        },
        d: function(dateObj) {
          return String(dateObj.getDay());
        },
        dd: function(dateObj) {
          return pad(dateObj.getDay());
        },
        ddd: function(dateObj, i18n) {
          return i18n.dayNamesShort[dateObj.getDay()];
        },
        dddd: function(dateObj, i18n) {
          return i18n.dayNames[dateObj.getDay()];
        },
        M: function(dateObj) {
          return String(dateObj.getMonth() + 1);
        },
        MM: function(dateObj) {
          return pad(dateObj.getMonth() + 1);
        },
        MMM: function(dateObj, i18n) {
          return i18n.monthNamesShort[dateObj.getMonth()];
        },
        MMMM: function(dateObj, i18n) {
          return i18n.monthNames[dateObj.getMonth()];
        },
        YY: function(dateObj) {
          return pad(String(dateObj.getFullYear()), 4).substr(2);
        },
        YYYY: function(dateObj) {
          return pad(dateObj.getFullYear(), 4);
        },
        h: function(dateObj) {
          return String(dateObj.getHours() % 12 || 12);
        },
        hh: function(dateObj) {
          return pad(dateObj.getHours() % 12 || 12);
        },
        H: function(dateObj) {
          return String(dateObj.getHours());
        },
        HH: function(dateObj) {
          return pad(dateObj.getHours());
        },
        m: function(dateObj) {
          return String(dateObj.getMinutes());
        },
        mm: function(dateObj) {
          return pad(dateObj.getMinutes());
        },
        s: function(dateObj) {
          return String(dateObj.getSeconds());
        },
        ss: function(dateObj) {
          return pad(dateObj.getSeconds());
        },
        S: function(dateObj) {
          return String(Math.round(dateObj.getMilliseconds() / 100));
        },
        SS: function(dateObj) {
          return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
        },
        SSS: function(dateObj) {
          return pad(dateObj.getMilliseconds(), 3);
        },
        a: function(dateObj, i18n) {
          return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
        },
        A: function(dateObj, i18n) {
          return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
        },
        ZZ: function(dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
        },
        Z: function(dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
        }
      };
      var monthParse = function(v) {
        return +v - 1;
      };
      var emptyDigits = [null, twoDigitsOptional];
      var emptyWord = [null, word];
      var amPm = [
        "isPm",
        word,
        function(v, i18n) {
          var val = v.toLowerCase();
          if (val === i18n.amPm[0]) {
            return 0;
          } else if (val === i18n.amPm[1]) {
            return 1;
          }
          return null;
        }
      ];
      var timezoneOffset = [
        "timezoneOffset",
        "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
        function(v) {
          var parts = (v + "").match(/([+-]|\d\d)/gi);
          if (parts) {
            var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
            return parts[0] === "+" ? minutes : -minutes;
          }
          return 0;
        }
      ];
      var parseFlags = {
        D: ["day", twoDigitsOptional],
        DD: ["day", twoDigits],
        Do: ["day", twoDigitsOptional + word, function(v) {
          return parseInt(v, 10);
        }],
        M: ["month", twoDigitsOptional, monthParse],
        MM: ["month", twoDigits, monthParse],
        YY: [
          "year",
          twoDigits,
          function(v) {
            var now = /* @__PURE__ */ new Date();
            var cent = +("" + now.getFullYear()).substr(0, 2);
            return +("" + (+v > 68 ? cent - 1 : cent) + v);
          }
        ],
        h: ["hour", twoDigitsOptional, void 0, "isPm"],
        hh: ["hour", twoDigits, void 0, "isPm"],
        H: ["hour", twoDigitsOptional],
        HH: ["hour", twoDigits],
        m: ["minute", twoDigitsOptional],
        mm: ["minute", twoDigits],
        s: ["second", twoDigitsOptional],
        ss: ["second", twoDigits],
        YYYY: ["year", fourDigits],
        S: ["millisecond", "\\d", function(v) {
          return +v * 100;
        }],
        SS: ["millisecond", twoDigits, function(v) {
          return +v * 10;
        }],
        SSS: ["millisecond", threeDigits],
        d: emptyDigits,
        dd: emptyDigits,
        ddd: emptyWord,
        dddd: emptyWord,
        MMM: ["month", word, monthUpdate("monthNamesShort")],
        MMMM: ["month", word, monthUpdate("monthNames")],
        a: amPm,
        A: amPm,
        ZZ: timezoneOffset,
        Z: timezoneOffset
      };
      var globalMasks = {
        default: "ddd MMM DD YYYY HH:mm:ss",
        shortDate: "M/D/YY",
        mediumDate: "MMM D, YYYY",
        longDate: "MMMM D, YYYY",
        fullDate: "dddd, MMMM D, YYYY",
        isoDate: "YYYY-MM-DD",
        isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
        shortTime: "HH:mm",
        mediumTime: "HH:mm:ss",
        longTime: "HH:mm:ss.SSS"
      };
      var setGlobalDateMasks = function(masks) {
        return assign(globalMasks, masks);
      };
      var format = function(dateObj, mask, i18n) {
        if (mask === void 0) {
          mask = globalMasks["default"];
        }
        if (i18n === void 0) {
          i18n = {};
        }
        if (typeof dateObj === "number") {
          dateObj = new Date(dateObj);
        }
        if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
          throw new Error("Invalid Date pass to format");
        }
        mask = globalMasks[mask] || mask;
        var literals = [];
        mask = mask.replace(literal, function($0, $1) {
          literals.push($1);
          return "@@@";
        });
        var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
        mask = mask.replace(token, function($0) {
          return formatFlags[$0](dateObj, combinedI18nSettings);
        });
        return mask.replace(/@@@/g, function() {
          return literals.shift();
        });
      };
      function parse2(dateStr, format2, i18n) {
        if (i18n === void 0) {
          i18n = {};
        }
        if (typeof format2 !== "string") {
          throw new Error("Invalid format in fecha parse");
        }
        format2 = globalMasks[format2] || format2;
        if (dateStr.length > 1e3) {
          return null;
        }
        var today = /* @__PURE__ */ new Date();
        var dateInfo = {
          year: today.getFullYear(),
          month: 0,
          day: 1,
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0,
          isPm: null,
          timezoneOffset: null
        };
        var parseInfo = [];
        var literals = [];
        var newFormat = format2.replace(literal, function($0, $1) {
          literals.push(regexEscape($1));
          return "@@@";
        });
        var specifiedFields = {};
        var requiredFields = {};
        newFormat = regexEscape(newFormat).replace(token, function($0) {
          var info = parseFlags[$0];
          var field2 = info[0], regex = info[1], requiredField = info[3];
          if (specifiedFields[field2]) {
            throw new Error("Invalid format. " + field2 + " specified twice in format");
          }
          specifiedFields[field2] = true;
          if (requiredField) {
            requiredFields[requiredField] = true;
          }
          parseInfo.push(info);
          return "(" + regex + ")";
        });
        Object.keys(requiredFields).forEach(function(field2) {
          if (!specifiedFields[field2]) {
            throw new Error("Invalid format. " + field2 + " is required in specified format");
          }
        });
        newFormat = newFormat.replace(/@@@/g, function() {
          return literals.shift();
        });
        var matches = dateStr.match(new RegExp(newFormat, "i"));
        if (!matches) {
          return null;
        }
        var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
        for (var i = 1; i < matches.length; i++) {
          var _a = parseInfo[i - 1], field = _a[0], parser = _a[2];
          var value = parser ? parser(matches[i], combinedI18nSettings) : +matches[i];
          if (value == null) {
            return null;
          }
          dateInfo[field] = value;
        }
        if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
          dateInfo.hour = +dateInfo.hour + 12;
        } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
          dateInfo.hour = 0;
        }
        var dateTZ;
        if (dateInfo.timezoneOffset == null) {
          dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
          var validateFields = [
            ["month", "getMonth"],
            ["day", "getDate"],
            ["hour", "getHours"],
            ["minute", "getMinutes"],
            ["second", "getSeconds"]
          ];
          for (var i = 0, len = validateFields.length; i < len; i++) {
            if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
              return null;
            }
          }
        } else {
          dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
          if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
            return null;
          }
        }
        return dateTZ;
      }
      var fecha = {
        format,
        parse: parse2,
        defaultI18n,
        setGlobalDateI18n,
        setGlobalDateMasks
      };
      exports3.assign = assign;
      exports3.default = fecha;
      exports3.format = format;
      exports3.parse = parse2;
      exports3.defaultI18n = defaultI18n;
      exports3.setGlobalDateI18n = setGlobalDateI18n;
      exports3.setGlobalDateMasks = setGlobalDateMasks;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/logform/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/logform/timestamp.js"(exports2, module2) {
    "use strict";
    var fecha = require_fecha_umd();
    var format = require_format();
    module2.exports = format((info, opts = {}) => {
      if (opts.format) {
        info.timestamp = typeof opts.format === "function" ? opts.format() : fecha.format(/* @__PURE__ */ new Date(), opts.format);
      }
      if (!info.timestamp) {
        info.timestamp = (/* @__PURE__ */ new Date()).toISOString();
      }
      if (opts.alias) {
        info[opts.alias] = info.timestamp;
      }
      return info;
    });
  }
});

// node_modules/logform/uncolorize.js
var require_uncolorize = __commonJS({
  "node_modules/logform/uncolorize.js"(exports2, module2) {
    "use strict";
    var colors = require_safe();
    var format = require_format();
    var { MESSAGE } = require_triple_beam();
    module2.exports = format((info, opts) => {
      if (opts.level !== false) {
        info.level = colors.strip(info.level);
      }
      if (opts.message !== false) {
        info.message = colors.strip(String(info.message));
      }
      if (opts.raw !== false && info[MESSAGE]) {
        info[MESSAGE] = colors.strip(String(info[MESSAGE]));
      }
      return info;
    });
  }
});

// node_modules/logform/index.js
var require_logform = __commonJS({
  "node_modules/logform/index.js"(exports2) {
    "use strict";
    var format = exports2.format = require_format();
    exports2.levels = require_levels();
    function exposeFormat(name, requireFormat) {
      Object.defineProperty(format, name, {
        get() {
          return requireFormat();
        },
        configurable: true
      });
    }
    exposeFormat("align", function() {
      return require_align();
    });
    exposeFormat("errors", function() {
      return require_errors();
    });
    exposeFormat("cli", function() {
      return require_cli2();
    });
    exposeFormat("combine", function() {
      return require_combine();
    });
    exposeFormat("colorize", function() {
      return require_colorize();
    });
    exposeFormat("json", function() {
      return require_json();
    });
    exposeFormat("label", function() {
      return require_label();
    });
    exposeFormat("logstash", function() {
      return require_logstash();
    });
    exposeFormat("metadata", function() {
      return require_metadata();
    });
    exposeFormat("ms", function() {
      return require_ms2();
    });
    exposeFormat("padLevels", function() {
      return require_pad_levels();
    });
    exposeFormat("prettyPrint", function() {
      return require_pretty_print();
    });
    exposeFormat("printf", function() {
      return require_printf();
    });
    exposeFormat("simple", function() {
      return require_simple();
    });
    exposeFormat("splat", function() {
      return require_splat();
    });
    exposeFormat("timestamp", function() {
      return require_timestamp();
    });
    exposeFormat("uncolorize", function() {
      return require_uncolorize();
    });
  }
});

// node_modules/winston/lib/winston/common.js
var require_common = __commonJS({
  "node_modules/winston/lib/winston/common.js"(exports2) {
    "use strict";
    var { format } = require("util");
    exports2.warn = {
      deprecated(prop) {
        return () => {
          throw new Error(format("{ %s } was removed in winston@3.0.0.", prop));
        };
      },
      useFormat(prop) {
        return () => {
          throw new Error([
            format("{ %s } was removed in winston@3.0.0.", prop),
            "Use a custom winston.format = winston.format(function) instead."
          ].join("\n"));
        };
      },
      forFunctions(obj, type, props) {
        props.forEach((prop) => {
          obj[prop] = exports2.warn[type](prop);
        });
      },
      moved(obj, movedTo, prop) {
        function movedNotice() {
          return () => {
            throw new Error([
              format("winston.%s was moved in winston@3.0.0.", prop),
              format("Use a winston.%s instead.", movedTo)
            ].join("\n"));
          };
        }
        Object.defineProperty(obj, prop, {
          get: movedNotice,
          set: movedNotice
        });
      },
      forProperties(obj, type, props) {
        props.forEach((prop) => {
          const notice = exports2.warn[type](prop);
          Object.defineProperty(obj, prop, {
            get: notice,
            set: notice
          });
        });
      }
    };
  }
});

// node_modules/winston/package.json
var require_package = __commonJS({
  "node_modules/winston/package.json"(exports2, module2) {
    module2.exports = {
      name: "winston",
      description: "A logger for just about everything.",
      version: "3.8.1",
      author: "Charlie Robbins <charlie.robbins@gmail.com>",
      maintainers: [
        "David Hyde <dabh@alumni.stanford.edu>"
      ],
      repository: {
        type: "git",
        url: "https://github.com/winstonjs/winston.git"
      },
      keywords: [
        "winston",
        "logger",
        "logging",
        "logs",
        "sysadmin",
        "bunyan",
        "pino",
        "loglevel",
        "tools",
        "json",
        "stream"
      ],
      dependencies: {
        "@dabh/diagnostics": "^2.0.2",
        async: "^3.2.3",
        "is-stream": "^2.0.0",
        logform: "^2.4.0",
        "one-time": "^1.0.0",
        "readable-stream": "^3.4.0",
        "safe-stable-stringify": "^2.3.1",
        "stack-trace": "0.0.x",
        "triple-beam": "^1.3.0",
        "winston-transport": "^4.5.0"
      },
      devDependencies: {
        "@babel/cli": "^7.17.0",
        "@babel/core": "^7.17.2",
        "@babel/preset-env": "^7.16.7",
        "@colors/colors": "1.5.0",
        "@dabh/eslint-config-populist": "^5.0.0",
        "@types/node": "^18.0.0",
        "abstract-winston-transport": "^0.5.1",
        assume: "^2.2.0",
        "cross-spawn-async": "^2.2.5",
        eslint: "^8.9.0",
        hock: "^1.4.1",
        mocha: "8.1.3",
        nyc: "^15.1.0",
        rimraf: "^3.0.2",
        split2: "^4.1.0",
        "std-mocks": "^1.0.1",
        through2: "^4.0.2",
        "winston-compat": "^0.1.5"
      },
      main: "./lib/winston",
      browser: "./dist/winston",
      types: "./index.d.ts",
      scripts: {
        lint: "eslint lib/*.js lib/winston/*.js lib/winston/**/*.js --resolve-plugins-relative-to ./node_modules/@dabh/eslint-config-populist",
        test: "mocha",
        "test:coverage": "nyc npm run test:unit",
        "test:unit": "mocha test/unit",
        "test:integration": "mocha test/integration",
        build: "rimraf dist && babel lib -d dist",
        prepublishOnly: "npm run build"
      },
      engines: {
        node: ">= 12.0.0"
      },
      license: "MIT"
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose) return;
      if (self2._readableState && !self2._readableState.emitClose) return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
      else stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors.js
var require_errors2 = __commonJS({
  "node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors2().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor2) {
        if (superCtor2) {
          ctor.super_ = superCtor2;
          ctor.prototype = Object.create(superCtor2.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor2) {
        if (superCtor2) {
          ctor.super_ = superCtor2;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor2.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function") throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0) this.tail.next = entry;
          else this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;
          else this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0) return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0) return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length) ret += str;
            else ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors2().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function") return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable) onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false) stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors2().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();
      else throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable)) return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "") this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended) return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ending) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/winston-transport/legacy.js
var require_legacy = __commonJS({
  "node_modules/winston-transport/legacy.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var { LEVEL } = require_triple_beam();
    var TransportStream = require_winston_transport();
    var LegacyTransportStream = module2.exports = function LegacyTransportStream2(options = {}) {
      TransportStream.call(this, options);
      if (!options.transport || typeof options.transport.log !== "function") {
        throw new Error("Invalid transport, must be an object with a log method.");
      }
      this.transport = options.transport;
      this.level = this.level || options.transport.level;
      this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;
      this._deprecated();
      function transportError(err) {
        this.emit("error", err, this.transport);
      }
      if (!this.transport.__winstonError) {
        this.transport.__winstonError = transportError.bind(this);
        this.transport.on("error", this.transport.__winstonError);
      }
    };
    util.inherits(LegacyTransportStream, TransportStream);
    LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
        this.transport.log(info[LEVEL], info.message, info, this._nop);
      }
      callback(null);
    };
    LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
      for (let i = 0; i < chunks.length; i++) {
        if (this._accept(chunks[i])) {
          this.transport.log(
            chunks[i].chunk[LEVEL],
            chunks[i].chunk.message,
            chunks[i].chunk,
            this._nop
          );
          chunks[i].callback();
        }
      }
      return callback(null);
    };
    LegacyTransportStream.prototype._deprecated = function _deprecated() {
      console.error([
        `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
        "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"
      ].join("\n"));
    };
    LegacyTransportStream.prototype.close = function close() {
      if (this.transport.close) {
        this.transport.close();
      }
      if (this.transport.__winstonError) {
        this.transport.removeListener("error", this.transport.__winstonError);
        this.transport.__winstonError = null;
      }
    };
  }
});

// node_modules/winston-transport/index.js
var require_winston_transport = __commonJS({
  "node_modules/winston-transport/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Writable = require_stream_writable();
    var { LEVEL } = require_triple_beam();
    var TransportStream = module2.exports = function TransportStream2(options = {}) {
      Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });
      this.format = options.format;
      this.level = options.level;
      this.handleExceptions = options.handleExceptions;
      this.handleRejections = options.handleRejections;
      this.silent = options.silent;
      if (options.log) this.log = options.log;
      if (options.logv) this.logv = options.logv;
      if (options.close) this.close = options.close;
      this.once("pipe", (logger) => {
        this.levels = logger.levels;
        this.parent = logger;
      });
      this.once("unpipe", (src) => {
        if (src === this.parent) {
          this.parent = null;
          if (this.close) {
            this.close();
          }
        }
      });
    };
    util.inherits(TransportStream, Writable);
    TransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      const level = this.level || this.parent && this.parent.level;
      if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (info && !this.format) {
          return this.log(info, callback);
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(Object.assign({}, info), this.format.options);
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          callback();
          if (errState) throw errState;
          return;
        }
        return this.log(transformed, callback);
      }
      this._writableState.sync = false;
      return callback(null);
    };
    TransportStream.prototype._writev = function _writev(chunks, callback) {
      if (this.logv) {
        const infos = chunks.filter(this._accept, this);
        if (!infos.length) {
          return callback(null);
        }
        return this.logv(infos, callback);
      }
      for (let i = 0; i < chunks.length; i++) {
        if (!this._accept(chunks[i])) continue;
        if (chunks[i].chunk && !this.format) {
          this.log(chunks[i].chunk, chunks[i].callback);
          continue;
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(
            Object.assign({}, chunks[i].chunk),
            this.format.options
          );
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          chunks[i].callback();
          if (errState) {
            callback(null);
            throw errState;
          }
        } else {
          this.log(transformed, chunks[i].callback);
        }
      }
      return callback(null);
    };
    TransportStream.prototype._accept = function _accept(write) {
      const info = write.chunk;
      if (this.silent) {
        return false;
      }
      const level = this.level || this.parent && this.parent.level;
      if (info.exception === true || !level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (this.handleExceptions || info.exception !== true) {
          return true;
        }
      }
      return false;
    };
    TransportStream.prototype._nop = function _nop() {
      return void 0;
    };
    module2.exports.LegacyTransportStream = require_legacy();
  }
});

// node_modules/winston/lib/winston/transports/console.js
var require_console = __commonJS({
  "node_modules/winston/lib/winston/transports/console.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var { LEVEL, MESSAGE } = require_triple_beam();
    var TransportStream = require_winston_transport();
    module2.exports = class Console extends TransportStream {
      /**
       * Constructor function for the Console transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        this.name = options.name || "console";
        this.stderrLevels = this._stringArrayToSet(options.stderrLevels);
        this.consoleWarnLevels = this._stringArrayToSet(options.consoleWarnLevels);
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
        this.setMaxListeners(30);
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.stderrLevels[info[LEVEL]]) {
          if (console._stderr) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            console.error(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        } else if (this.consoleWarnLevels[info[LEVEL]]) {
          if (console._stderr) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            console.warn(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        }
        if (console._stdout) {
          console._stdout.write(`${info[MESSAGE]}${this.eol}`);
        } else {
          console.log(info[MESSAGE]);
        }
        if (callback) {
          callback();
        }
      }
      /**
       * Returns a Set-like object with strArray's elements as keys (each with the
       * value true).
       * @param {Array} strArray - Array of Set-elements as strings.
       * @param {?string} [errMsg] - Custom error message thrown on invalid input.
       * @returns {Object} - TODO: add return description.
       * @private
       */
      _stringArrayToSet(strArray, errMsg) {
        if (!strArray)
          return {};
        errMsg = errMsg || "Cannot make set from type other than Array of string elements";
        if (!Array.isArray(strArray)) {
          throw new Error(errMsg);
        }
        return strArray.reduce((set, el) => {
          if (typeof el !== "string") {
            throw new Error(errMsg);
          }
          set[el] = true;
          return set;
        }, {});
      }
    };
  }
});

// node_modules/async/internal/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/async/internal/isArrayLike.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isArrayLike;
    function isArrayLike(value) {
      return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS({
  "node_modules/async/internal/initialParams.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(fn) {
      return function(...args) {
        var callback = args.pop();
        return fn.call(this, args, callback);
      };
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS({
  "node_modules/async/internal/setImmediate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.fallback = fallback;
    exports2.wrap = wrap;
    var hasQueueMicrotask = exports2.hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
    var hasSetImmediate = exports2.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = exports2.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer) {
      return (fn, ...args) => defer(() => fn(...args));
    }
    var _defer;
    if (hasQueueMicrotask) {
      _defer = queueMicrotask;
    } else if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    exports2.default = wrap(_defer);
  }
});

// node_modules/async/asyncify.js
var require_asyncify = __commonJS({
  "node_modules/async/asyncify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = asyncify;
    var _initialParams = require_initialParams();
    var _initialParams2 = _interopRequireDefault(_initialParams);
    var _setImmediate = require_setImmediate();
    var _setImmediate2 = _interopRequireDefault(_setImmediate);
    var _wrapAsync = require_wrapAsync();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncify(func) {
      if ((0, _wrapAsync.isAsync)(func)) {
        return function(...args) {
          const callback = args.pop();
          const promise = func.apply(this, args);
          return handlePromise(promise, callback);
        };
      }
      return (0, _initialParams2.default)(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e) {
          return callback(e);
        }
        if (result && typeof result.then === "function") {
          return handlePromise(result, callback);
        } else {
          callback(null, result);
        }
      });
    }
    function handlePromise(promise, callback) {
      return promise.then((value) => {
        invokeCallback(callback, null, value);
      }, (err) => {
        invokeCallback(callback, err && err.message ? err : new Error(err));
      });
    }
    function invokeCallback(callback, error, value) {
      try {
        callback(error, value);
      } catch (err) {
        (0, _setImmediate2.default)((e) => {
          throw e;
        }, err);
      }
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS({
  "node_modules/async/internal/wrapAsync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isAsyncIterable = exports2.isAsyncGenerator = exports2.isAsync = void 0;
    var _asyncify = require_asyncify();
    var _asyncify2 = _interopRequireDefault(_asyncify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isAsync(fn) {
      return fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function isAsyncGenerator(fn) {
      return fn[Symbol.toStringTag] === "AsyncGenerator";
    }
    function isAsyncIterable(obj) {
      return typeof obj[Symbol.asyncIterator] === "function";
    }
    function wrapAsync(asyncFn) {
      if (typeof asyncFn !== "function") throw new Error("expected a function");
      return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
    }
    exports2.default = wrapAsync;
    exports2.isAsync = isAsync;
    exports2.isAsyncGenerator = isAsyncGenerator;
    exports2.isAsyncIterable = isAsyncIterable;
  }
});

// node_modules/async/internal/awaitify.js
var require_awaitify = __commonJS({
  "node_modules/async/internal/awaitify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = awaitify;
    function awaitify(asyncFn, arity = asyncFn.length) {
      if (!arity) throw new Error("arity is undefined");
      function awaitable(...args) {
        if (typeof args[arity - 1] === "function") {
          return asyncFn.apply(this, args);
        }
        return new Promise((resolve, reject) => {
          args[arity - 1] = (err, ...cbArgs) => {
            if (err) return reject(err);
            resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
          };
          asyncFn.apply(this, args);
        });
      }
      return awaitable;
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/parallel.js
var require_parallel = __commonJS({
  "node_modules/async/internal/parallel.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = (0, _awaitify2.default)((eachfn, tasks, callback) => {
      var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
      eachfn(tasks, (task, key, taskCb) => {
        (0, _wrapAsync2.default)(task)((err, ...result) => {
          if (result.length < 2) {
            [result] = result;
          }
          results[key] = result;
          taskCb(err);
        });
      }, (err) => callback(err, results));
    }, 3);
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/once.js
var require_once = __commonJS({
  "node_modules/async/internal/once.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = once;
    function once(fn) {
      function wrapper(...args) {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      }
      Object.assign(wrapper, fn);
      return wrapper;
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS({
  "node_modules/async/internal/getIterator.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(coll) {
      return coll[Symbol.iterator] && coll[Symbol.iterator]();
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/iterator.js
var require_iterator = __commonJS({
  "node_modules/async/internal/iterator.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createIterator;
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _getIterator = require_getIterator();
    var _getIterator2 = _interopRequireDefault(_getIterator);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
      };
    }
    function createES2015Iterator(iterator) {
      var i = -1;
      return function next() {
        var item = iterator.next();
        if (item.done) return null;
        i++;
        return { value: item.value, key: i };
      };
    }
    function createObjectIterator(obj) {
      var okeys = obj ? Object.keys(obj) : [];
      var i = -1;
      var len = okeys.length;
      return function next() {
        var key = okeys[++i];
        if (key === "__proto__") {
          return next();
        }
        return i < len ? { value: obj[key], key } : null;
      };
    }
    function createIterator(coll) {
      if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
      }
      var iterator = (0, _getIterator2.default)(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS({
  "node_modules/async/internal/onlyOnce.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = onlyOnce;
    function onlyOnce(fn) {
      return function(...args) {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      };
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS({
  "node_modules/async/internal/breakLoop.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var breakLoop = {};
    exports2.default = breakLoop;
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/asyncEachOfLimit.js
var require_asyncEachOfLimit = __commonJS({
  "node_modules/async/internal/asyncEachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = asyncEachOfLimit;
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
      let done = false;
      let canceled = false;
      let awaiting = false;
      let running = 0;
      let idx = 0;
      function replenish() {
        if (running >= limit || awaiting || done) return;
        awaiting = true;
        generator.next().then(({ value, done: iterDone }) => {
          if (canceled || done) return;
          awaiting = false;
          if (iterDone) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running++;
          iteratee(value, idx, iterateeCallback);
          idx++;
          replenish();
        }).catch(handleError);
      }
      function iterateeCallback(err, result) {
        running -= 1;
        if (canceled) return;
        if (err) return handleError(err);
        if (err === false) {
          done = true;
          canceled = true;
          return;
        }
        if (result === _breakLoop2.default || done && running <= 0) {
          done = true;
          return callback(null);
        }
        replenish();
      }
      function handleError(err) {
        if (canceled) return;
        awaiting = false;
        done = true;
        callback(err);
      }
      replenish();
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS({
  "node_modules/async/internal/eachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _iterator = require_iterator();
    var _iterator2 = _interopRequireDefault(_iterator);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _asyncEachOfLimit = require_asyncEachOfLimit();
    var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = (limit) => {
      return (obj, iteratee, callback) => {
        callback = (0, _once2.default)(callback);
        if (limit <= 0) {
          throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj) {
          return callback(null);
        }
        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
        }
        if ((0, _wrapAsync.isAsyncIterable)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          if (canceled) return;
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (err === false) {
            done = true;
            canceled = true;
          } else if (value === _breakLoop2.default || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS({
  "node_modules/async/eachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOfLimit2 = require_eachOfLimit();
    var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfLimit(coll, limit, iteratee, callback) {
      return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOfLimit, 4);
    module2.exports = exports2["default"];
  }
});

// node_modules/async/eachOfSeries.js
var require_eachOfSeries = __commonJS({
  "node_modules/async/eachOfSeries.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfSeries(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOfSeries, 3);
    module2.exports = exports2["default"];
  }
});

// node_modules/async/series.js
var require_series = __commonJS({
  "node_modules/async/series.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = series;
    var _parallel2 = require_parallel();
    var _parallel3 = _interopRequireDefault(_parallel2);
    var _eachOfSeries = require_eachOfSeries();
    var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function series(tasks, callback) {
      return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors2().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors2().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err) throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0) eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length) return noop;
      if (typeof streams[streams.length - 1] !== "function") return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
      exports2.finished = require_end_of_stream();
      exports2.pipeline = require_pipeline();
    }
  }
});

// node_modules/@dabh/diagnostics/diagnostics.js
var require_diagnostics = __commonJS({
  "node_modules/@dabh/diagnostics/diagnostics.js"(exports2, module2) {
    var adapters = [];
    var modifiers = [];
    var logger = function devnull() {
    };
    function use(adapter) {
      if (~adapters.indexOf(adapter)) return false;
      adapters.push(adapter);
      return true;
    }
    function set(custom) {
      logger = custom;
    }
    function enabled(namespace) {
      var async = [];
      for (var i = 0; i < adapters.length; i++) {
        if (adapters[i].async) {
          async.push(adapters[i]);
          continue;
        }
        if (adapters[i](namespace)) return true;
      }
      if (!async.length) return false;
      return new Promise(function pinky(resolve) {
        Promise.all(
          async.map(function prebind(fn) {
            return fn(namespace);
          })
        ).then(function resolved(values) {
          resolve(values.some(Boolean));
        });
      });
    }
    function modify(fn) {
      if (~modifiers.indexOf(fn)) return false;
      modifiers.push(fn);
      return true;
    }
    function write() {
      logger.apply(logger, arguments);
    }
    function process2(message) {
      for (var i = 0; i < modifiers.length; i++) {
        message = modifiers[i].apply(modifiers[i], arguments);
      }
      return message;
    }
    function introduce(fn, options) {
      var has = Object.prototype.hasOwnProperty;
      for (var key in options) {
        if (has.call(options, key)) {
          fn[key] = options[key];
        }
      }
      return fn;
    }
    function nope(options) {
      options.enabled = false;
      options.modify = modify;
      options.set = set;
      options.use = use;
      return introduce(function diagnopes() {
        return false;
      }, options);
    }
    function yep(options) {
      function diagnostics() {
        var args = Array.prototype.slice.call(arguments, 0);
        write.call(write, options, process2(args, options));
        return true;
      }
      options.enabled = true;
      options.modify = modify;
      options.set = set;
      options.use = use;
      return introduce(diagnostics, options);
    }
    module2.exports = function create(diagnostics) {
      diagnostics.introduce = introduce;
      diagnostics.enabled = enabled;
      diagnostics.process = process2;
      diagnostics.modify = modify;
      diagnostics.write = write;
      diagnostics.nope = nope;
      diagnostics.yep = yep;
      diagnostics.set = set;
      diagnostics.use = use;
      return diagnostics;
    };
  }
});

// node_modules/@dabh/diagnostics/node/production.js
var require_production = __commonJS({
  "node_modules/@dabh/diagnostics/node/production.js"(exports2, module2) {
    var create = require_diagnostics();
    var diagnostics = create(function prod(namespace, options) {
      options = options || {};
      options.namespace = namespace;
      options.prod = true;
      options.dev = false;
      if (!(options.force || prod.force)) return prod.nope(options);
      return prod.yep(options);
    });
    module2.exports = diagnostics;
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports2, module2) {
    module2.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports2, module2) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle = module2.exports = function swizzle2(args) {
      var results = [];
      for (var i = 0, len = args.length; i < len; i++) {
        var arg = args[i];
        if (isArrayish(arg)) {
          results = concat.call(results, slice.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports2, module2) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module2.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match;
      var i;
      var hexAlpha;
      if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for (i = 0; i < 3; i++) {
          var i2 = i * 2;
          rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty.call(colorNames, match[1])) {
          return null;
        }
        rgb = colorNames[match[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i = 0; i < 3; i++) {
        rgb[i] = clamp(rgb[i], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var s = clamp(parseFloat(match[2]), 0, 100);
        var l = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var w = clamp(parseFloat(match[2]), 0, 100);
        var b = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r = Math.round(rgba[0] / 255 * 100);
      var g = Math.round(rgba[1] / 255 * 100);
      var b = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/color/index.js
var require_color = __commonJS({
  "node_modules/color/index.js"(exports2, module2) {
    "use strict";
    var colorString = require_color_string();
    var convert = require_color_convert();
    var _slice = [].slice;
    var skippedModels = [
      // to be honest, I don't really feel like keyword belongs in color convert, but eh.
      "keyword",
      // gray conflicts with some method names, and has its own method defined.
      "gray",
      // shouldn't really be in color-convert either...
      "hex"
    ];
    var hashedModelKeys = {};
    Object.keys(convert).forEach(function(model) {
      hashedModelKeys[_slice.call(convert[model].labels).sort().join("")] = model;
    });
    var limiters = {};
    function Color(obj, model) {
      if (!(this instanceof Color)) {
        return new Color(obj, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      var i;
      var channels;
      if (obj == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (obj instanceof Color) {
        this.model = obj.model;
        this.color = obj.color.slice();
        this.valpha = obj.valpha;
      } else if (typeof obj === "string") {
        var result = colorString.get(obj);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + obj);
        }
        this.model = result.model;
        channels = convert[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (obj.length) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        var newArr = _slice.call(obj, 0, channels);
        this.color = zeroArray(newArr, channels);
        this.valpha = typeof obj[channels] === "number" ? obj[channels] : 1;
      } else if (typeof obj === "number") {
        obj &= 16777215;
        this.model = "rgb";
        this.color = [
          obj >> 16 & 255,
          obj >> 8 & 255,
          obj & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        var keys = Object.keys(obj);
        if ("alpha" in obj) {
          keys.splice(keys.indexOf("alpha"), 1);
          this.valpha = typeof obj.alpha === "number" ? obj.alpha : 0;
        }
        var hashedKeys = keys.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(obj));
        }
        this.model = hashedModelKeys[hashedKeys];
        var labels = convert[this.model].labels;
        var color = [];
        for (i = 0; i < labels.length; i++) {
          color.push(obj[labels[i]]);
        }
        this.color = zeroArray(color);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i = 0; i < channels; i++) {
          var limit = limiters[this.model][i];
          if (limit) {
            this.color[i] = limit(this.color[i]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color.prototype = {
      toString: function() {
        return this.string();
      },
      toJSON: function() {
        return this[this.model]();
      },
      string: function(places) {
        var self2 = this.model in colorString.to ? this : this.rgb();
        self2 = self2.round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to[self2.model](args);
      },
      percentString: function(places) {
        var self2 = this.rgb().round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to.rgb.percent(args);
      },
      array: function() {
        return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
      },
      object: function() {
        var result = {};
        var channels = convert[this.model].channels;
        var labels = convert[this.model].labels;
        for (var i = 0; i < channels; i++) {
          result[labels[i]] = this.color[i];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray: function() {
        var rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
          rgb.push(this.valpha);
        }
        return rgb;
      },
      unitObject: function() {
        var rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
          rgb.alpha = this.valpha;
        }
        return rgb;
      },
      round: function(places) {
        places = Math.max(places || 0, 0);
        return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
      },
      alpha: function(val) {
        if (arguments.length) {
          return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
        }
        return this.valpha;
      },
      // rgb
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(val) {
        return (val % 360 + 360) % 360;
      }),
      // eslint-disable-line brace-style
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(100)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(100)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword: function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return convert[this.model].keyword(this.color);
      },
      hex: function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return colorString.to.hex(this.rgb().round().color);
      },
      rgbNumber: function() {
        var rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
      },
      luminosity: function() {
        var rgb = this.rgb().color;
        var lum = [];
        for (var i = 0; i < rgb.length; i++) {
          var chan = rgb[i] / 255;
          lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function(color2) {
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function(color2) {
        var contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7.1) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark: function() {
        var rgb = this.rgb().color;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
        return yiq < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      negate: function() {
        var rgb = this.rgb();
        for (var i = 0; i < 3; i++) {
          rgb.color[i] = 255 - rgb.color[i];
        }
        return rgb;
      },
      lighten: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
      },
      darken: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
      },
      saturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
      },
      desaturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
      },
      whiten: function(ratio) {
        var hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken: function(ratio) {
        var hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale: function() {
        var rgb = this.rgb().color;
        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color.rgb(val, val, val);
      },
      fade: function(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer: function(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate: function(degrees) {
        var hsl = this.hsl();
        var hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
      },
      mix: function(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        var color1 = mixinColor.rgb();
        var color2 = this.rgb();
        var p = weight === void 0 ? 0.5 : weight;
        var w = 2 * p - 1;
        var a = color1.alpha() - color2.alpha();
        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        var w2 = 1 - w1;
        return Color.rgb(
          w1 * color1.red() + w2 * color2.red(),
          w1 * color1.green() + w2 * color2.green(),
          w1 * color1.blue() + w2 * color2.blue(),
          color1.alpha() * p + color2.alpha() * (1 - p)
        );
      }
    };
    Object.keys(convert).forEach(function(model) {
      if (skippedModels.indexOf(model) !== -1) {
        return;
      }
      var channels = convert[model].channels;
      Color.prototype[model] = function() {
        if (this.model === model) {
          return new Color(this);
        }
        if (arguments.length) {
          return new Color(arguments, model);
        }
        var newAlpha = typeof arguments[channels] === "number" ? channels : this.valpha;
        return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
      };
      Color[model] = function(color) {
        if (typeof color === "number") {
          color = zeroArray(_slice.call(arguments), channels);
        }
        return new Color(color, model);
      };
    });
    function roundTo(num, places) {
      return Number(num.toFixed(places));
    }
    function roundToPlace(places) {
      return function(num) {
        return roundTo(num, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      model.forEach(function(m) {
        (limiters[m] || (limiters[m] = []))[channel] = modifier;
      });
      model = model[0];
      return function(val) {
        var result;
        if (arguments.length) {
          if (modifier) {
            val = modifier(val);
          }
          result = this[model]();
          result.color[channel] = val;
          return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    function maxfn(max) {
      return function(v) {
        return Math.max(0, Math.min(max, v));
      };
    }
    function assertArray(val) {
      return Array.isArray(val) ? val : [val];
    }
    function zeroArray(arr, length) {
      for (var i = 0; i < length; i++) {
        if (typeof arr[i] !== "number") {
          arr[i] = 0;
        }
      }
      return arr;
    }
    module2.exports = Color;
  }
});

// node_modules/text-hex/index.js
var require_text_hex = __commonJS({
  "node_modules/text-hex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function hex(str) {
      for (var i = 0, hash = 0; i < str.length; hash = str.charCodeAt(i++) + ((hash << 5) - hash)) ;
      var color = Math.floor(
        Math.abs(
          Math.sin(hash) * 1e4 % 1 * 16777216
        )
      ).toString(16);
      return "#" + Array(6 - color.length + 1).join("0") + color;
    };
  }
});

// node_modules/colorspace/index.js
var require_colorspace = __commonJS({
  "node_modules/colorspace/index.js"(exports2, module2) {
    "use strict";
    var color = require_color();
    var hex = require_text_hex();
    module2.exports = function colorspace(namespace, delimiter) {
      var split = namespace.split(delimiter || ":");
      var base = hex(split[0]);
      if (!split.length) return base;
      for (var i = 0, l = split.length - 1; i < l; i++) {
        base = color(base).mix(color(hex(split[i + 1]))).saturate(1).hex();
      }
      return base;
    };
  }
});

// node_modules/kuler/index.js
var require_kuler = __commonJS({
  "node_modules/kuler/index.js"(exports2, module2) {
    "use strict";
    function Kuler(text, color) {
      if (color) return new Kuler(text).style(color);
      if (!(this instanceof Kuler)) return new Kuler(text);
      this.text = text;
    }
    Kuler.prototype.prefix = "\x1B[";
    Kuler.prototype.suffix = "m";
    Kuler.prototype.hex = function hex(color) {
      color = color[0] === "#" ? color.substring(1) : color;
      if (color.length === 3) {
        color = color.split("");
        color[5] = color[2];
        color[4] = color[2];
        color[3] = color[1];
        color[2] = color[1];
        color[1] = color[0];
        color = color.join("");
      }
      var r = color.substring(0, 2), g = color.substring(2, 4), b = color.substring(4, 6);
      return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
    };
    Kuler.prototype.rgb = function rgb(r, g, b) {
      var red = r / 255 * 5, green = g / 255 * 5, blue = b / 255 * 5;
      return this.ansi(red, green, blue);
    };
    Kuler.prototype.ansi = function ansi(r, g, b) {
      var red = Math.round(r), green = Math.round(g), blue = Math.round(b);
      return 16 + red * 36 + green * 6 + blue;
    };
    Kuler.prototype.reset = function reset() {
      return this.prefix + "39;49" + this.suffix;
    };
    Kuler.prototype.style = function style(color) {
      return this.prefix + "38;5;" + this.rgb.apply(this, this.hex(color)) + this.suffix + this.text + this.reset();
    };
    module2.exports = Kuler;
  }
});

// node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js
var require_namespace_ansi = __commonJS({
  "node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js"(exports2, module2) {
    var colorspace = require_colorspace();
    var kuler = require_kuler();
    module2.exports = function ansiModifier(args, options) {
      var namespace = options.namespace;
      var ansi = options.colors !== false ? kuler(namespace + ":", colorspace(namespace)) : namespace + ":";
      args[0] = ansi + " " + args[0];
      return args;
    };
  }
});

// node_modules/enabled/index.js
var require_enabled = __commonJS({
  "node_modules/enabled/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function enabled(name, variable) {
      if (!variable) return false;
      var variables = variable.split(/[\s,]+/), i = 0;
      for (; i < variables.length; i++) {
        variable = variables[i].replace("*", ".*?");
        if ("-" === variable.charAt(0)) {
          if (new RegExp("^" + variable.substr(1) + "$").test(name)) {
            return false;
          }
          continue;
        }
        if (new RegExp("^" + variable + "$").test(name)) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/@dabh/diagnostics/adapters/index.js
var require_adapters = __commonJS({
  "node_modules/@dabh/diagnostics/adapters/index.js"(exports2, module2) {
    var enabled = require_enabled();
    module2.exports = function create(fn) {
      return function adapter(namespace) {
        try {
          return enabled(namespace, fn());
        } catch (e) {
        }
        return false;
      };
    };
  }
});

// node_modules/@dabh/diagnostics/adapters/process.env.js
var require_process_env = __commonJS({
  "node_modules/@dabh/diagnostics/adapters/process.env.js"(exports2, module2) {
    var adapter = require_adapters();
    module2.exports = adapter(function processenv() {
      return process.env.DEBUG || process.env.DIAGNOSTICS;
    });
  }
});

// node_modules/@dabh/diagnostics/logger/console.js
var require_console2 = __commonJS({
  "node_modules/@dabh/diagnostics/logger/console.js"(exports2, module2) {
    module2.exports = function(meta, messages) {
      try {
        Function.prototype.apply.call(console.log, console, messages);
      } catch (e) {
      }
    };
  }
});

// node_modules/@dabh/diagnostics/node/development.js
var require_development = __commonJS({
  "node_modules/@dabh/diagnostics/node/development.js"(exports2, module2) {
    var create = require_diagnostics();
    var tty = require("tty").isatty(1);
    var diagnostics = create(function dev(namespace, options) {
      options = options || {};
      options.colors = "colors" in options ? options.colors : tty;
      options.namespace = namespace;
      options.prod = false;
      options.dev = true;
      if (!dev.enabled(namespace) && !(options.force || dev.force)) {
        return dev.nope(options);
      }
      return dev.yep(options);
    });
    diagnostics.modify(require_namespace_ansi());
    diagnostics.use(require_process_env());
    diagnostics.set(require_console2());
    module2.exports = diagnostics;
  }
});

// node_modules/@dabh/diagnostics/node/index.js
var require_node2 = __commonJS({
  "node_modules/@dabh/diagnostics/node/index.js"(exports2, module2) {
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_production();
    } else {
      module2.exports = require_development();
    }
  }
});

// node_modules/winston/lib/winston/tail-file.js
var require_tail_file = __commonJS({
  "node_modules/winston/lib/winston/tail-file.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var { StringDecoder } = require("string_decoder");
    var { Stream } = require_readable();
    function noop() {
    }
    module2.exports = (options, iter) => {
      const buffer = Buffer.alloc(64 * 1024);
      const decode = new StringDecoder("utf8");
      const stream = new Stream();
      let buff = "";
      let pos = 0;
      let row = 0;
      if (options.start === -1) {
        delete options.start;
      }
      stream.readable = true;
      stream.destroy = () => {
        stream.destroyed = true;
        stream.emit("end");
        stream.emit("close");
      };
      fs.open(options.file, "a+", "0644", (err, fd) => {
        if (err) {
          if (!iter) {
            stream.emit("error", err);
          } else {
            iter(err);
          }
          stream.destroy();
          return;
        }
        (function read() {
          if (stream.destroyed) {
            fs.close(fd, noop);
            return;
          }
          return fs.read(fd, buffer, 0, buffer.length, pos, (error, bytes) => {
            if (error) {
              if (!iter) {
                stream.emit("error", error);
              } else {
                iter(error);
              }
              stream.destroy();
              return;
            }
            if (!bytes) {
              if (buff) {
                if (options.start == null || row > options.start) {
                  if (!iter) {
                    stream.emit("line", buff);
                  } else {
                    iter(null, buff);
                  }
                }
                row++;
                buff = "";
              }
              return setTimeout(read, 1e3);
            }
            let data = decode.write(buffer.slice(0, bytes));
            if (!iter) {
              stream.emit("data", data);
            }
            data = (buff + data).split(/\n+/);
            const l = data.length - 1;
            let i = 0;
            for (; i < l; i++) {
              if (options.start == null || row > options.start) {
                if (!iter) {
                  stream.emit("line", data[i]);
                } else {
                  iter(null, data[i]);
                }
              }
              row++;
            }
            buff = data[l];
            pos += bytes;
            return read();
          });
        })();
      });
      if (!iter) {
        return stream;
      }
      return stream.destroy;
    };
  }
});

// node_modules/winston/lib/winston/transports/file.js
var require_file = __commonJS({
  "node_modules/winston/lib/winston/transports/file.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var asyncSeries = require_series();
    var zlib = require("zlib");
    var { MESSAGE } = require_triple_beam();
    var { Stream, PassThrough } = require_readable();
    var TransportStream = require_winston_transport();
    var debug = require_node2()("winston:file");
    var os = require("os");
    var tailFile = require_tail_file();
    module2.exports = class File extends TransportStream {
      /**
       * Constructor function for the File transport object responsible for
       * persisting log messages and metadata to one or more files.
       * @param {Object} options - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        this.name = options.name || "file";
        function throwIf(target, ...args) {
          args.slice(1).forEach((name) => {
            if (options[name]) {
              throw new Error(`Cannot set ${name} and ${target} together`);
            }
          });
        }
        this._stream = new PassThrough();
        this._stream.setMaxListeners(30);
        this._onError = this._onError.bind(this);
        if (options.filename || options.dirname) {
          throwIf("filename or dirname", "stream");
          this._basename = this.filename = options.filename ? path.basename(options.filename) : "winston.log";
          this.dirname = options.dirname || path.dirname(options.filename);
          this.options = options.options || { flags: "a" };
        } else if (options.stream) {
          console.warn("options.stream will be removed in winston@4. Use winston.transports.Stream");
          throwIf("stream", "filename", "maxsize");
          this._dest = this._stream.pipe(this._setupStream(options.stream));
          this.dirname = path.dirname(this._dest.path);
        } else {
          throw new Error("Cannot log to file without filename or stream.");
        }
        this.maxsize = options.maxsize || null;
        this.rotationFormat = options.rotationFormat || false;
        this.zippedArchive = options.zippedArchive || false;
        this.maxFiles = options.maxFiles || null;
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
        this.tailable = options.tailable || false;
        this._size = 0;
        this._pendingSize = 0;
        this._created = 0;
        this._drain = false;
        this._opening = false;
        this._ending = false;
        if (this.dirname) this._createLogDirIfNotExist(this.dirname);
        this.open();
      }
      finishIfEnding() {
        if (this._ending) {
          if (this._opening) {
            this.once("open", () => {
              this._stream.once("finish", () => this.emit("finish"));
              setImmediate(() => this._stream.end());
            });
          } else {
            this._stream.once("finish", () => this.emit("finish"));
            setImmediate(() => this._stream.end());
          }
        }
      }
      /**
       * Core logging method exposed to Winston. Metadata is optional.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback = () => {
      }) {
        if (this.silent) {
          callback();
          return true;
        }
        if (this._drain) {
          this._stream.once("drain", () => {
            this._drain = false;
            this.log(info, callback);
          });
          return;
        }
        if (this._rotate) {
          this._stream.once("rotate", () => {
            this._rotate = false;
            this.log(info, callback);
          });
          return;
        }
        const output = `${info[MESSAGE]}${this.eol}`;
        const bytes = Buffer.byteLength(output);
        function logged() {
          this._size += bytes;
          this._pendingSize -= bytes;
          debug("logged %s %s", this._size, output);
          this.emit("logged", info);
          if (this._opening) {
            return;
          }
          if (!this._needsNewFile()) {
            return;
          }
          this._rotate = true;
          this._endStream(() => this._rotateFile());
        }
        this._pendingSize += bytes;
        if (this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize)) {
          this.rotatedWhileOpening = true;
        }
        const written = this._stream.write(output, logged.bind(this));
        if (!written) {
          this._drain = true;
          this._stream.once("drain", () => {
            this._drain = false;
            callback();
          });
        } else {
          callback();
        }
        debug("written", written, this._drain);
        this.finishIfEnding();
        return written;
      }
      /**
       * Query the transport. Options object is optional.
       * @param {Object} options - Loggly-like query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       * TODO: Refactor me.
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = normalizeQuery(options);
        const file = path.join(this.dirname, this.filename);
        let buff = "";
        let results = [];
        let row = 0;
        const stream = fs.createReadStream(file, {
          encoding: "utf8"
        });
        stream.on("error", (err) => {
          if (stream.readable) {
            stream.destroy();
          }
          if (!callback) {
            return;
          }
          return err.code !== "ENOENT" ? callback(err) : callback(null, results);
        });
        stream.on("data", (data) => {
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (; i < l; i++) {
            if (!options.start || row >= options.start) {
              add(data[i]);
            }
            row++;
          }
          buff = data[l];
        });
        stream.on("close", () => {
          if (buff) {
            add(buff, true);
          }
          if (options.order === "desc") {
            results = results.reverse();
          }
          if (callback) callback(null, results);
        });
        function add(buff2, attempt) {
          try {
            const log = JSON.parse(buff2);
            if (check(log)) {
              push(log);
            }
          } catch (e) {
            if (!attempt) {
              stream.emit("error", e);
            }
          }
        }
        function push(log) {
          if (options.rows && results.length >= options.rows && options.order !== "desc") {
            if (stream.readable) {
              stream.destroy();
            }
            return;
          }
          if (options.fields) {
            log = options.fields.reduce((obj, key) => {
              obj[key] = log[key];
              return obj;
            }, {});
          }
          if (options.order === "desc") {
            if (results.length >= options.rows) {
              results.shift();
            }
          }
          results.push(log);
        }
        function check(log) {
          if (!log) {
            return;
          }
          if (typeof log !== "object") {
            return;
          }
          const time = new Date(log.timestamp);
          if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {
            return;
          }
          return true;
        }
        function normalizeQuery(options2) {
          options2 = options2 || {};
          options2.rows = options2.rows || options2.limit || 10;
          options2.start = options2.start || 0;
          options2.until = options2.until || /* @__PURE__ */ new Date();
          if (typeof options2.until !== "object") {
            options2.until = new Date(options2.until);
          }
          options2.from = options2.from || options2.until - 24 * 60 * 60 * 1e3;
          if (typeof options2.from !== "object") {
            options2.from = new Date(options2.from);
          }
          options2.order = options2.order || "desc";
          return options2;
        }
      }
      /**
       * Returns a log stream for this transport. Options object is optional.
       * @param {Object} options - Stream options for this instance.
       * @returns {Stream} - TODO: add return description.
       * TODO: Refactor me.
       */
      stream(options = {}) {
        const file = path.join(this.dirname, this.filename);
        const stream = new Stream();
        const tail = {
          file,
          start: options.start
        };
        stream.destroy = tailFile(tail, (err, line) => {
          if (err) {
            return stream.emit("error", err);
          }
          try {
            stream.emit("data", line);
            line = JSON.parse(line);
            stream.emit("log", line);
          } catch (e) {
            stream.emit("error", e);
          }
        });
        return stream;
      }
      /**
       * Checks to see the filesize of.
       * @returns {undefined}
       */
      open() {
        if (!this.filename) return;
        if (this._opening) return;
        this._opening = true;
        this.stat((err, size) => {
          if (err) {
            return this.emit("error", err);
          }
          debug("stat done: %s { size: %s }", this.filename, size);
          this._size = size;
          this._dest = this._createStream(this._stream);
          this._opening = false;
          this.once("open", () => {
            if (this._stream.eventNames().includes("rotate")) {
              this._stream.emit("rotate");
            } else {
              this._rotate = false;
            }
          });
        });
      }
      /**
       * Stat the file and assess information in order to create the proper stream.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      stat(callback) {
        const target = this._getFile();
        const fullpath = path.join(this.dirname, target);
        fs.stat(fullpath, (err, stat) => {
          if (err && err.code === "ENOENT") {
            debug("ENOENT\xA0ok", fullpath);
            this.filename = target;
            return callback(null, 0);
          }
          if (err) {
            debug(`err ${err.code} ${fullpath}`);
            return callback(err);
          }
          if (!stat || this._needsNewFile(stat.size)) {
            return this._incFile(() => this.stat(callback));
          }
          this.filename = target;
          callback(null, stat.size);
        });
      }
      /**
       * Closes the stream associated with this instance.
       * @param {function} cb - TODO: add param description.
       * @returns {undefined}
       */
      close(cb) {
        if (!this._stream) {
          return;
        }
        this._stream.end(() => {
          if (cb) {
            cb();
          }
          this.emit("flush");
          this.emit("closed");
        });
      }
      /**
       * TODO: add method description.
       * @param {number} size - TODO: add param description.
       * @returns {undefined}
       */
      _needsNewFile(size) {
        size = size || this._size;
        return this.maxsize && size >= this.maxsize;
      }
      /**
       * TODO: add method description.
       * @param {Error} err - TODO: add param description.
       * @returns {undefined}
       */
      _onError(err) {
        this.emit("error", err);
      }
      /**
       * TODO: add method description.
       * @param {Stream} stream - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      _setupStream(stream) {
        stream.on("error", this._onError);
        return stream;
      }
      /**
       * TODO: add method description.
       * @param {Stream} stream - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      _cleanupStream(stream) {
        stream.removeListener("error", this._onError);
        return stream;
      }
      /**
       * TODO: add method description.
       */
      _rotateFile() {
        this._incFile(() => this.open());
      }
      /**
       * Unpipe from the stream that has been marked as full and end it so it
       * flushes to disk.
       *
       * @param {function} callback - Callback for when the current file has closed.
       * @private
       */
      _endStream(callback = () => {
      }) {
        if (this._dest) {
          this._stream.unpipe(this._dest);
          this._dest.end(() => {
            this._cleanupStream(this._dest);
            callback();
          });
        } else {
          callback();
        }
      }
      /**
       * Returns the WritableStream for the active file on this instance. If we
       * should gzip the file then a zlib stream is returned.
       *
       * @param {ReadableStream} source PassThrough to pipe to the file when open.
       * @returns {WritableStream} Stream that writes to disk for the active file.
       */
      _createStream(source) {
        const fullpath = path.join(this.dirname, this.filename);
        debug("create stream start", fullpath, this.options);
        const dest = fs.createWriteStream(fullpath, this.options).on("error", (err) => debug(err)).on("close", () => debug("close", dest.path, dest.bytesWritten)).on("open", () => {
          debug("file open ok", fullpath);
          this.emit("open", fullpath);
          source.pipe(dest);
          if (this.rotatedWhileOpening) {
            this._stream = new PassThrough();
            this._stream.setMaxListeners(30);
            this._rotateFile();
            this.rotatedWhileOpening = false;
            this._cleanupStream(dest);
            source.end();
          }
        });
        debug("create stream ok", fullpath);
        if (this.zippedArchive) {
          const gzip = zlib.createGzip();
          gzip.pipe(dest);
          return gzip;
        }
        return dest;
      }
      /**
       * TODO: add method description.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      _incFile(callback) {
        debug("_incFile", this.filename);
        const ext = path.extname(this._basename);
        const basename = path.basename(this._basename, ext);
        if (!this.tailable) {
          this._created += 1;
          this._checkMaxFilesIncrementing(ext, basename, callback);
        } else {
          this._checkMaxFilesTailable(ext, basename, callback);
        }
      }
      /**
       * Gets the next filename to use for this instance in the case that log
       * filesizes are being capped.
       * @returns {string} - TODO: add return description.
       * @private
       */
      _getFile() {
        const ext = path.extname(this._basename);
        const basename = path.basename(this._basename, ext);
        const isRotation = this.rotationFormat ? this.rotationFormat() : this._created;
        const target = !this.tailable && this._created ? `${basename}${isRotation}${ext}` : `${basename}${ext}`;
        return this.zippedArchive && !this.tailable ? `${target}.gz` : target;
      }
      /**
       * Increment the number of files created or checked by this instance.
       * @param {mixed} ext - TODO: add param description.
       * @param {mixed} basename - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {undefined}
       * @private
       */
      _checkMaxFilesIncrementing(ext, basename, callback) {
        if (!this.maxFiles || this._created < this.maxFiles) {
          return setImmediate(callback);
        }
        const oldest = this._created - this.maxFiles;
        const isOldest = oldest !== 0 ? oldest : "";
        const isZipped = this.zippedArchive ? ".gz" : "";
        const filePath = `${basename}${isOldest}${ext}${isZipped}`;
        const target = path.join(this.dirname, filePath);
        fs.unlink(target, callback);
      }
      /**
       * Roll files forward based on integer, up to maxFiles. e.g. if base if
       * file.log and it becomes oversized, roll to file1.log, and allow file.log
       * to be re-used. If file is oversized again, roll file1.log to file2.log,
       * roll file.log to file1.log, and so on.
       * @param {mixed} ext - TODO: add param description.
       * @param {mixed} basename - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {undefined}
       * @private
       */
      _checkMaxFilesTailable(ext, basename, callback) {
        const tasks = [];
        if (!this.maxFiles) {
          return;
        }
        const isZipped = this.zippedArchive ? ".gz" : "";
        for (let x = this.maxFiles - 1; x > 1; x--) {
          tasks.push(function(i, cb) {
            let fileName = `${basename}${i - 1}${ext}${isZipped}`;
            const tmppath = path.join(this.dirname, fileName);
            fs.exists(tmppath, (exists) => {
              if (!exists) {
                return cb(null);
              }
              fileName = `${basename}${i}${ext}${isZipped}`;
              fs.rename(tmppath, path.join(this.dirname, fileName), cb);
            });
          }.bind(this, x));
        }
        asyncSeries(tasks, () => {
          fs.rename(
            path.join(this.dirname, `${basename}${ext}`),
            path.join(this.dirname, `${basename}1${ext}${isZipped}`),
            callback
          );
        });
      }
      _createLogDirIfNotExist(dirPath) {
        if (!fs.existsSync(dirPath)) {
          fs.mkdirSync(dirPath, { recursive: true });
        }
      }
    };
  }
});

// node_modules/winston/lib/winston/transports/http.js
var require_http = __commonJS({
  "node_modules/winston/lib/winston/transports/http.js"(exports2, module2) {
    "use strict";
    var http = require("http");
    var https = require("https");
    var { Stream } = require_readable();
    var TransportStream = require_winston_transport();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = class Http extends TransportStream {
      /**
       * Constructor function for the Http transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      // eslint-disable-next-line max-statements
      constructor(options = {}) {
        super(options);
        this.options = options;
        this.name = options.name || "http";
        this.ssl = !!options.ssl;
        this.host = options.host || "localhost";
        this.port = options.port;
        this.auth = options.auth;
        this.path = options.path || "";
        this.agent = options.agent;
        this.headers = options.headers || {};
        this.headers["content-type"] = "application/json";
        this.batch = options.batch || false;
        this.batchInterval = options.batchInterval || 5e3;
        this.batchCount = options.batchCount || 10;
        this.batchOptions = [];
        this.batchTimeoutID = -1;
        this.batchCallback = {};
        if (!this.port) {
          this.port = this.ssl ? 443 : 80;
        }
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        this._request(info, (err, res) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            this.emit("warn", err);
          } else {
            this.emit("logged", info);
          }
        });
        if (callback) {
          setImmediate(callback);
        }
      }
      /**
       * Query the transport. Options object is optional.
       * @param {Object} options -  Loggly-like query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       * @returns {undefined}
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = {
          method: "query",
          params: this.normalizeQuery(options)
        };
        if (options.params.path) {
          options.path = options.params.path;
          delete options.params.path;
        }
        if (options.params.auth) {
          options.auth = options.params.auth;
          delete options.params.auth;
        }
        this._request(options, (err, res, body) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            return callback(err);
          }
          if (typeof body === "string") {
            try {
              body = JSON.parse(body);
            } catch (e) {
              return callback(e);
            }
          }
          callback(null, body);
        });
      }
      /**
       * Returns a log stream for this transport. Options object is optional.
       * @param {Object} options - Stream options for this instance.
       * @returns {Stream} - TODO: add return description
       */
      stream(options = {}) {
        const stream = new Stream();
        options = {
          method: "stream",
          params: options
        };
        if (options.params.path) {
          options.path = options.params.path;
          delete options.params.path;
        }
        if (options.params.auth) {
          options.auth = options.params.auth;
          delete options.params.auth;
        }
        let buff = "";
        const req = this._request(options);
        stream.destroy = () => req.destroy();
        req.on("data", (data) => {
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (; i < l; i++) {
            try {
              stream.emit("log", JSON.parse(data[i]));
            } catch (e) {
              stream.emit("error", e);
            }
          }
          buff = data[l];
        });
        req.on("error", (err) => stream.emit("error", err));
        return stream;
      }
      /**
       * Make a request to a winstond server or any http server which can
       * handle json-rpc.
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       */
      _request(options, callback) {
        options = options || {};
        const auth = options.auth || this.auth;
        const path = options.path || this.path || "";
        delete options.auth;
        delete options.path;
        if (this.batch) {
          this._doBatch(options, callback, auth, path);
        } else {
          this._doRequest(options, callback, auth, path);
        }
      }
      /**
       * Send or memorize the options according to batch configuration
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doBatch(options, callback, auth, path) {
        this.batchOptions.push(options);
        if (this.batchOptions.length === 1) {
          const me = this;
          this.batchCallback = callback;
          this.batchTimeoutID = setTimeout(function() {
            me.batchTimeoutID = -1;
            me._doBatchRequest(me.batchCallback, auth, path);
          }, this.batchInterval);
        }
        if (this.batchOptions.length === this.batchCount) {
          this._doBatchRequest(this.batchCallback, auth, path);
        }
      }
      /**
       * Initiate a request with the memorized batch options, stop the batch timeout
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doBatchRequest(callback, auth, path) {
        if (this.batchTimeoutID > 0) {
          clearTimeout(this.batchTimeoutID);
          this.batchTimeoutID = -1;
        }
        const batchOptionsCopy = this.batchOptions.slice();
        this.batchOptions = [];
        this._doRequest(batchOptionsCopy, callback, auth, path);
      }
      /**
       * Make a request to a winstond server or any http server which can
       * handle json-rpc.
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doRequest(options, callback, auth, path) {
        const headers = Object.assign({}, this.headers);
        if (auth && auth.bearer) {
          headers.Authorization = `Bearer ${auth.bearer}`;
        }
        const req = (this.ssl ? https : http).request({
          ...this.options,
          method: "POST",
          host: this.host,
          port: this.port,
          path: `/${path.replace(/^\//, "")}`,
          headers,
          auth: auth && auth.username && auth.password ? `${auth.username}:${auth.password}` : "",
          agent: this.agent
        });
        req.on("error", callback);
        req.on("response", (res) => res.on("end", () => callback(null, res)).resume());
        req.end(Buffer.from(jsonStringify(options, this.options.replacer), "utf8"));
      }
    };
  }
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "node_modules/is-stream/index.js"(exports2, module2) {
    "use strict";
    var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
    isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
    module2.exports = isStream;
  }
});

// node_modules/winston/lib/winston/transports/stream.js
var require_stream2 = __commonJS({
  "node_modules/winston/lib/winston/transports/stream.js"(exports2, module2) {
    "use strict";
    var isStream = require_is_stream();
    var { MESSAGE } = require_triple_beam();
    var os = require("os");
    var TransportStream = require_winston_transport();
    module2.exports = class Stream extends TransportStream {
      /**
       * Constructor function for the Console transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        if (!options.stream || !isStream(options.stream)) {
          throw new Error("options.stream is required.");
        }
        this._stream = options.stream;
        this._stream.setMaxListeners(Infinity);
        this.isObjectMode = options.stream._writableState.objectMode;
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.isObjectMode) {
          this._stream.write(info);
          if (callback) {
            callback();
          }
          return;
        }
        this._stream.write(`${info[MESSAGE]}${this.eol}`);
        if (callback) {
          callback();
        }
        return;
      }
    };
  }
});

// node_modules/winston/lib/winston/transports/index.js
var require_transports = __commonJS({
  "node_modules/winston/lib/winston/transports/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "Console", {
      configurable: true,
      enumerable: true,
      get() {
        return require_console();
      }
    });
    Object.defineProperty(exports2, "File", {
      configurable: true,
      enumerable: true,
      get() {
        return require_file();
      }
    });
    Object.defineProperty(exports2, "Http", {
      configurable: true,
      enumerable: true,
      get() {
        return require_http();
      }
    });
    Object.defineProperty(exports2, "Stream", {
      configurable: true,
      enumerable: true,
      get() {
        return require_stream2();
      }
    });
  }
});

// node_modules/winston/lib/winston/config/index.js
var require_config2 = __commonJS({
  "node_modules/winston/lib/winston/config/index.js"(exports2) {
    "use strict";
    var logform = require_logform();
    var { configs } = require_triple_beam();
    exports2.cli = logform.levels(configs.cli);
    exports2.npm = logform.levels(configs.npm);
    exports2.syslog = logform.levels(configs.syslog);
    exports2.addColors = logform.levels;
  }
});

// node_modules/async/eachOf.js
var require_eachOf = __commonJS({
  "node_modules/async/eachOf.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = (0, _once2.default)(callback);
      var index = 0, completed = 0, { length } = coll, canceled = false;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err === false) {
          canceled = true;
        }
        if (canceled === true) return;
        if (err) {
          callback(err);
        } else if (++completed === length || value === _breakLoop2.default) {
          callback(null);
        }
      }
      for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
      }
    }
    function eachOfGeneric(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
    }
    function eachOf(coll, iteratee, callback) {
      var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
      return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOf, 3);
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS({
  "node_modules/async/internal/withoutIndex.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _withoutIndex;
    function _withoutIndex(iteratee) {
      return (value, index, callback) => iteratee(value, callback);
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/forEach.js
var require_forEach = __commonJS({
  "node_modules/async/forEach.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault(_eachOf);
    var _withoutIndex = require_withoutIndex();
    var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachLimit(coll, iteratee, callback) {
      return (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachLimit, 3);
    module2.exports = exports2["default"];
  }
});

// node_modules/fn.name/index.js
var require_fn = __commonJS({
  "node_modules/fn.name/index.js"(exports2, module2) {
    "use strict";
    var toString = Object.prototype.toString;
    module2.exports = function name(fn) {
      if ("string" === typeof fn.displayName && fn.constructor.name) {
        return fn.displayName;
      } else if ("string" === typeof fn.name && fn.name) {
        return fn.name;
      }
      if ("object" === typeof fn && fn.constructor && "string" === typeof fn.constructor.name) return fn.constructor.name;
      var named = fn.toString(), type = toString.call(fn).slice(8, -1);
      if ("Function" === type) {
        named = named.substring(named.indexOf("(") + 1, named.indexOf(")"));
      } else {
        named = type;
      }
      return named || "anonymous";
    };
  }
});

// node_modules/one-time/index.js
var require_one_time = __commonJS({
  "node_modules/one-time/index.js"(exports2, module2) {
    "use strict";
    var name = require_fn();
    module2.exports = function one(fn) {
      var called = 0, value;
      function onetime() {
        if (called) return value;
        called = 1;
        value = fn.apply(this, arguments);
        fn = null;
        return value;
      }
      onetime.displayName = name(fn);
      return onetime;
    };
  }
});

// node_modules/stack-trace/lib/stack-trace.js
var require_stack_trace = __commonJS({
  "node_modules/stack-trace/lib/stack-trace.js"(exports2) {
    exports2.get = function(belowFn) {
      var oldLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Infinity;
      var dummyObject = {};
      var v8Handler = Error.prepareStackTrace;
      Error.prepareStackTrace = function(dummyObject2, v8StackTrace2) {
        return v8StackTrace2;
      };
      Error.captureStackTrace(dummyObject, belowFn || exports2.get);
      var v8StackTrace = dummyObject.stack;
      Error.prepareStackTrace = v8Handler;
      Error.stackTraceLimit = oldLimit;
      return v8StackTrace;
    };
    exports2.parse = function(err) {
      if (!err.stack) {
        return [];
      }
      var self2 = this;
      var lines = err.stack.split("\n").slice(1);
      return lines.map(function(line) {
        if (line.match(/^\s*[-]{4,}$/)) {
          return self2._createParsedCallSite({
            fileName: line,
            lineNumber: null,
            functionName: null,
            typeName: null,
            methodName: null,
            columnNumber: null,
            "native": null
          });
        }
        var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
        if (!lineMatch) {
          return;
        }
        var object = null;
        var method = null;
        var functionName = null;
        var typeName = null;
        var methodName = null;
        var isNative = lineMatch[5] === "native";
        if (lineMatch[1]) {
          functionName = lineMatch[1];
          var methodStart = functionName.lastIndexOf(".");
          if (functionName[methodStart - 1] == ".")
            methodStart--;
          if (methodStart > 0) {
            object = functionName.substr(0, methodStart);
            method = functionName.substr(methodStart + 1);
            var objectEnd = object.indexOf(".Module");
            if (objectEnd > 0) {
              functionName = functionName.substr(objectEnd + 1);
              object = object.substr(0, objectEnd);
            }
          }
          typeName = null;
        }
        if (method) {
          typeName = object;
          methodName = method;
        }
        if (method === "<anonymous>") {
          methodName = null;
          functionName = null;
        }
        var properties = {
          fileName: lineMatch[2] || null,
          lineNumber: parseInt(lineMatch[3], 10) || null,
          functionName,
          typeName,
          methodName,
          columnNumber: parseInt(lineMatch[4], 10) || null,
          "native": isNative
        };
        return self2._createParsedCallSite(properties);
      }).filter(function(callSite) {
        return !!callSite;
      });
    };
    function CallSite(properties) {
      for (var property in properties) {
        this[property] = properties[property];
      }
    }
    var strProperties = [
      "this",
      "typeName",
      "functionName",
      "methodName",
      "fileName",
      "lineNumber",
      "columnNumber",
      "function",
      "evalOrigin"
    ];
    var boolProperties = [
      "topLevel",
      "eval",
      "native",
      "constructor"
    ];
    strProperties.forEach(function(property) {
      CallSite.prototype[property] = null;
      CallSite.prototype["get" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    boolProperties.forEach(function(property) {
      CallSite.prototype[property] = false;
      CallSite.prototype["is" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    exports2._createParsedCallSite = function(properties) {
      return new CallSite(properties);
    };
  }
});

// node_modules/winston/lib/winston/exception-stream.js
var require_exception_stream = __commonJS({
  "node_modules/winston/lib/winston/exception-stream.js"(exports2, module2) {
    "use strict";
    var { Writable } = require_readable();
    module2.exports = class ExceptionStream extends Writable {
      /**
       * Constructor function for the ExceptionStream responsible for wrapping a
       * TransportStream; only allowing writes of `info` objects with
       * `info.exception` set to true.
       * @param {!TransportStream} transport - Stream to filter to exceptions
       */
      constructor(transport) {
        super({ objectMode: true });
        if (!transport) {
          throw new Error("ExceptionStream requires a TransportStream instance.");
        }
        this.handleExceptions = true;
        this.transport = transport;
      }
      /**
       * Writes the info object to our transport instance if (and only if) the
       * `exception` property is set on the info.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _write(info, enc, callback) {
        if (info.exception) {
          return this.transport.log(info, callback);
        }
        callback();
        return true;
      }
    };
  }
});

// node_modules/winston/lib/winston/exception-handler.js
var require_exception_handler = __commonJS({
  "node_modules/winston/lib/winston/exception-handler.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var asyncForEach = require_forEach();
    var debug = require_node2()("winston:exception");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var ExceptionStream = require_exception_stream();
    module2.exports = class ExceptionHandler {
      /**
       * TODO: add contructor description
       * @param {!Logger} logger - TODO: add param description
       */
      constructor(logger) {
        if (!logger) {
          throw new Error("Logger is required to handle exceptions");
        }
        this.logger = logger;
        this.handlers = /* @__PURE__ */ new Map();
      }
      /**
       * Handles `uncaughtException` events for the current process by adding any
       * handlers passed in.
       * @returns {undefined}
       */
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._uncaughtException.bind(this);
          process.on("uncaughtException", this.catcher);
        }
      }
      /**
       * Removes any handlers to `uncaughtException` events for the current
       * process. This does not modify the state of the `this.handlers` set.
       * @returns {undefined}
       */
      unhandle() {
        if (this.catcher) {
          process.removeListener("uncaughtException", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach((wrapper) => this.logger.unpipe(wrapper));
        }
      }
      /**
       * TODO: add method description
       * @param {Error} err - Error to get information about.
       * @returns {mixed} - TODO: add return description.
       */
      getAllInfo(err) {
        let { message } = err;
        if (!message && typeof err === "string") {
          message = err;
        }
        return {
          error: err,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: [
            `uncaughtException: ${message || "(no error message)"}`,
            err.stack || "  No stack trace"
          ].join("\n"),
          stack: err.stack,
          exception: true,
          date: (/* @__PURE__ */ new Date()).toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      /**
       * Gets all relevant process information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
       * Gets all relevant OS information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
      /**
       * Gets a stack trace for the specified error.
       * @param {mixed} err - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      /**
       * Helper method to add a transport as an exception handler.
       * @param {Transport} handler - The transport to add as an exception handler.
       * @returns {void}
       */
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleExceptions = true;
          const wrapper = new ExceptionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      /**
       * Logs all relevant information around the `err` and exits the current
       * process.
       * @param {Error} err - Error to handle
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _uncaughtException(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getExceptionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no exception handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(handlers, (handler, next) => {
          const done = once(next);
          const transport = handler.transport || handler;
          function onDone(event) {
            return () => {
              debug(event);
              done();
            };
          }
          transport._ending = true;
          transport.once("finish", onDone("finished"));
          transport.once("error", onDone("error"));
        }, () => doExit && gracefulExit());
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      /**
       * Returns the list of transports and exceptionHandlers for this instance.
       * @returns {Array} - List of transports and exceptionHandlers for this
       * instance.
       * @private
       */
      _getExceptionHandlers() {
        return this.logger.transports.filter((wrap) => {
          const transport = wrap.transport || wrap;
          return transport.handleExceptions;
        });
      }
    };
  }
});

// node_modules/winston/lib/winston/rejection-handler.js
var require_rejection_handler = __commonJS({
  "node_modules/winston/lib/winston/rejection-handler.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var asyncForEach = require_forEach();
    var debug = require_node2()("winston:rejection");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var ExceptionStream = require_exception_stream();
    module2.exports = class RejectionHandler {
      /**
       * TODO: add contructor description
       * @param {!Logger} logger - TODO: add param description
       */
      constructor(logger) {
        if (!logger) {
          throw new Error("Logger is required to handle rejections");
        }
        this.logger = logger;
        this.handlers = /* @__PURE__ */ new Map();
      }
      /**
       * Handles `unhandledRejection` events for the current process by adding any
       * handlers passed in.
       * @returns {undefined}
       */
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._unhandledRejection.bind(this);
          process.on("unhandledRejection", this.catcher);
        }
      }
      /**
       * Removes any handlers to `unhandledRejection` events for the current
       * process. This does not modify the state of the `this.handlers` set.
       * @returns {undefined}
       */
      unhandle() {
        if (this.catcher) {
          process.removeListener("unhandledRejection", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach(
            (wrapper) => this.logger.unpipe(wrapper)
          );
        }
      }
      /**
       * TODO: add method description
       * @param {Error} err - Error to get information about.
       * @returns {mixed} - TODO: add return description.
       */
      getAllInfo(err) {
        let message = null;
        if (err) {
          message = typeof err === "string" ? err : err.message;
        }
        return {
          error: err,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: [
            `unhandledRejection: ${message || "(no error message)"}`,
            err && err.stack || "  No stack trace"
          ].join("\n"),
          stack: err && err.stack,
          exception: true,
          date: (/* @__PURE__ */ new Date()).toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      /**
       * Gets all relevant process information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
       * Gets all relevant OS information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
      /**
       * Gets a stack trace for the specified error.
       * @param {mixed} err - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      /**
       * Helper method to add a transport as an exception handler.
       * @param {Transport} handler - The transport to add as an exception handler.
       * @returns {void}
       */
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleRejections = true;
          const wrapper = new ExceptionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      /**
       * Logs all relevant information around the `err` and exits the current
       * process.
       * @param {Error} err - Error to handle
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _unhandledRejection(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getRejectionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no rejection handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(
          handlers,
          (handler, next) => {
            const done = once(next);
            const transport = handler.transport || handler;
            function onDone(event) {
              return () => {
                debug(event);
                done();
              };
            }
            transport._ending = true;
            transport.once("finish", onDone("finished"));
            transport.once("error", onDone("error"));
          },
          () => doExit && gracefulExit()
        );
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      /**
       * Returns the list of transports and exceptionHandlers for this instance.
       * @returns {Array} - List of transports and exceptionHandlers for this
       * instance.
       * @private
       */
      _getRejectionHandlers() {
        return this.logger.transports.filter((wrap) => {
          const transport = wrap.transport || wrap;
          return transport.handleRejections;
        });
      }
    };
  }
});

// node_modules/winston/lib/winston/profiler.js
var require_profiler = __commonJS({
  "node_modules/winston/lib/winston/profiler.js"(exports2, module2) {
    "use strict";
    module2.exports = class Profiler {
      /**
       * Constructor function for the Profiler instance used by
       * `Logger.prototype.startTimer`. When done is called the timer will finish
       * and log the duration.
       * @param {!Logger} logger - TODO: add param description.
       * @private
       */
      constructor(logger) {
        if (!logger) {
          throw new Error("Logger is required for profiling.");
        }
        this.logger = logger;
        this.start = Date.now();
      }
      /**
       * Ends the current timer (i.e. Profiler) instance and logs the `msg` along
       * with the duration since creation.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      done(...args) {
        if (typeof args[args.length - 1] === "function") {
          console.warn("Callback function no longer supported as of winston@3.0.0");
          args.pop();
        }
        const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
        info.level = info.level || "info";
        info.durationMs = Date.now() - this.start;
        return this.logger.write(info);
      }
    };
  }
});

// node_modules/winston/lib/winston/logger.js
var require_logger = __commonJS({
  "node_modules/winston/lib/winston/logger.js"(exports2, module2) {
    "use strict";
    var { Stream, Transform } = require_readable();
    var asyncForEach = require_forEach();
    var { LEVEL, SPLAT } = require_triple_beam();
    var isStream = require_is_stream();
    var ExceptionHandler = require_exception_handler();
    var RejectionHandler = require_rejection_handler();
    var LegacyTransportStream = require_legacy();
    var Profiler = require_profiler();
    var { warn } = require_common();
    var config = require_config2();
    var formatRegExp = /%[scdjifoO%]/g;
    var Logger = class extends Transform {
      /**
       * Constructor function for the Logger object responsible for persisting log
       * messages and metadata to one or more transports.
       * @param {!Object} options - foo
       */
      constructor(options) {
        super({ objectMode: true });
        this.configure(options);
      }
      child(defaultRequestMetadata) {
        const logger = this;
        return Object.create(logger, {
          write: {
            value: function(info) {
              const infoClone = Object.assign(
                {},
                defaultRequestMetadata,
                info
              );
              if (info instanceof Error) {
                infoClone.stack = info.stack;
                infoClone.message = info.message;
              }
              logger.write(infoClone);
            }
          }
        });
      }
      /**
       * This will wholesale reconfigure this instance by:
       * 1. Resetting all transports. Older transports will be removed implicitly.
       * 2. Set all other options including levels, colors, rewriters, filters,
       *    exceptionHandlers, etc.
       * @param {!Object} options - TODO: add param description.
       * @returns {undefined}
       */
      configure({
        silent,
        format,
        defaultMeta,
        levels,
        level = "info",
        exitOnError = true,
        transports,
        colors,
        emitErrs,
        formatters,
        padLevels,
        rewriters,
        stripColors,
        exceptionHandlers,
        rejectionHandlers
      } = {}) {
        if (this.transports.length) {
          this.clear();
        }
        this.silent = silent;
        this.format = format || this.format || require_json()();
        this.defaultMeta = defaultMeta || null;
        this.levels = levels || this.levels || config.npm.levels;
        this.level = level;
        if (this.exceptions) {
          this.exceptions.unhandle();
        }
        if (this.rejections) {
          this.rejections.unhandle();
        }
        this.exceptions = new ExceptionHandler(this);
        this.rejections = new RejectionHandler(this);
        this.profilers = {};
        this.exitOnError = exitOnError;
        if (transports) {
          transports = Array.isArray(transports) ? transports : [transports];
          transports.forEach((transport) => this.add(transport));
        }
        if (colors || emitErrs || formatters || padLevels || rewriters || stripColors) {
          throw new Error(
            [
              "{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.",
              "Use a custom winston.format(function) instead.",
              "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
            ].join("\n")
          );
        }
        if (exceptionHandlers) {
          this.exceptions.handle(exceptionHandlers);
        }
        if (rejectionHandlers) {
          this.rejections.handle(rejectionHandlers);
        }
      }
      isLevelEnabled(level) {
        const givenLevelValue = getLevelValue(this.levels, level);
        if (givenLevelValue === null) {
          return false;
        }
        const configuredLevelValue = getLevelValue(this.levels, this.level);
        if (configuredLevelValue === null) {
          return false;
        }
        if (!this.transports || this.transports.length === 0) {
          return configuredLevelValue >= givenLevelValue;
        }
        const index = this.transports.findIndex((transport) => {
          let transportLevelValue = getLevelValue(this.levels, transport.level);
          if (transportLevelValue === null) {
            transportLevelValue = configuredLevelValue;
          }
          return transportLevelValue >= givenLevelValue;
        });
        return index !== -1;
      }
      /* eslint-disable valid-jsdoc */
      /**
       * Ensure backwards compatibility with a `log` method
       * @param {mixed} level - Level the log message is written at.
       * @param {mixed} msg - TODO: add param description.
       * @param {mixed} meta - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       *
       * @example
       *    // Supports the existing API:
       *    logger.log('info', 'Hello world', { custom: true });
       *    logger.log('info', new Error('Yo, it\'s on fire'));
       *
       *    // Requires winston.format.splat()
       *    logger.log('info', '%s %d%%', 'A string', 50, { thisIsMeta: true });
       *
       *    // And the new API with a single JSON literal:
       *    logger.log({ level: 'info', message: 'Hello world', custom: true });
       *    logger.log({ level: 'info', message: new Error('Yo, it\'s on fire') });
       *
       *    // Also requires winston.format.splat()
       *    logger.log({
       *      level: 'info',
       *      message: '%s %d%%',
       *      [SPLAT]: ['A string', 50],
       *      meta: { thisIsMeta: true }
       *    });
       *
       */
      /* eslint-enable valid-jsdoc */
      log(level, msg, ...splat) {
        if (arguments.length === 1) {
          level[LEVEL] = level.level;
          this._addDefaultMeta(level);
          this.write(level);
          return this;
        }
        if (arguments.length === 2) {
          if (msg && typeof msg === "object") {
            msg[LEVEL] = msg.level = level;
            this._addDefaultMeta(msg);
            this.write(msg);
            return this;
          }
          msg = { [LEVEL]: level, level, message: msg };
          this._addDefaultMeta(msg);
          this.write(msg);
          return this;
        }
        const [meta] = splat;
        if (typeof meta === "object" && meta !== null) {
          const tokens = msg && msg.match && msg.match(formatRegExp);
          if (!tokens) {
            const info = Object.assign({}, this.defaultMeta, meta, {
              [LEVEL]: level,
              [SPLAT]: splat,
              level,
              message: msg
            });
            if (meta.message) info.message = `${info.message} ${meta.message}`;
            if (meta.stack) info.stack = meta.stack;
            this.write(info);
            return this;
          }
        }
        this.write(Object.assign({}, this.defaultMeta, {
          [LEVEL]: level,
          [SPLAT]: splat,
          level,
          message: msg
        }));
        return this;
      }
      /**
       * Pushes data so that it can be picked up by all of our pipe targets.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - Continues stream processing.
       * @returns {undefined}
       * @private
       */
      _transform(info, enc, callback) {
        if (this.silent) {
          return callback();
        }
        if (!info[LEVEL]) {
          info[LEVEL] = info.level;
        }
        if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {
          console.error("[winston] Unknown logger level: %s", info[LEVEL]);
        }
        if (!this._readableState.pipes) {
          console.error(
            "[winston] Attempt to write logs with no transports, which can increase memory usage: %j",
            info
          );
        }
        try {
          this.push(this.format.transform(info, this.format.options));
        } finally {
          this._writableState.sync = false;
          callback();
        }
      }
      /**
       * Delays the 'finish' event until all transport pipe targets have
       * also emitted 'finish' or are already finished.
       * @param {mixed} callback - Continues stream processing.
       */
      _final(callback) {
        const transports = this.transports.slice();
        asyncForEach(
          transports,
          (transport, next) => {
            if (!transport || transport.finished) return setImmediate(next);
            transport.once("finish", next);
            transport.end();
          },
          callback
        );
      }
      /**
       * Adds the transport to this logger instance by piping to it.
       * @param {mixed} transport - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       */
      add(transport) {
        const target = !isStream(transport) || transport.log.length > 2 ? new LegacyTransportStream({ transport }) : transport;
        if (!target._writableState || !target._writableState.objectMode) {
          throw new Error(
            "Transports must WritableStreams in objectMode. Set { objectMode: true }."
          );
        }
        this._onEvent("error", target);
        this._onEvent("warn", target);
        this.pipe(target);
        if (transport.handleExceptions) {
          this.exceptions.handle();
        }
        if (transport.handleRejections) {
          this.rejections.handle();
        }
        return this;
      }
      /**
       * Removes the transport from this logger instance by unpiping from it.
       * @param {mixed} transport - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       */
      remove(transport) {
        if (!transport) return this;
        let target = transport;
        if (!isStream(transport) || transport.log.length > 2) {
          target = this.transports.filter(
            (match) => match.transport === transport
          )[0];
        }
        if (target) {
          this.unpipe(target);
        }
        return this;
      }
      /**
       * Removes all transports from this logger instance.
       * @returns {Logger} - TODO: add return description.
       */
      clear() {
        this.unpipe();
        return this;
      }
      /**
       * Cleans up resources (streams, event listeners) for all transports
       * associated with this instance (if necessary).
       * @returns {Logger} - TODO: add return description.
       */
      close() {
        this.exceptions.unhandle();
        this.rejections.unhandle();
        this.clear();
        this.emit("close");
        return this;
      }
      /**
       * Sets the `target` levels specified on this instance.
       * @param {Object} Target levels to use on this instance.
       */
      setLevels() {
        warn.deprecated("setLevels");
      }
      /**
       * Queries the all transports for this instance with the specified `options`.
       * This will aggregate each transport's results into one object containing
       * a property per transport.
       * @param {Object} options - Query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        const results = {};
        const queryObject = Object.assign({}, options.query || {});
        function queryTransport(transport, next) {
          if (options.query && typeof transport.formatQuery === "function") {
            options.query = transport.formatQuery(queryObject);
          }
          transport.query(options, (err, res) => {
            if (err) {
              return next(err);
            }
            if (typeof transport.formatResults === "function") {
              res = transport.formatResults(res, options.format);
            }
            next(null, res);
          });
        }
        function addResults(transport, next) {
          queryTransport(transport, (err, result) => {
            if (next) {
              result = err || result;
              if (result) {
                results[transport.name] = result;
              }
              next();
            }
            next = null;
          });
        }
        asyncForEach(
          this.transports.filter((transport) => !!transport.query),
          addResults,
          () => callback(null, results)
        );
      }
      /**
       * Returns a log stream for all transports. Options object is optional.
       * @param{Object} options={} - Stream options for this instance.
       * @returns {Stream} - TODO: add return description.
       */
      stream(options = {}) {
        const out = new Stream();
        const streams = [];
        out._streams = streams;
        out.destroy = () => {
          let i = streams.length;
          while (i--) {
            streams[i].destroy();
          }
        };
        this.transports.filter((transport) => !!transport.stream).forEach((transport) => {
          const str = transport.stream(options);
          if (!str) {
            return;
          }
          streams.push(str);
          str.on("log", (log) => {
            log.transport = log.transport || [];
            log.transport.push(transport.name);
            out.emit("log", log);
          });
          str.on("error", (err) => {
            err.transport = err.transport || [];
            err.transport.push(transport.name);
            out.emit("error", err);
          });
        });
        return out;
      }
      /**
       * Returns an object corresponding to a specific timing. When done is called
       * the timer will finish and log the duration. e.g.:
       * @returns {Profile} - TODO: add return description.
       * @example
       *    const timer = winston.startTimer()
       *    setTimeout(() => {
       *      timer.done({
       *        message: 'Logging message'
       *      });
       *    }, 1000);
       */
      startTimer() {
        return new Profiler(this);
      }
      /**
       * Tracks the time inbetween subsequent calls to this method with the same
       * `id` parameter. The second call to this method will log the difference in
       * milliseconds along with the message.
       * @param {string} id Unique id of the profiler
       * @returns {Logger} - TODO: add return description.
       */
      profile(id, ...args) {
        const time = Date.now();
        if (this.profilers[id]) {
          const timeEnd = this.profilers[id];
          delete this.profilers[id];
          if (typeof args[args.length - 2] === "function") {
            console.warn(
              "Callback function no longer supported as of winston@3.0.0"
            );
            args.pop();
          }
          const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
          info.level = info.level || "info";
          info.durationMs = time - timeEnd;
          info.message = info.message || id;
          return this.write(info);
        }
        this.profilers[id] = time;
        return this;
      }
      /**
       * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
       * @returns {undefined}
       * @deprecated
       */
      handleExceptions(...args) {
        console.warn(
          "Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()"
        );
        this.exceptions.handle(...args);
      }
      /**
       * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
       * @returns {undefined}
       * @deprecated
       */
      unhandleExceptions(...args) {
        console.warn(
          "Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()"
        );
        this.exceptions.unhandle(...args);
      }
      /**
       * Throw a more meaningful deprecation notice
       * @throws {Error} - TODO: add throws description.
       */
      cli() {
        throw new Error(
          [
            "Logger.cli() was removed in winston@3.0.0",
            "Use a custom winston.formats.cli() instead.",
            "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
          ].join("\n")
        );
      }
      /**
       * Bubbles the `event` that occured on the specified `transport` up
       * from this instance.
       * @param {string} event - The event that occured
       * @param {Object} transport - Transport on which the event occured
       * @private
       */
      _onEvent(event, transport) {
        function transportEvent(err) {
          if (event === "error" && !this.transports.includes(transport)) {
            this.add(transport);
          }
          this.emit(event, err, transport);
        }
        if (!transport["__winston" + event]) {
          transport["__winston" + event] = transportEvent.bind(this);
          transport.on(event, transport["__winston" + event]);
        }
      }
      _addDefaultMeta(msg) {
        if (this.defaultMeta) {
          Object.assign(msg, this.defaultMeta);
        }
      }
    };
    function getLevelValue(levels, level) {
      const value = levels[level];
      if (!value && value !== 0) {
        return null;
      }
      return value;
    }
    Object.defineProperty(Logger.prototype, "transports", {
      configurable: false,
      enumerable: true,
      get() {
        const { pipes } = this._readableState;
        return !Array.isArray(pipes) ? [pipes].filter(Boolean) : pipes;
      }
    });
    module2.exports = Logger;
  }
});

// node_modules/winston/lib/winston/create-logger.js
var require_create_logger = __commonJS({
  "node_modules/winston/lib/winston/create-logger.js"(exports2, module2) {
    "use strict";
    var { LEVEL } = require_triple_beam();
    var config = require_config2();
    var Logger = require_logger();
    var debug = require_node2()("winston:create-logger");
    function isLevelEnabledFunctionName(level) {
      return "is" + level.charAt(0).toUpperCase() + level.slice(1) + "Enabled";
    }
    module2.exports = function(opts = {}) {
      opts.levels = opts.levels || config.npm.levels;
      class DerivedLogger extends Logger {
        /**
         * Create a new class derived logger for which the levels can be attached to
         * the prototype of. This is a V8 optimization that is well know to increase
         * performance of prototype functions.
         * @param {!Object} options - Options for the created logger.
         */
        constructor(options) {
          super(options);
        }
      }
      const logger = new DerivedLogger(opts);
      Object.keys(opts.levels).forEach(function(level) {
        debug('Define prototype method for "%s"', level);
        if (level === "log") {
          console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
          return;
        }
        DerivedLogger.prototype[level] = function(...args) {
          const self2 = this || logger;
          if (args.length === 1) {
            const [msg] = args;
            const info = msg && msg.message && msg || { message: msg };
            info.level = info[LEVEL] = level;
            self2._addDefaultMeta(info);
            self2.write(info);
            return this || logger;
          }
          if (args.length === 0) {
            self2.log(level, "");
            return self2;
          }
          return self2.log(level, ...args);
        };
        DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function() {
          return (this || logger).isLevelEnabled(level);
        };
      });
      return logger;
    };
  }
});

// node_modules/winston/lib/winston/container.js
var require_container = __commonJS({
  "node_modules/winston/lib/winston/container.js"(exports2, module2) {
    "use strict";
    var createLogger = require_create_logger();
    module2.exports = class Container {
      /**
       * Constructor function for the Container object responsible for managing a
       * set of `winston.Logger` instances based on string ids.
       * @param {!Object} [options={}] - Default pass-thru options for Loggers.
       */
      constructor(options = {}) {
        this.loggers = /* @__PURE__ */ new Map();
        this.options = options;
      }
      /**
       * Retrieves a `winston.Logger` instance for the specified `id`. If an
       * instance does not exist, one is created.
       * @param {!string} id - The id of the Logger to get.
       * @param {?Object} [options] - Options for the Logger instance.
       * @returns {Logger} - A configured Logger instance with a specified id.
       */
      add(id, options) {
        if (!this.loggers.has(id)) {
          options = Object.assign({}, options || this.options);
          const existing = options.transports || this.options.transports;
          options.transports = existing ? existing.slice() : [];
          const logger = createLogger(options);
          logger.on("close", () => this._delete(id));
          this.loggers.set(id, logger);
        }
        return this.loggers.get(id);
      }
      /**
       * Retreives a `winston.Logger` instance for the specified `id`. If
       * an instance does not exist, one is created.
       * @param {!string} id - The id of the Logger to get.
       * @param {?Object} [options] - Options for the Logger instance.
       * @returns {Logger} - A configured Logger instance with a specified id.
       */
      get(id, options) {
        return this.add(id, options);
      }
      /**
       * Check if the container has a logger with the id.
       * @param {?string} id - The id of the Logger instance to find.
       * @returns {boolean} - Boolean value indicating if this instance has a
       * logger with the specified `id`.
       */
      has(id) {
        return !!this.loggers.has(id);
      }
      /**
       * Closes a `Logger` instance with the specified `id` if it exists.
       * If no `id` is supplied then all Loggers are closed.
       * @param {?string} id - The id of the Logger instance to close.
       * @returns {undefined}
       */
      close(id) {
        if (id) {
          return this._removeLogger(id);
        }
        this.loggers.forEach((val, key) => this._removeLogger(key));
      }
      /**
       * Remove a logger based on the id.
       * @param {!string} id - The id of the logger to remove.
       * @returns {undefined}
       * @private
       */
      _removeLogger(id) {
        if (!this.loggers.has(id)) {
          return;
        }
        const logger = this.loggers.get(id);
        logger.close();
        this._delete(id);
      }
      /**
       * Deletes a `Logger` instance with the specified `id`.
       * @param {!string} id - The id of the Logger instance to delete from
       * container.
       * @returns {undefined}
       * @private
       */
      _delete(id) {
        this.loggers.delete(id);
      }
    };
  }
});

// node_modules/winston/lib/winston.js
var require_winston = __commonJS({
  "node_modules/winston/lib/winston.js"(exports2) {
    "use strict";
    var logform = require_logform();
    var { warn } = require_common();
    exports2.version = require_package().version;
    exports2.transports = require_transports();
    exports2.config = require_config2();
    exports2.addColors = logform.levels;
    exports2.format = logform.format;
    exports2.createLogger = require_create_logger();
    exports2.ExceptionHandler = require_exception_handler();
    exports2.RejectionHandler = require_rejection_handler();
    exports2.Container = require_container();
    exports2.Transport = require_winston_transport();
    exports2.loggers = new exports2.Container();
    var defaultLogger = exports2.createLogger();
    Object.keys(exports2.config.npm.levels).concat([
      "log",
      "query",
      "stream",
      "add",
      "remove",
      "clear",
      "profile",
      "startTimer",
      "handleExceptions",
      "unhandleExceptions",
      "handleRejections",
      "unhandleRejections",
      "configure",
      "child"
    ]).forEach(
      (method) => exports2[method] = (...args) => defaultLogger[method](...args)
    );
    Object.defineProperty(exports2, "level", {
      get() {
        return defaultLogger.level;
      },
      set(val) {
        defaultLogger.level = val;
      }
    });
    Object.defineProperty(exports2, "exceptions", {
      get() {
        return defaultLogger.exceptions;
      }
    });
    ["exitOnError"].forEach((prop) => {
      Object.defineProperty(exports2, prop, {
        get() {
          return defaultLogger[prop];
        },
        set(val) {
          defaultLogger[prop] = val;
        }
      });
    });
    Object.defineProperty(exports2, "default", {
      get() {
        return {
          exceptionHandlers: defaultLogger.exceptionHandlers,
          rejectionHandlers: defaultLogger.rejectionHandlers,
          transports: defaultLogger.transports
        };
      }
    });
    warn.deprecated(exports2, "setLevels");
    warn.forFunctions(exports2, "useFormat", ["cli"]);
    warn.forProperties(exports2, "useFormat", ["padLevels", "stripColors"]);
    warn.forFunctions(exports2, "deprecated", [
      "addRewriter",
      "addFilter",
      "clone",
      "extend"
    ]);
    warn.forProperties(exports2, "deprecated", ["emitErrs", "levelLength"]);
    warn.moved(exports2, "createLogger", "Logger");
  }
});

// node_modules/debug/node_modules/ms/index.js
var require_ms3 = __commonJS({
  "node_modules/debug/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms3();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag2 = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag2();
    var env = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/debug/src/node.js
var require_node3 = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node3();
    }
  }
});

// node_modules/emitter/dist/emitter.js
var require_emitter = __commonJS({
  "node_modules/emitter/dist/emitter.js"(exports2) {
    (function(global2, factory) {
      if (typeof define === "function" && define.amd) {
        define(["exports"], factory);
      } else if (typeof exports2 !== "undefined") {
        factory(exports2);
      } else {
        var mod = {
          exports: {}
        };
        factory(mod.exports);
        global2.emitter = mod.exports;
      }
    })(exports2, function(exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", {
        value: true
      });
      var _createClass = /* @__PURE__ */ function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      exports3.Promise = Promise2;
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var noop = function noop2() {
        return false;
      };
      var defaultMaxListeners = 10;
      var EventEmitter = function() {
        function EventEmitter2() {
          _classCallCheck(this, EventEmitter2);
          this._events = this._events || {};
          this._maxListeners = this._maxListeners || defaultMaxListeners;
        }
        _createClass(EventEmitter2, [{
          key: "setMaxListeners",
          value: function setMaxListeners(n) {
            if (typeof n !== "number" || n < 0) throw TypeError("n must be a positive number");
            this._maxListeners = n;
          }
        }, {
          key: "emit",
          value: function emit(type) {
            var er, handler, len, args, i, listeners;
            if (!this._events) this._events = {};
            if (type === "error") {
              if (!this._events.error || typeof this._events.error === "object" && !this._events.error.length) {
                er = arguments[1];
                if (this.domain) {
                  if (!er) er = new TypeError('Uncaught, unspecified "error" event.');
                } else if (er instanceof Error) {
                  throw er;
                } else {
                  throw TypeError('Uncaught, unspecified "error" event.');
                }
                return false;
              }
            }
            handler = this._events[type];
            if (typeof handler === "undefined") return false;
            if (typeof handler === "function") {
              switch (arguments.length) {
                // fast cases
                case 1:
                  handler.call(this);
                  break;
                case 2:
                  handler.call(this, arguments[1]);
                  break;
                case 3:
                  handler.call(this, arguments[1], arguments[2]);
                  break;
                // slower
                default:
                  len = arguments.length;
                  args = new Array(len - 1);
                  for (i = 1; i < len; i++) args[i - 1] = arguments[i];
                  handler.apply(this, args);
              }
            } else if (typeof handler === "object") {
              len = arguments.length;
              args = new Array(len - 1);
              for (i = 1; i < len; i++) args[i - 1] = arguments[i];
              listeners = handler.slice();
              len = listeners.length;
              for (i = 0; i < len; i++) listeners[i].apply(this, args);
            }
            return true;
          }
        }, {
          key: "addListener",
          value: function addListener(type, listener) {
            var m;
            if (typeof listener !== "function") throw TypeError("listener must be a function");
            if (!this._events) this._events = {};
            if (this._events.newListener) this.emit("newListener", type, typeof listener.listener === "function" ? listener.listener : listener);
            if (!this._events[type])
              this._events[type] = listener;
            else if (typeof this._events[type] === "object")
              this._events[type].push(listener);
            else
              this._events[type] = [this._events[type], listener];
            if (typeof this._events[type] === "object" && !this._events[type].warned) {
              m = this._maxListeners;
              if (m && m > 0 && this._events[type].length > m) {
                this._events[type].warned = true;
                console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[type].length);
                console.trace();
              }
            }
            return this;
          }
        }, {
          key: "on",
          value: function on() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return this.addListener.apply(this, args);
          }
        }, {
          key: "once",
          value: function once(type, listener) {
            if (typeof listener !== "function") throw TypeError("listener must be a function");
            function g() {
              this.removeListener(type, g);
              listener.apply(this, arguments);
            }
            g.listener = listener;
            this.on(type, g);
            return this;
          }
        }, {
          key: "removeListener",
          value: function removeListener(type, listener) {
            var list, position, length, i;
            if (typeof listener !== "function") throw TypeError("listener must be a function");
            if (!this._events || !this._events[type]) return this;
            list = this._events[type];
            length = list.length;
            position = -1;
            if (list === listener || typeof list.listener === "function" && list.listener === listener) {
              this._events[type] = void 0;
              if (this._events.removeListener) this.emit("removeListener", type, listener);
            } else if (typeof list === "object") {
              for (i = length; i-- > 0; ) {
                if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                  position = i;
                  break;
                }
              }
              if (position < 0) return this;
              if (list.length === 1) {
                list.length = 0;
                this._events[type] = void 0;
              } else {
                list.splice(position, 1);
              }
              if (this._events.removeListener) this.emit("removeListener", type, listener);
            }
            return this;
          }
        }, {
          key: "removeAllListeners",
          value: function removeAllListeners(type) {
            var key, listeners;
            if (!this._events) return this;
            if (!this._events.removeListener) {
              if (arguments.length === 0) this._events = {};
              else if (this._events[type]) this._events[type] = void 0;
              return this;
            }
            if (arguments.length === 0) {
              var keys = Object.keys(this._events);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (key === "removeListener") continue;
                this.removeAllListeners(key);
              }
              this.removeAllListeners("removeListener");
              this._events = {};
              return this;
            }
            listeners = this._events[type];
            if (typeof listeners === "function") {
              this.removeListener(type, listeners);
            } else {
              while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]);
            }
            this._events[type] = void 0;
            return this;
          }
        }, {
          key: "listeners",
          value: function listeners(type) {
            var ret;
            if (!this._events || !this._events[type]) ret = [];
            else if (typeof this._events[type] === "function") ret = [this._events[type]];
            else ret = this._events[type].slice();
            return ret;
          }
        }], [{
          key: "listenerCount",
          value: function listenerCount(emitter, type) {
            var ret;
            if (!emitter._events || !emitter._events[type]) ret = 0;
            else if (typeof emitter._events[type] === "function") ret = 1;
            else ret = emitter._events[type].length;
            return ret;
          }
        }, {
          key: "inherits",
          value: function inherits(ctor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        }, {
          key: "extend",
          value: function extend(target) {
            return _extend(target, new EventEmitter2(), EventEmitter2.prototype);
          }
        }]);
        return EventEmitter2;
      }();
      exports3.EventEmitter = EventEmitter;
      function _extend(target) {
        for (var _len2 = arguments.length, objs = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          objs[_key2 - 1] = arguments[_key2];
        }
        for (var i = 0, l = objs.length; i < l; i++) {
          var keys = Object.getOwnPropertyNames(objs[i] || {});
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var key = _step.value;
              target[key] = objs[i][key];
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
        return target;
      }
      var _Promise = function() {
        function _Promise2() {
          var resolver = arguments.length <= 0 || arguments[0] === void 0 ? noop : arguments[0];
          _classCallCheck(this, _Promise2);
          this._settled = false;
          this._success = false;
          this._args = [];
          this._callbacks = [];
          this._onReject = noop;
          resolver(this.resolve.bind(this), this.reject.bind(this));
        }
        _createClass(_Promise2, [{
          key: "then",
          value: function then(onResolve) {
            var _this = this;
            var onReject = arguments.length <= 1 || arguments[1] === void 0 ? noop : arguments[1];
            var promise = new _Promise2();
            this._onReject = onReject;
            this._callbacks.push(function() {
              for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args[_key3] = arguments[_key3];
              }
              var ret = onResolve.apply(_this, args);
              if (ret && typeof ret.then == "function") {
                ret.then(promise.resolve.bind(promise), promise.reject.bind(promise));
              }
            });
            if (this._settled) {
              if (this._success) {
                this.resolve.apply(this, this._args);
              } else {
                this.onReject.apply(this, this._args);
              }
            }
            return promise;
          }
        }, {
          key: "catch",
          value: function _catch(onReject) {
            this._onReject = onReject;
            return this;
          }
        }, {
          key: "resolve",
          value: function resolve() {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = void 0;
            for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
            }
            try {
              for (var _iterator2 = this._callbacks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var handler = _step2.value;
                handler.apply(this, args);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
            this._args = args;
            this._settled = true;
            this._success = true;
          }
        }, {
          key: "reject",
          value: function reject() {
            for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
              args[_key5] = arguments[_key5];
            }
            this._onReject.apply(this, args);
            this._args = args;
            this._settled = true;
          }
        }]);
        return _Promise2;
      }();
      var nativePromise = ("undefined" !== typeof global ? global : window).Promise || null;
      function Promise2(resolver) {
        var promise = null;
        var resolve = noop;
        var reject = noop;
        resolver = resolver || noop;
        if (nativePromise) {
          promise = new nativePromise(function(_1, _2) {
            resolve = _1;
            reject = _2;
            resolver(_1, _2);
          });
          promise.resolve = function() {
            for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
              args[_key6] = arguments[_key6];
            }
            resolve.apply(promise, args);
          };
          promise.reject = function() {
            for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
              args[_key7] = arguments[_key7];
            }
            reject.apply(promise, args);
          };
        } else {
          promise = new _Promise(resolver);
        }
        return promise;
      }
    });
  }
});

// node_modules/batch/index.js
var require_batch = __commonJS({
  "node_modules/batch/index.js"(exports2, module2) {
    try {
      EventEmitter = require("events").EventEmitter;
      if (!EventEmitter) throw new Error();
    } catch (err) {
      Emitter = require_emitter();
    }
    var EventEmitter;
    var Emitter;
    var defer = typeof process !== "undefined" && process && typeof process.nextTick === "function" ? process.nextTick : function(fn) {
      setTimeout(fn);
    };
    function noop() {
    }
    module2.exports = Batch;
    function Batch() {
      if (!(this instanceof Batch)) return new Batch();
      this.fns = [];
      this.concurrency(Infinity);
      this.throws(true);
      for (var i = 0, len = arguments.length; i < len; ++i) {
        this.push(arguments[i]);
      }
    }
    if (EventEmitter) {
      Batch.prototype.__proto__ = EventEmitter.prototype;
    } else {
      Emitter(Batch.prototype);
    }
    Batch.prototype.concurrency = function(n) {
      this.n = n;
      return this;
    };
    Batch.prototype.push = function(fn) {
      this.fns.push(fn);
      return this;
    };
    Batch.prototype.throws = function(throws) {
      this.e = !!throws;
      return this;
    };
    Batch.prototype.end = function(cb) {
      var self2 = this, total = this.fns.length, pending = total, results = [], errors = [], cb = cb || noop, fns = this.fns, max = this.n, throws = this.e, index = 0, done;
      if (!fns.length) return defer(function() {
        cb(null, results);
      });
      function next() {
        var i2 = index++;
        var fn = fns[i2];
        if (!fn) return;
        var start = /* @__PURE__ */ new Date();
        try {
          fn(callback);
        } catch (err) {
          callback(err);
        }
        function callback(err, res) {
          if (done) return;
          if (err && throws) return done = true, defer(function() {
            cb(err);
          });
          var complete = total - pending + 1;
          var end = /* @__PURE__ */ new Date();
          results[i2] = res;
          errors[i2] = err;
          self2.emit("progress", {
            index: i2,
            value: res,
            error: err,
            pending,
            total,
            complete,
            percent: complete / total * 100 | 0,
            start,
            end,
            duration: end - start
          });
          if (--pending) next();
          else defer(function() {
            if (!throws) cb(errors, results);
            else cb(null, results);
          });
        }
      }
      for (var i = 0; i < fns.length; i++) {
        if (i == max) break;
        next();
      }
      return this;
    };
  }
});

// node_modules/@jsreport/reap/index.js
var require_reap = __commonJS({
  "node_modules/@jsreport/reap/index.js"(exports2, module2) {
    var Emitter = require("events").EventEmitter;
    var debug = require_src()("reap");
    var Batch = require_batch();
    var path = require("path");
    var resolve = path.resolve;
    var fs = require("fs");
    var ms = require_ms();
    module2.exports = Reaper;
    function Reaper(opts) {
      opts = opts || {};
      this.dirs = [];
      this._filter = function(file, fn) {
        fn(true);
      };
      this.concurrency = opts.concurrency || 10;
      this.threshold = opts.threshold || ms("30 minutes");
      debug("threshold %s", this.threshold);
    }
    Reaper.prototype.__proto__ = Emitter.prototype;
    Reaper.prototype.old = function(file, fn) {
      var threshold = this.threshold;
      fs.stat(file, function(err, s) {
        if (err) return fn(err);
        var d = /* @__PURE__ */ new Date() - s.mtime;
        debug("%s age: %s", file, ms(d));
        fn(null, d > threshold, s);
      });
    };
    Reaper.prototype.watch = function(dir) {
      this.dirs.push(dir);
    };
    Reaper.prototype.filter = function(fn) {
      this._filter = fn;
    };
    Reaper.prototype.start = function(fn) {
      var self2 = this;
      var batch = new Batch();
      batch.concurrency(10);
      this.dirs.forEach(function(dir) {
        var files = fs.readdirSync(dir);
        debug("dir %s has %s files", dir, files.length);
        files.forEach(function(file) {
          batch.push(function(done) {
            file = resolve(dir, file);
            self2.old(file, function(err, old, s) {
              if (err) return done(err);
              if (!old) return done();
              if (!s.isFile()) return done();
              s.path = file;
              self2._filter(s, function(unlink) {
                if (!unlink) return done();
                debug("unlink %s", file);
                self2.emit("remove", s);
                fs.unlink(file, function(err2) {
                  done(err2, s);
                });
              });
            });
          });
        });
      });
      batch.end(function(err, files) {
        if (err) return fn(err);
        fn(null, files.filter(empty));
      });
    };
    function empty(f) {
      return null != f;
    }
  }
});

// node_modules/@jsreport/jsreport-core/package.json
var require_package2 = __commonJS({
  "node_modules/@jsreport/jsreport-core/package.json"(exports2, module2) {
    module2.exports = {
      name: "@jsreport/jsreport-core",
      version: "4.4.1",
      description: "javascript based business reporting",
      keywords: [
        "report",
        "business",
        "javascript"
      ],
      homepage: "https://github.com/jsreport/jsreport/tree/master/packages/jsreport-core",
      repository: {
        type: "git",
        url: "git+ssh://git@github.com/jsreport/jsreport.git"
      },
      license: "LGPL",
      author: {
        name: "Jan Blaha",
        email: "jan.blaha@hotmail.com"
      },
      maintainers: [
        {
          name: "pofider",
          email: "jan.blaha@hotmail.com"
        }
      ],
      main: "index.js",
      files: [
        "lib",
        "index.js",
        "test/store/common.js",
        "test/blobStorage/common.js",
        "test/extensions/validExtensions/listeners"
      ],
      scripts: {
        test: "mocha --timeout 5000 --recursive test --exit && standard",
        "test:watch": "mocha --watch --recursive test"
      },
      dependencies: {
        "@babel/code-frame": "7.23.5",
        "@babel/parser": "7.23.5",
        "@babel/traverse": "7.23.5",
        "@colors/colors": "1.5.0",
        "@jsreport/advanced-workers": "2.0.2",
        "@jsreport/mingo": "2.4.1",
        "@jsreport/reap": "0.1.0",
        "@jsreport/serializator": "1.0.0",
        "@jsreport/ses": "1.1.0",
        ajv: "6.12.6",
        "app-root-path": "3.0.0",
        bytes: "3.1.2",
        camelcase: "5.0.0",
        debug: "4.3.2",
        decamelize: "2.0.0",
        deepmerge: "2.1.0",
        diff: "3.5.0",
        "diff-match-patch": "1.0.5",
        "enhanced-resolve": "5.8.3",
        "has-own-deep": "1.1.0",
        isbinaryfile: "5.0.0",
        "listener-collection": "2.0.0",
        "lodash.get": "4.4.2",
        "lodash.groupby": "4.6.0",
        "lodash.omit": "4.5.0",
        "lru-cache": "4.1.1",
        ms: "2.1.3",
        nanoid: "3.2.0",
        nconf: "0.12.0",
        "node.extend.without.arrays": "1.1.6",
        semver: "7.5.4",
        "set-value": "4.1.0",
        "stack-trace": "0.0.10",
        "triple-beam": "1.3.0",
        "unset-value": "2.0.1",
        uuid: "8.3.2",
        winston: "3.8.1",
        "winston-transport": "4.5.0",
        "yieldable-json": "2.0.1"
      },
      devDependencies: {
        "@node-rs/jsonwebtoken": "0.2.0",
        jsdom: "24.1.0",
        mocha: "10.1.0",
        should: "13.2.3",
        standard: "16.0.4",
        "std-mocks": "1.0.1",
        "winston-loggly-bulk": "3.2.1"
      },
      engines: {
        node: ">=18.15"
      },
      standard: {
        env: {
          mocha: true
        }
      }
    };
  }
});

// node_modules/is/index.js
var require_is = __commonJS({
  "node_modules/is/index.js"(exports2, module2) {
    "use strict";
    var objProto = Object.prototype;
    var owns = objProto.hasOwnProperty;
    var toStr = objProto.toString;
    var symbolValueOf;
    if (typeof Symbol === "function") {
      symbolValueOf = Symbol.prototype.valueOf;
    }
    var bigIntValueOf;
    if (typeof BigInt === "function") {
      bigIntValueOf = BigInt.prototype.valueOf;
    }
    var isActualNaN = function(value) {
      return value !== value;
    };
    var NON_HOST_TYPES = {
      "boolean": 1,
      number: 1,
      string: 1,
      undefined: 1
    };
    var base64Regex = /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)$/;
    var hexRegex = /^[A-Fa-f0-9]+$/;
    var is = {};
    is.a = is.type = function(value, type) {
      return typeof value === type;
    };
    is.defined = function(value) {
      return typeof value !== "undefined";
    };
    is.empty = function(value) {
      var type = toStr.call(value);
      var key;
      if (type === "[object Array]" || type === "[object Arguments]" || type === "[object String]") {
        return value.length === 0;
      }
      if (type === "[object Object]") {
        for (key in value) {
          if (owns.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      return !value;
    };
    is.equal = function equal(value, other) {
      if (value === other) {
        return true;
      }
      var type = toStr.call(value);
      var key;
      if (type !== toStr.call(other)) {
        return false;
      }
      if (type === "[object Object]") {
        for (key in value) {
          if (!is.equal(value[key], other[key]) || !(key in other)) {
            return false;
          }
        }
        for (key in other) {
          if (!is.equal(value[key], other[key]) || !(key in value)) {
            return false;
          }
        }
        return true;
      }
      if (type === "[object Array]") {
        key = value.length;
        if (key !== other.length) {
          return false;
        }
        while (key--) {
          if (!is.equal(value[key], other[key])) {
            return false;
          }
        }
        return true;
      }
      if (type === "[object Function]") {
        return value.prototype === other.prototype;
      }
      if (type === "[object Date]") {
        return value.getTime() === other.getTime();
      }
      return false;
    };
    is.hosted = function(value, host) {
      var type = typeof host[value];
      return type === "object" ? !!host[value] : !NON_HOST_TYPES[type];
    };
    is.instance = is["instanceof"] = function(value, constructor) {
      return value instanceof constructor;
    };
    is.nil = is["null"] = function(value) {
      return value === null;
    };
    is.undef = is.undefined = function(value) {
      return typeof value === "undefined";
    };
    is.args = is.arguments = function(value) {
      var isStandardArguments = toStr.call(value) === "[object Arguments]";
      var isOldArguments = !is.array(value) && is.arraylike(value) && is.object(value) && is.fn(value.callee);
      return isStandardArguments || isOldArguments;
    };
    is.array = Array.isArray || function(value) {
      return toStr.call(value) === "[object Array]";
    };
    is.args.empty = function(value) {
      return is.args(value) && value.length === 0;
    };
    is.array.empty = function(value) {
      return is.array(value) && value.length === 0;
    };
    is.arraylike = function(value) {
      return !!value && !is.bool(value) && owns.call(value, "length") && isFinite(value.length) && is.number(value.length) && value.length >= 0;
    };
    is.bool = is["boolean"] = function(value) {
      return toStr.call(value) === "[object Boolean]";
    };
    is["false"] = function(value) {
      return is.bool(value) && Boolean(Number(value)) === false;
    };
    is["true"] = function(value) {
      return is.bool(value) && Boolean(Number(value)) === true;
    };
    is.date = function(value) {
      return toStr.call(value) === "[object Date]";
    };
    is.date.valid = function(value) {
      return is.date(value) && !isNaN(Number(value));
    };
    is.element = function(value) {
      return value !== void 0 && typeof HTMLElement !== "undefined" && value instanceof HTMLElement && value.nodeType === 1;
    };
    is.error = function(value) {
      return toStr.call(value) === "[object Error]";
    };
    is.fn = is["function"] = function(value) {
      var isAlert = typeof window !== "undefined" && value === window.alert;
      if (isAlert) {
        return true;
      }
      var str = toStr.call(value);
      return str === "[object Function]" || str === "[object GeneratorFunction]" || str === "[object AsyncFunction]";
    };
    is.number = function(value) {
      return toStr.call(value) === "[object Number]";
    };
    is.infinite = function(value) {
      return value === Infinity || value === -Infinity;
    };
    is.decimal = function(value) {
      return is.number(value) && !isActualNaN(value) && !is.infinite(value) && value % 1 !== 0;
    };
    is.divisibleBy = function(value, n) {
      var isDividendInfinite = is.infinite(value);
      var isDivisorInfinite = is.infinite(n);
      var isNonZeroNumber = is.number(value) && !isActualNaN(value) && is.number(n) && !isActualNaN(n) && n !== 0;
      return isDividendInfinite || isDivisorInfinite || isNonZeroNumber && value % n === 0;
    };
    is.integer = is["int"] = function(value) {
      return is.number(value) && !isActualNaN(value) && value % 1 === 0;
    };
    is.maximum = function(value, others) {
      if (isActualNaN(value)) {
        throw new TypeError("NaN is not a valid value");
      } else if (!is.arraylike(others)) {
        throw new TypeError("second argument must be array-like");
      }
      var len = others.length;
      while (--len >= 0) {
        if (value < others[len]) {
          return false;
        }
      }
      return true;
    };
    is.minimum = function(value, others) {
      if (isActualNaN(value)) {
        throw new TypeError("NaN is not a valid value");
      } else if (!is.arraylike(others)) {
        throw new TypeError("second argument must be array-like");
      }
      var len = others.length;
      while (--len >= 0) {
        if (value > others[len]) {
          return false;
        }
      }
      return true;
    };
    is.nan = function(value) {
      return !is.number(value) || value !== value;
    };
    is.even = function(value) {
      return is.infinite(value) || is.number(value) && value === value && value % 2 === 0;
    };
    is.odd = function(value) {
      return is.infinite(value) || is.number(value) && value === value && value % 2 !== 0;
    };
    is.ge = function(value, other) {
      if (isActualNaN(value) || isActualNaN(other)) {
        throw new TypeError("NaN is not a valid value");
      }
      return !is.infinite(value) && !is.infinite(other) && value >= other;
    };
    is.gt = function(value, other) {
      if (isActualNaN(value) || isActualNaN(other)) {
        throw new TypeError("NaN is not a valid value");
      }
      return !is.infinite(value) && !is.infinite(other) && value > other;
    };
    is.le = function(value, other) {
      if (isActualNaN(value) || isActualNaN(other)) {
        throw new TypeError("NaN is not a valid value");
      }
      return !is.infinite(value) && !is.infinite(other) && value <= other;
    };
    is.lt = function(value, other) {
      if (isActualNaN(value) || isActualNaN(other)) {
        throw new TypeError("NaN is not a valid value");
      }
      return !is.infinite(value) && !is.infinite(other) && value < other;
    };
    is.within = function(value, start, finish) {
      if (isActualNaN(value) || isActualNaN(start) || isActualNaN(finish)) {
        throw new TypeError("NaN is not a valid value");
      } else if (!is.number(value) || !is.number(start) || !is.number(finish)) {
        throw new TypeError("all arguments must be numbers");
      }
      var isAnyInfinite = is.infinite(value) || is.infinite(start) || is.infinite(finish);
      return isAnyInfinite || value >= start && value <= finish;
    };
    is.object = function(value) {
      return toStr.call(value) === "[object Object]";
    };
    is.primitive = function isPrimitive(value) {
      if (!value) {
        return true;
      }
      if (typeof value === "object" || is.object(value) || is.fn(value) || is.array(value)) {
        return false;
      }
      return true;
    };
    is.hash = function(value) {
      return is.object(value) && value.constructor === Object && !value.nodeType && !value.setInterval;
    };
    is.regexp = function(value) {
      return toStr.call(value) === "[object RegExp]";
    };
    is.string = function(value) {
      return toStr.call(value) === "[object String]";
    };
    is.base64 = function(value) {
      return is.string(value) && (!value.length || base64Regex.test(value));
    };
    is.hex = function(value) {
      return is.string(value) && (!value.length || hexRegex.test(value));
    };
    is.symbol = function(value) {
      return typeof Symbol === "function" && toStr.call(value) === "[object Symbol]" && typeof symbolValueOf.call(value) === "symbol";
    };
    is.bigint = function(value) {
      return typeof BigInt === "function" && toStr.call(value) === "[object BigInt]" && typeof bigIntValueOf.call(value) === "bigint";
    };
    module2.exports = is;
  }
});

// node_modules/node.extend.without.arrays/lib/extend.js
var require_extend = __commonJS({
  "node_modules/node.extend.without.arrays/lib/extend.js"(exports2, module2) {
    var is = require_is();
    function extend() {
      var target = arguments[0] || {};
      var i = 1;
      var length = arguments.length;
      var deep = false;
      var options, name, src, copy, copy_is_array, clone;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (typeof target !== "object" && !is.fn(target)) {
        target = {};
      }
      for (; i < length; i++) {
        options = arguments[i];
        if (options != null) {
          if (typeof options === "string") {
            options = options.split("");
          }
          for (name in options) {
            src = target[name];
            copy = options[name];
            if (target === copy) {
              continue;
            }
            if (deep && copy && (is.hash(copy) || (copy_is_array = is.array(copy)))) {
              if (copy_is_array) {
                copy_is_array = false;
                clone = extend(deep, [], copy);
              } else {
                clone = src && is.hash(src) ? src : {};
              }
              target[name] = extend(deep, clone, copy);
            } else if (typeof copy !== "undefined") {
              target[name] = copy;
            }
          }
        }
      }
      return target;
    }
    extend.version = "1.1.3";
    module2.exports = extend;
  }
});

// node_modules/node.extend.without.arrays/index.js
var require_node_extend_without = __commonJS({
  "node_modules/node.extend.without.arrays/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_extend();
  }
});

// node_modules/xregexp/lib/xregexp.js
var require_xregexp = __commonJS({
  "node_modules/xregexp/lib/xregexp.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var REGEX_DATA = "xregexp";
    var features = {
      astral: false
    };
    var nativ = {
      exec: RegExp.prototype.exec,
      test: RegExp.prototype.test,
      match: String.prototype.match,
      replace: String.prototype.replace,
      split: String.prototype.split
    };
    var fixed = {};
    var regexCache = {};
    var patternCache = {};
    var tokens = [];
    var defaultScope = "default";
    var classScope = "class";
    var nativeTokens = {
      // Any native multicharacter token in default scope, or any single character
      "default": /\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|\(\?(?:[:=!]|<[=!])|[?*+]\?|{\d+(?:,\d*)?}\??|[\s\S]/,
      // Any native multicharacter token in character class scope, or any single character
      "class": /\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|[\s\S]/
    };
    var replacementToken = /\$(?:{([\w$]+)}|<([\w$]+)>|(\d\d?|[\s\S]))/g;
    var correctExecNpcg = nativ.exec.call(/()??/, "")[1] === void 0;
    var hasFlagsProp = /x/.flags !== void 0;
    var toString = {}.toString;
    function hasNativeFlag(flag) {
      var isSupported = true;
      try {
        new RegExp("", flag);
      } catch (exception) {
        isSupported = false;
      }
      return isSupported;
    }
    var hasNativeU = hasNativeFlag("u");
    var hasNativeY = hasNativeFlag("y");
    var registeredFlags = {
      g: true,
      i: true,
      m: true,
      u: hasNativeU,
      y: hasNativeY
    };
    function augment(regex, captureNames, xSource, xFlags, isInternalOnly) {
      var p = void 0;
      regex[REGEX_DATA] = {
        captureNames
      };
      if (isInternalOnly) {
        return regex;
      }
      if (regex.__proto__) {
        regex.__proto__ = XRegExp.prototype;
      } else {
        for (p in XRegExp.prototype) {
          regex[p] = XRegExp.prototype[p];
        }
      }
      regex[REGEX_DATA].source = xSource;
      regex[REGEX_DATA].flags = xFlags ? xFlags.split("").sort().join("") : xFlags;
      return regex;
    }
    function clipDuplicates(str) {
      return nativ.replace.call(str, /([\s\S])(?=[\s\S]*\1)/g, "");
    }
    function copyRegex(regex, options) {
      if (!XRegExp.isRegExp(regex)) {
        throw new TypeError("Type RegExp expected");
      }
      var xData = regex[REGEX_DATA] || {};
      var flags = getNativeFlags(regex);
      var flagsToAdd = "";
      var flagsToRemove = "";
      var xregexpSource = null;
      var xregexpFlags = null;
      options = options || {};
      if (options.removeG) {
        flagsToRemove += "g";
      }
      if (options.removeY) {
        flagsToRemove += "y";
      }
      if (flagsToRemove) {
        flags = nativ.replace.call(flags, new RegExp("[" + flagsToRemove + "]+", "g"), "");
      }
      if (options.addG) {
        flagsToAdd += "g";
      }
      if (options.addY) {
        flagsToAdd += "y";
      }
      if (flagsToAdd) {
        flags = clipDuplicates(flags + flagsToAdd);
      }
      if (!options.isInternalOnly) {
        if (xData.source !== void 0) {
          xregexpSource = xData.source;
        }
        if (xData.flags != null) {
          xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags;
        }
      }
      regex = augment(new RegExp(options.source || regex.source, flags), hasNamedCapture(regex) ? xData.captureNames.slice(0) : null, xregexpSource, xregexpFlags, options.isInternalOnly);
      return regex;
    }
    function dec(hex2) {
      return parseInt(hex2, 16);
    }
    function getContextualTokenSeparator(match, scope, flags) {
      if (
        // No need to separate tokens if at the beginning or end of a group
        match.input[match.index - 1] === "(" || match.input[match.index + match[0].length] === ")" || // Avoid separating tokens when the following token is a quantifier
        isQuantifierNext(match.input, match.index + match[0].length, flags)
      ) {
        return "";
      }
      return "(?:)";
    }
    function getNativeFlags(regex) {
      return hasFlagsProp ? regex.flags : (
        // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation
        // with an empty string) allows this to continue working predictably when
        // `XRegExp.proptotype.toString` is overridden
        nativ.exec.call(/\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1]
      );
    }
    function hasNamedCapture(regex) {
      return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);
    }
    function hex(dec2) {
      return parseInt(dec2, 10).toString(16);
    }
    function isQuantifierNext(pattern, pos, flags) {
      var inlineCommentPattern = "\\(\\?#[^)]*\\)";
      var lineCommentPattern = "#[^#\\n]*";
      var quantifierPattern = "[?*+]|{\\d+(?:,\\d*)?}";
      return nativ.test.call(flags.indexOf("x") !== -1 ? (
        // Ignore any leading whitespace, line comments, and inline comments
        /^(?:\s|#[^#\n]*|\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/
      ) : (
        // Ignore any leading inline comments
        /^(?:\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/
      ), pattern.slice(pos));
    }
    function isType(value, type) {
      return toString.call(value) === "[object " + type + "]";
    }
    function pad4(str) {
      while (str.length < 4) {
        str = "0" + str;
      }
      return str;
    }
    function prepareFlags(pattern, flags) {
      var i = void 0;
      if (clipDuplicates(flags) !== flags) {
        throw new SyntaxError("Invalid duplicate regex flag " + flags);
      }
      pattern = nativ.replace.call(pattern, /^\(\?([\w$]+)\)/, function($0, $1) {
        if (nativ.test.call(/[gy]/, $1)) {
          throw new SyntaxError("Cannot use flag g or y in mode modifier " + $0);
        }
        flags = clipDuplicates(flags + $1);
        return "";
      });
      for (i = 0; i < flags.length; ++i) {
        if (!registeredFlags[flags[i]]) {
          throw new SyntaxError("Unknown regex flag " + flags[i]);
        }
      }
      return {
        pattern,
        flags
      };
    }
    function prepareOptions(value) {
      var options = {};
      if (isType(value, "String")) {
        XRegExp.forEach(value, /[^\s,]+/, function(match) {
          options[match] = true;
        });
        return options;
      }
      return value;
    }
    function registerFlag(flag) {
      if (!/^[\w$]$/.test(flag)) {
        throw new Error("Flag must be a single character A-Za-z0-9_$");
      }
      registeredFlags[flag] = true;
    }
    function runTokens(pattern, flags, pos, scope, context) {
      var i = tokens.length;
      var leadChar = pattern[pos];
      var result = null;
      var match = void 0;
      var t = void 0;
      while (i--) {
        t = tokens[i];
        if (t.leadChar && t.leadChar !== leadChar || t.scope !== scope && t.scope !== "all" || t.flag && !(flags.indexOf(t.flag) !== -1)) {
          continue;
        }
        match = XRegExp.exec(pattern, t.regex, pos, "sticky");
        if (match) {
          result = {
            matchLength: match[0].length,
            output: t.handler.call(context, match, scope, flags),
            reparse: t.reparse
          };
          break;
        }
      }
      return result;
    }
    function setAstral(on) {
      features.astral = on;
    }
    function toObject(value) {
      if (value == null) {
        throw new TypeError("Cannot convert null or undefined to object");
      }
      return value;
    }
    function XRegExp(pattern, flags) {
      if (XRegExp.isRegExp(pattern)) {
        if (flags !== void 0) {
          throw new TypeError("Cannot supply flags when copying a RegExp");
        }
        return copyRegex(pattern);
      }
      pattern = pattern === void 0 ? "" : String(pattern);
      flags = flags === void 0 ? "" : String(flags);
      if (XRegExp.isInstalled("astral") && !(flags.indexOf("A") !== -1)) {
        flags += "A";
      }
      if (!patternCache[pattern]) {
        patternCache[pattern] = {};
      }
      if (!patternCache[pattern][flags]) {
        var context = {
          hasNamedCapture: false,
          captureNames: []
        };
        var scope = defaultScope;
        var output = "";
        var pos = 0;
        var result = void 0;
        var applied = prepareFlags(pattern, flags);
        var appliedPattern = applied.pattern;
        var appliedFlags = applied.flags;
        while (pos < appliedPattern.length) {
          do {
            result = runTokens(appliedPattern, appliedFlags, pos, scope, context);
            if (result && result.reparse) {
              appliedPattern = appliedPattern.slice(0, pos) + result.output + appliedPattern.slice(pos + result.matchLength);
            }
          } while (result && result.reparse);
          if (result) {
            output += result.output;
            pos += result.matchLength || 1;
          } else {
            var token = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, "sticky")[0];
            output += token;
            pos += token.length;
            if (token === "[" && scope === defaultScope) {
              scope = classScope;
            } else if (token === "]" && scope === classScope) {
              scope = defaultScope;
            }
          }
        }
        patternCache[pattern][flags] = {
          // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty
          // groups are sometimes inserted during regex transpilation in order to keep tokens
          // separated. However, more than one empty group in a row is never needed.
          pattern: nativ.replace.call(output, /(?:\(\?:\))+/g, "(?:)"),
          // Strip all but native flags
          flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ""),
          // `context.captureNames` has an item for each capturing group, even if unnamed
          captures: context.hasNamedCapture ? context.captureNames : null
        };
      }
      var generated = patternCache[pattern][flags];
      return augment(new RegExp(generated.pattern, generated.flags), generated.captures, pattern, flags);
    }
    XRegExp.prototype = /(?:)/;
    XRegExp.version = "4.0.0";
    XRegExp._clipDuplicates = clipDuplicates;
    XRegExp._hasNativeFlag = hasNativeFlag;
    XRegExp._dec = dec;
    XRegExp._hex = hex;
    XRegExp._pad4 = pad4;
    XRegExp.addToken = function(regex, handler, options) {
      options = options || {};
      var optionalFlags = options.optionalFlags;
      var i = void 0;
      if (options.flag) {
        registerFlag(options.flag);
      }
      if (optionalFlags) {
        optionalFlags = nativ.split.call(optionalFlags, "");
        for (i = 0; i < optionalFlags.length; ++i) {
          registerFlag(optionalFlags[i]);
        }
      }
      tokens.push({
        regex: copyRegex(regex, {
          addG: true,
          addY: hasNativeY,
          isInternalOnly: true
        }),
        handler,
        scope: options.scope || defaultScope,
        flag: options.flag,
        reparse: options.reparse,
        leadChar: options.leadChar
      });
      XRegExp.cache.flush("patterns");
    };
    XRegExp.cache = function(pattern, flags) {
      if (!regexCache[pattern]) {
        regexCache[pattern] = {};
      }
      return regexCache[pattern][flags] || (regexCache[pattern][flags] = XRegExp(pattern, flags));
    };
    XRegExp.cache.flush = function(cacheName) {
      if (cacheName === "patterns") {
        patternCache = {};
      } else {
        regexCache = {};
      }
    };
    XRegExp.escape = function(str) {
      return nativ.replace.call(toObject(str), /[-\[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    };
    XRegExp.exec = function(str, regex, pos, sticky) {
      var cacheKey = "g";
      var addY = false;
      var fakeY = false;
      var match = void 0;
      addY = hasNativeY && !!(sticky || regex.sticky && sticky !== false);
      if (addY) {
        cacheKey += "y";
      } else if (sticky) {
        fakeY = true;
        cacheKey += "FakeY";
      }
      regex[REGEX_DATA] = regex[REGEX_DATA] || {};
      var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
        addG: true,
        addY,
        source: fakeY ? regex.source + "|()" : void 0,
        removeY: sticky === false,
        isInternalOnly: true
      }));
      pos = pos || 0;
      r2.lastIndex = pos;
      match = fixed.exec.call(r2, str);
      if (fakeY && match && match.pop() === "") {
        match = null;
      }
      if (regex.global) {
        regex.lastIndex = match ? r2.lastIndex : 0;
      }
      return match;
    };
    XRegExp.forEach = function(str, regex, callback) {
      var pos = 0;
      var i = -1;
      var match = void 0;
      while (match = XRegExp.exec(str, regex, pos)) {
        callback(match, ++i, str, regex);
        pos = match.index + (match[0].length || 1);
      }
    };
    XRegExp.globalize = function(regex) {
      return copyRegex(regex, { addG: true });
    };
    XRegExp.install = function(options) {
      options = prepareOptions(options);
      if (!features.astral && options.astral) {
        setAstral(true);
      }
    };
    XRegExp.isInstalled = function(feature) {
      return !!features[feature];
    };
    XRegExp.isRegExp = function(value) {
      return toString.call(value) === "[object RegExp]";
    };
    XRegExp.match = function(str, regex, scope) {
      var global2 = regex.global && scope !== "one" || scope === "all";
      var cacheKey = (global2 ? "g" : "") + (regex.sticky ? "y" : "") || "noGY";
      regex[REGEX_DATA] = regex[REGEX_DATA] || {};
      var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
        addG: !!global2,
        removeG: scope === "one",
        isInternalOnly: true
      }));
      var result = nativ.match.call(toObject(str), r2);
      if (regex.global) {
        regex.lastIndex = scope === "one" && result ? (
          // Can't use `r2.lastIndex` since `r2` is nonglobal in this case
          result.index + result[0].length
        ) : 0;
      }
      return global2 ? result || [] : result && result[0];
    };
    XRegExp.matchChain = function(str, chain) {
      return function recurseChain(values, level) {
        var item = chain[level].regex ? chain[level] : { regex: chain[level] };
        var matches = [];
        function addMatch(match) {
          if (item.backref) {
            if (!(match.hasOwnProperty(item.backref) || +item.backref < match.length)) {
              throw new ReferenceError("Backreference to undefined group: " + item.backref);
            }
            matches.push(match[item.backref] || "");
          } else {
            matches.push(match[0]);
          }
        }
        for (var i = 0; i < values.length; ++i) {
          XRegExp.forEach(values[i], item.regex, addMatch);
        }
        return level === chain.length - 1 || !matches.length ? matches : recurseChain(matches, level + 1);
      }([str], 0);
    };
    XRegExp.replace = function(str, search, replacement, scope) {
      var isRegex = XRegExp.isRegExp(search);
      var global2 = search.global && scope !== "one" || scope === "all";
      var cacheKey = (global2 ? "g" : "") + (search.sticky ? "y" : "") || "noGY";
      var s2 = search;
      if (isRegex) {
        search[REGEX_DATA] = search[REGEX_DATA] || {};
        s2 = search[REGEX_DATA][cacheKey] || (search[REGEX_DATA][cacheKey] = copyRegex(search, {
          addG: !!global2,
          removeG: scope === "one",
          isInternalOnly: true
        }));
      } else if (global2) {
        s2 = new RegExp(XRegExp.escape(String(search)), "g");
      }
      var result = fixed.replace.call(toObject(str), s2, replacement);
      if (isRegex && search.global) {
        search.lastIndex = 0;
      }
      return result;
    };
    XRegExp.replaceEach = function(str, replacements) {
      var i = void 0;
      var r = void 0;
      for (i = 0; i < replacements.length; ++i) {
        r = replacements[i];
        str = XRegExp.replace(str, r[0], r[1], r[2]);
      }
      return str;
    };
    XRegExp.split = function(str, separator, limit) {
      return fixed.split.call(toObject(str), separator, limit);
    };
    XRegExp.test = function(str, regex, pos, sticky) {
      return !!XRegExp.exec(str, regex, pos, sticky);
    };
    XRegExp.uninstall = function(options) {
      options = prepareOptions(options);
      if (features.astral && options.astral) {
        setAstral(false);
      }
    };
    XRegExp.union = function(patterns, flags, options) {
      options = options || {};
      var conjunction = options.conjunction || "or";
      var numCaptures = 0;
      var numPriorCaptures = void 0;
      var captureNames = void 0;
      function rewrite(match, paren, backref) {
        var name = captureNames[numCaptures - numPriorCaptures];
        if (paren) {
          ++numCaptures;
          if (name) {
            return "(?<" + name + ">";
          }
        } else if (backref) {
          return "\\" + (+backref + numPriorCaptures);
        }
        return match;
      }
      if (!(isType(patterns, "Array") && patterns.length)) {
        throw new TypeError("Must provide a nonempty array of patterns to merge");
      }
      var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
      var output = [];
      var pattern = void 0;
      for (var i = 0; i < patterns.length; ++i) {
        pattern = patterns[i];
        if (XRegExp.isRegExp(pattern)) {
          numPriorCaptures = numCaptures;
          captureNames = pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames || [];
          output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));
        } else {
          output.push(XRegExp.escape(pattern));
        }
      }
      var separator = conjunction === "none" ? "" : "|";
      return XRegExp(output.join(separator), flags);
    };
    fixed.exec = function(str) {
      var origLastIndex = this.lastIndex;
      var match = nativ.exec.apply(this, arguments);
      if (match) {
        if (!correctExecNpcg && match.length > 1 && match.indexOf("") !== -1) {
          var r2 = copyRegex(this, {
            removeG: true,
            isInternalOnly: true
          });
          nativ.replace.call(String(str).slice(match.index), r2, function() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            var len = args.length;
            for (var i2 = 1; i2 < len - 2; ++i2) {
              if (args[i2] === void 0) {
                match[i2] = void 0;
              }
            }
          });
        }
        if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {
          for (var i = 1; i < match.length; ++i) {
            var name = this[REGEX_DATA].captureNames[i - 1];
            if (name) {
              match[name] = match[i];
            }
          }
        }
        if (this.global && !match[0].length && this.lastIndex > match.index) {
          this.lastIndex = match.index;
        }
      }
      if (!this.global) {
        this.lastIndex = origLastIndex;
      }
      return match;
    };
    fixed.test = function(str) {
      return !!fixed.exec.call(this, str);
    };
    fixed.match = function(regex) {
      if (!XRegExp.isRegExp(regex)) {
        regex = new RegExp(regex);
      } else if (regex.global) {
        var result = nativ.match.apply(this, arguments);
        regex.lastIndex = 0;
        return result;
      }
      return fixed.exec.call(regex, toObject(this));
    };
    fixed.replace = function(search, replacement) {
      var isRegex = XRegExp.isRegExp(search);
      var origLastIndex = void 0;
      var captureNames = void 0;
      var result = void 0;
      if (isRegex) {
        if (search[REGEX_DATA]) {
          captureNames = search[REGEX_DATA].captureNames;
        }
        origLastIndex = search.lastIndex;
      } else {
        search += "";
      }
      if (isType(replacement, "Function")) {
        result = nativ.replace.call(String(this), search, function() {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          if (captureNames) {
            args[0] = new String(args[0]);
            for (var i = 0; i < captureNames.length; ++i) {
              if (captureNames[i]) {
                args[0][captureNames[i]] = args[i + 1];
              }
            }
          }
          if (isRegex && search.global) {
            search.lastIndex = args[args.length - 2] + args[0].length;
          }
          return replacement.apply(void 0, args);
        });
      } else {
        result = nativ.replace.call(this == null ? this : String(this), search, function() {
          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          return nativ.replace.call(String(replacement), replacementToken, replacer);
          function replacer($0, bracketed, angled, dollarToken) {
            bracketed = bracketed || angled;
            if (bracketed) {
              var n = +bracketed;
              if (n <= args.length - 3) {
                return args[n] || "";
              }
              n = captureNames ? captureNames.indexOf(bracketed) : -1;
              if (n < 0) {
                throw new SyntaxError("Backreference to undefined group " + $0);
              }
              return args[n + 1] || "";
            }
            if (dollarToken === "$") {
              return "$";
            }
            if (dollarToken === "&" || +dollarToken === 0) {
              return args[0];
            }
            if (dollarToken === "`") {
              return args[args.length - 1].slice(0, args[args.length - 2]);
            }
            if (dollarToken === "'") {
              return args[args.length - 1].slice(args[args.length - 2] + args[0].length);
            }
            dollarToken = +dollarToken;
            if (!isNaN(dollarToken)) {
              if (dollarToken > args.length - 3) {
                throw new SyntaxError("Backreference to undefined group " + $0);
              }
              return args[dollarToken] || "";
            }
            throw new SyntaxError("Invalid token " + $0);
          }
        });
      }
      if (isRegex) {
        if (search.global) {
          search.lastIndex = 0;
        } else {
          search.lastIndex = origLastIndex;
        }
      }
      return result;
    };
    fixed.split = function(separator, limit) {
      if (!XRegExp.isRegExp(separator)) {
        return nativ.split.apply(this, arguments);
      }
      var str = String(this);
      var output = [];
      var origLastIndex = separator.lastIndex;
      var lastLastIndex = 0;
      var lastLength = void 0;
      limit = (limit === void 0 ? -1 : limit) >>> 0;
      XRegExp.forEach(str, separator, function(match) {
        if (match.index + match[0].length > lastLastIndex) {
          output.push(str.slice(lastLastIndex, match.index));
          if (match.length > 1 && match.index < str.length) {
            Array.prototype.push.apply(output, match.slice(1));
          }
          lastLength = match[0].length;
          lastLastIndex = match.index + lastLength;
        }
      });
      if (lastLastIndex === str.length) {
        if (!nativ.test.call(separator, "") || lastLength) {
          output.push("");
        }
      } else {
        output.push(str.slice(lastLastIndex));
      }
      separator.lastIndex = origLastIndex;
      return output.length > limit ? output.slice(0, limit) : output;
    };
    XRegExp.addToken(/\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4}|{[\dA-Fa-f]+})|x(?![\dA-Fa-f]{2}))/, function(match, scope) {
      if (match[1] === "B" && scope === defaultScope) {
        return match[0];
      }
      throw new SyntaxError("Invalid escape " + match[0]);
    }, {
      scope: "all",
      leadChar: "\\"
    });
    XRegExp.addToken(/\\u{([\dA-Fa-f]+)}/, function(match, scope, flags) {
      var code = dec(match[1]);
      if (code > 1114111) {
        throw new SyntaxError("Invalid Unicode code point " + match[0]);
      }
      if (code <= 65535) {
        return "\\u" + pad4(hex(code));
      }
      if (hasNativeU && flags.indexOf("u") !== -1) {
        return match[0];
      }
      throw new SyntaxError("Cannot use Unicode code point above \\u{FFFF} without flag u");
    }, {
      scope: "all",
      leadChar: "\\"
    });
    XRegExp.addToken(
      /\[(\^?)\]/,
      // For cross-browser compatibility with ES3, convert [] to \b\B and [^] to [\s\S].
      // (?!) should work like \b\B, but is unreliable in some versions of Firefox
      /* eslint-disable no-confusing-arrow */
      function(match) {
        return match[1] ? "[\\s\\S]" : "\\b\\B";
      },
      /* eslint-enable no-confusing-arrow */
      { leadChar: "[" }
    );
    XRegExp.addToken(/\(\?#[^)]*\)/, getContextualTokenSeparator, { leadChar: "(" });
    XRegExp.addToken(/\s+|#[^\n]*\n?/, getContextualTokenSeparator, { flag: "x" });
    XRegExp.addToken(/\./, function() {
      return "[\\s\\S]";
    }, {
      flag: "s",
      leadChar: "."
    });
    XRegExp.addToken(/\\k<([\w$]+)>/, function(match) {
      var index = isNaN(match[1]) ? this.captureNames.indexOf(match[1]) + 1 : +match[1];
      var endIndex = match.index + match[0].length;
      if (!index || index > this.captureNames.length) {
        throw new SyntaxError("Backreference to undefined group " + match[0]);
      }
      return "\\" + index + (endIndex === match.input.length || isNaN(match.input[endIndex]) ? "" : "(?:)");
    }, { leadChar: "\\" });
    XRegExp.addToken(/\\(\d+)/, function(match, scope) {
      if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) && match[1] !== "0") {
        throw new SyntaxError("Cannot use octal escape or backreference to undefined group " + match[0]);
      }
      return match[0];
    }, {
      scope: "all",
      leadChar: "\\"
    });
    XRegExp.addToken(/\(\?P?<([\w$]+)>/, function(match) {
      if (!isNaN(match[1])) {
        throw new SyntaxError("Cannot use integer as capture name " + match[0]);
      }
      if (match[1] === "length" || match[1] === "__proto__") {
        throw new SyntaxError("Cannot use reserved word as capture name " + match[0]);
      }
      if (this.captureNames.indexOf(match[1]) !== -1) {
        throw new SyntaxError("Cannot use same name for multiple groups " + match[0]);
      }
      this.captureNames.push(match[1]);
      this.hasNamedCapture = true;
      return "(";
    }, { leadChar: "(" });
    XRegExp.addToken(/\((?!\?)/, function(match, scope, flags) {
      if (flags.indexOf("n") !== -1) {
        return "(?:";
      }
      this.captureNames.push(null);
      return "(";
    }, {
      optionalFlags: "n",
      leadChar: "("
    });
    exports2.default = XRegExp;
    module2.exports = exports2["default"];
  }
});

// node_modules/xregexp/lib/addons/build.js
var require_build = __commonJS({
  "node_modules/xregexp/lib/addons/build.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(XRegExp) {
      var REGEX_DATA = "xregexp";
      var subParts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
      var parts = XRegExp.union([/\({{([\w$]+)}}\)|{{([\w$]+)}}/, subParts], "g", {
        conjunction: "or"
      });
      function deanchor(pattern) {
        var leadingAnchor = /^(?:\(\?:\))*\^/;
        var trailingAnchor = /\$(?:\(\?:\))*$/;
        if (leadingAnchor.test(pattern) && trailingAnchor.test(pattern) && // Ensure that the trailing `$` isn't escaped
        trailingAnchor.test(pattern.replace(/\\[\s\S]/g, ""))) {
          return pattern.replace(leadingAnchor, "").replace(trailingAnchor, "");
        }
        return pattern;
      }
      function asXRegExp(value, addFlagX) {
        var flags = addFlagX ? "x" : "";
        return XRegExp.isRegExp(value) ? value[REGEX_DATA] && value[REGEX_DATA].captureNames ? (
          // Don't recompile, to preserve capture names
          value
        ) : (
          // Recompile as XRegExp
          XRegExp(value.source, flags)
        ) : (
          // Compile string as XRegExp
          XRegExp(value, flags)
        );
      }
      function interpolate(substitution) {
        return substitution instanceof RegExp ? substitution : XRegExp.escape(substitution);
      }
      function reduceToSubpatternsObject(subpatterns, interpolated, subpatternIndex) {
        subpatterns["subpattern" + subpatternIndex] = interpolated;
        return subpatterns;
      }
      function embedSubpatternAfter(raw, subpatternIndex, rawLiterals) {
        var hasSubpattern = subpatternIndex < rawLiterals.length - 1;
        return raw + (hasSubpattern ? "{{subpattern" + subpatternIndex + "}}" : "");
      }
      XRegExp.tag = function(flags) {
        return function(literals) {
          for (var _len = arguments.length, substitutions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            substitutions[_key - 1] = arguments[_key];
          }
          var subpatterns = substitutions.map(interpolate).reduce(reduceToSubpatternsObject, {});
          var pattern = literals.raw.map(embedSubpatternAfter).join("");
          return XRegExp.build(pattern, subpatterns, flags);
        };
      };
      XRegExp.build = function(pattern, subs, flags) {
        flags = flags || "";
        var addFlagX = flags.indexOf("x") !== -1;
        var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern);
        if (inlineFlags) {
          flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);
        }
        var data = {};
        for (var p in subs) {
          if (subs.hasOwnProperty(p)) {
            var sub = asXRegExp(subs[p], addFlagX);
            data[p] = {
              // Deanchoring allows embedding independently useful anchored regexes. If you
              // really need to keep your anchors, double them (i.e., `^^...$$`).
              pattern: deanchor(sub.source),
              names: sub[REGEX_DATA].captureNames || []
            };
          }
        }
        var patternAsRegex = asXRegExp(pattern, addFlagX);
        var numCaps = 0;
        var numPriorCaps = void 0;
        var numOuterCaps = 0;
        var outerCapsMap = [0];
        var outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];
        var output = patternAsRegex.source.replace(parts, function($0, $1, $2, $3, $4) {
          var subName = $1 || $2;
          var capName = void 0;
          var intro = void 0;
          var localCapIndex = void 0;
          if (subName) {
            if (!data.hasOwnProperty(subName)) {
              throw new ReferenceError("Undefined property " + $0);
            }
            if ($1) {
              capName = outerCapNames[numOuterCaps];
              outerCapsMap[++numOuterCaps] = ++numCaps;
              intro = "(?<" + (capName || subName) + ">";
            } else {
              intro = "(?:";
            }
            numPriorCaps = numCaps;
            var rewrittenSubpattern = data[subName].pattern.replace(subParts, function(match, paren, backref) {
              if (paren) {
                capName = data[subName].names[numCaps - numPriorCaps];
                ++numCaps;
                if (capName) {
                  return "(?<" + capName + ">";
                }
              } else if (backref) {
                localCapIndex = +backref - 1;
                return data[subName].names[localCapIndex] ? (
                  // Need to preserve the backreference name in case using flag `n`
                  "\\k<" + data[subName].names[localCapIndex] + ">"
                ) : "\\" + (+backref + numPriorCaps);
              }
              return match;
            });
            return "" + intro + rewrittenSubpattern + ")";
          }
          if ($3) {
            capName = outerCapNames[numOuterCaps];
            outerCapsMap[++numOuterCaps] = ++numCaps;
            if (capName) {
              return "(?<" + capName + ">";
            }
          } else if ($4) {
            localCapIndex = +$4 - 1;
            return outerCapNames[localCapIndex] ? (
              // Need to preserve the backreference name in case using flag `n`
              "\\k<" + outerCapNames[localCapIndex] + ">"
            ) : "\\" + outerCapsMap[+$4];
          }
          return $0;
        });
        return XRegExp(output, flags);
      };
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/xregexp/lib/addons/matchrecursive.js
var require_matchrecursive = __commonJS({
  "node_modules/xregexp/lib/addons/matchrecursive.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(XRegExp) {
      function row(name, value, start, end) {
        return {
          name,
          value,
          start,
          end
        };
      }
      XRegExp.matchRecursive = function(str, left, right, flags, options) {
        flags = flags || "";
        options = options || {};
        var global2 = flags.indexOf("g") !== -1;
        var sticky = flags.indexOf("y") !== -1;
        var basicFlags = flags.replace(/y/g, "");
        var escapeChar = options.escapeChar;
        var vN = options.valueNames;
        var output = [];
        var openTokens = 0;
        var delimStart = 0;
        var delimEnd = 0;
        var lastOuterEnd = 0;
        var outerStart = void 0;
        var innerStart = void 0;
        var leftMatch = void 0;
        var rightMatch = void 0;
        var esc = void 0;
        left = XRegExp(left, basicFlags);
        right = XRegExp(right, basicFlags);
        if (escapeChar) {
          if (escapeChar.length > 1) {
            throw new Error("Cannot use more than one escape character");
          }
          escapeChar = XRegExp.escape(escapeChar);
          esc = new RegExp(
            "(?:" + escapeChar + "[\\S\\s]|(?:(?!" + // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.
            // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax
            // transformation resulting from those flags was already applied to `left` and
            // `right` when they were passed through the XRegExp constructor above.
            XRegExp.union([left, right], "", { conjunction: "or" }).source + ")[^" + escapeChar + "])+)+",
            // Flags `gy` not needed here
            flags.replace(/[^imu]+/g, "")
          );
        }
        while (true) {
          if (escapeChar) {
            delimEnd += (XRegExp.exec(str, esc, delimEnd, "sticky") || [""])[0].length;
          }
          leftMatch = XRegExp.exec(str, left, delimEnd);
          rightMatch = XRegExp.exec(str, right, delimEnd);
          if (leftMatch && rightMatch) {
            if (leftMatch.index <= rightMatch.index) {
              rightMatch = null;
            } else {
              leftMatch = null;
            }
          }
          if (leftMatch || rightMatch) {
            delimStart = (leftMatch || rightMatch).index;
            delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
          } else if (!openTokens) {
            break;
          }
          if (sticky && !openTokens && delimStart > lastOuterEnd) {
            break;
          }
          if (leftMatch) {
            if (!openTokens) {
              outerStart = delimStart;
              innerStart = delimEnd;
            }
            ++openTokens;
          } else if (rightMatch && openTokens) {
            if (!--openTokens) {
              if (vN) {
                if (vN[0] && outerStart > lastOuterEnd) {
                  output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
                }
                if (vN[1]) {
                  output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
                }
                if (vN[2]) {
                  output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
                }
                if (vN[3]) {
                  output.push(row(vN[3], str.slice(delimStart, delimEnd), delimStart, delimEnd));
                }
              } else {
                output.push(str.slice(innerStart, delimStart));
              }
              lastOuterEnd = delimEnd;
              if (!global2) {
                break;
              }
            }
          } else {
            throw new Error("Unbalanced delimiter found in string");
          }
          if (delimStart === delimEnd) {
            ++delimEnd;
          }
        }
        if (global2 && !sticky && vN && vN[0] && str.length > lastOuterEnd) {
          output.push(row(vN[0], str.slice(lastOuterEnd), lastOuterEnd, str.length));
        }
        return output;
      };
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/xregexp/lib/addons/unicode-base.js
var require_unicode_base = __commonJS({
  "node_modules/xregexp/lib/addons/unicode-base.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(XRegExp) {
      var unicode = {};
      var dec = XRegExp._dec;
      var hex = XRegExp._hex;
      var pad4 = XRegExp._pad4;
      function normalize(name) {
        return name.replace(/[- _]+/g, "").toLowerCase();
      }
      function charCode(chr) {
        var esc = /^\\[xu](.+)/.exec(chr);
        return esc ? dec(esc[1]) : chr.charCodeAt(chr[0] === "\\" ? 1 : 0);
      }
      function invertBmp(range) {
        var output = "";
        var lastEnd = -1;
        XRegExp.forEach(range, /(\\x..|\\u....|\\?[\s\S])(?:-(\\x..|\\u....|\\?[\s\S]))?/, function(m) {
          var start = charCode(m[1]);
          if (start > lastEnd + 1) {
            output += "\\u" + pad4(hex(lastEnd + 1));
            if (start > lastEnd + 2) {
              output += "-\\u" + pad4(hex(start - 1));
            }
          }
          lastEnd = charCode(m[2] || m[1]);
        });
        if (lastEnd < 65535) {
          output += "\\u" + pad4(hex(lastEnd + 1));
          if (lastEnd < 65534) {
            output += "-\\uFFFF";
          }
        }
        return output;
      }
      function cacheInvertedBmp(slug) {
        var prop = "b!";
        return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));
      }
      function buildAstral(slug, isNegated) {
        var item = unicode[slug];
        var combined = "";
        if (item.bmp && !item.isBmpLast) {
          combined = "[" + item.bmp + "]" + (item.astral ? "|" : "");
        }
        if (item.astral) {
          combined += item.astral;
        }
        if (item.isBmpLast && item.bmp) {
          combined += (item.astral ? "|" : "") + "[" + item.bmp + "]";
        }
        return isNegated ? "(?:(?!" + combined + ")(?:[\uD800-\uDBFF][\uDC00-\uDFFF]|[\0-\uFFFF]))" : "(?:" + combined + ")";
      }
      function cacheAstral(slug, isNegated) {
        var prop = isNegated ? "a!" : "a=";
        return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated));
      }
      XRegExp.addToken(
        // Use `*` instead of `+` to avoid capturing `^` as the token name in `\p{^}`
        /\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/,
        function(match, scope, flags) {
          var ERR_DOUBLE_NEG = "Invalid double negation ";
          var ERR_UNKNOWN_NAME = "Unknown Unicode token ";
          var ERR_UNKNOWN_REF = "Unicode token missing data ";
          var ERR_ASTRAL_ONLY = "Astral mode required for Unicode token ";
          var ERR_ASTRAL_IN_CLASS = "Astral mode does not support Unicode tokens within character classes";
          var isNegated = match[1] === "P" || !!match[2];
          var isAstralMode = flags.indexOf("A") !== -1;
          var slug = normalize(match[4] || match[3]);
          var item = unicode[slug];
          if (match[1] === "P" && match[2]) {
            throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);
          }
          if (!unicode.hasOwnProperty(slug)) {
            throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);
          }
          if (item.inverseOf) {
            slug = normalize(item.inverseOf);
            if (!unicode.hasOwnProperty(slug)) {
              throw new ReferenceError(ERR_UNKNOWN_REF + match[0] + " -> " + item.inverseOf);
            }
            item = unicode[slug];
            isNegated = !isNegated;
          }
          if (!(item.bmp || isAstralMode)) {
            throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);
          }
          if (isAstralMode) {
            if (scope === "class") {
              throw new SyntaxError(ERR_ASTRAL_IN_CLASS);
            }
            return cacheAstral(slug, isNegated);
          }
          return scope === "class" ? isNegated ? cacheInvertedBmp(slug) : item.bmp : (isNegated ? "[^" : "[") + item.bmp + "]";
        },
        {
          scope: "all",
          optionalFlags: "A",
          leadChar: "\\"
        }
      );
      XRegExp.addUnicodeData = function(data) {
        var ERR_NO_NAME = "Unicode token requires name";
        var ERR_NO_DATA = "Unicode token has no character data ";
        var item = void 0;
        for (var i = 0; i < data.length; ++i) {
          item = data[i];
          if (!item.name) {
            throw new Error(ERR_NO_NAME);
          }
          if (!(item.inverseOf || item.bmp || item.astral)) {
            throw new Error(ERR_NO_DATA + item.name);
          }
          unicode[normalize(item.name)] = item;
          if (item.alias) {
            unicode[normalize(item.alias)] = item;
          }
        }
        XRegExp.cache.flush("patterns");
      };
      XRegExp._getUnicodeProperty = function(name) {
        var slug = normalize(name);
        return unicode[slug];
      };
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/xregexp/lib/addons/unicode-blocks.js
var require_unicode_blocks = __commonJS({
  "node_modules/xregexp/lib/addons/unicode-blocks.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(XRegExp) {
      if (!XRegExp.addUnicodeData) {
        throw new ReferenceError("Unicode Base must be loaded before Unicode Blocks");
      }
      XRegExp.addUnicodeData([{
        name: "InAdlam",
        astral: "\uD83A[\uDD00-\uDD5F]"
      }, {
        name: "InAegean_Numbers",
        astral: "\uD800[\uDD00-\uDD3F]"
      }, {
        name: "InAhom",
        astral: "\uD805[\uDF00-\uDF3F]"
      }, {
        name: "InAlchemical_Symbols",
        astral: "\uD83D[\uDF00-\uDF7F]"
      }, {
        name: "InAlphabetic_Presentation_Forms",
        bmp: "\uFB00-\uFB4F"
      }, {
        name: "InAnatolian_Hieroglyphs",
        astral: "\uD811[\uDC00-\uDE7F]"
      }, {
        name: "InAncient_Greek_Musical_Notation",
        astral: "\uD834[\uDE00-\uDE4F]"
      }, {
        name: "InAncient_Greek_Numbers",
        astral: "\uD800[\uDD40-\uDD8F]"
      }, {
        name: "InAncient_Symbols",
        astral: "\uD800[\uDD90-\uDDCF]"
      }, {
        name: "InArabic",
        bmp: "\u0600-\u06FF"
      }, {
        name: "InArabic_Extended_A",
        bmp: "\u08A0-\u08FF"
      }, {
        name: "InArabic_Mathematical_Alphabetic_Symbols",
        astral: "\uD83B[\uDE00-\uDEFF]"
      }, {
        name: "InArabic_Presentation_Forms_A",
        bmp: "\uFB50-\uFDFF"
      }, {
        name: "InArabic_Presentation_Forms_B",
        bmp: "\uFE70-\uFEFF"
      }, {
        name: "InArabic_Supplement",
        bmp: "\u0750-\u077F"
      }, {
        name: "InArmenian",
        bmp: "\u0530-\u058F"
      }, {
        name: "InArrows",
        bmp: "\u2190-\u21FF"
      }, {
        name: "InAvestan",
        astral: "\uD802[\uDF00-\uDF3F]"
      }, {
        name: "InBalinese",
        bmp: "\u1B00-\u1B7F"
      }, {
        name: "InBamum",
        bmp: "\uA6A0-\uA6FF"
      }, {
        name: "InBamum_Supplement",
        astral: "\uD81A[\uDC00-\uDE3F]"
      }, {
        name: "InBasic_Latin",
        bmp: "\0-\x7F"
      }, {
        name: "InBassa_Vah",
        astral: "\uD81A[\uDED0-\uDEFF]"
      }, {
        name: "InBatak",
        bmp: "\u1BC0-\u1BFF"
      }, {
        name: "InBengali",
        bmp: "\u0980-\u09FF"
      }, {
        name: "InBhaiksuki",
        astral: "\uD807[\uDC00-\uDC6F]"
      }, {
        name: "InBlock_Elements",
        bmp: "\u2580-\u259F"
      }, {
        name: "InBopomofo",
        bmp: "\u3100-\u312F"
      }, {
        name: "InBopomofo_Extended",
        bmp: "\u31A0-\u31BF"
      }, {
        name: "InBox_Drawing",
        bmp: "\u2500-\u257F"
      }, {
        name: "InBrahmi",
        astral: "\uD804[\uDC00-\uDC7F]"
      }, {
        name: "InBraille_Patterns",
        bmp: "\u2800-\u28FF"
      }, {
        name: "InBuginese",
        bmp: "\u1A00-\u1A1F"
      }, {
        name: "InBuhid",
        bmp: "\u1740-\u175F"
      }, {
        name: "InByzantine_Musical_Symbols",
        astral: "\uD834[\uDC00-\uDCFF]"
      }, {
        name: "InCJK_Compatibility",
        bmp: "\u3300-\u33FF"
      }, {
        name: "InCJK_Compatibility_Forms",
        bmp: "\uFE30-\uFE4F"
      }, {
        name: "InCJK_Compatibility_Ideographs",
        bmp: "\uF900-\uFAFF"
      }, {
        name: "InCJK_Compatibility_Ideographs_Supplement",
        astral: "\uD87E[\uDC00-\uDE1F]"
      }, {
        name: "InCJK_Radicals_Supplement",
        bmp: "\u2E80-\u2EFF"
      }, {
        name: "InCJK_Strokes",
        bmp: "\u31C0-\u31EF"
      }, {
        name: "InCJK_Symbols_and_Punctuation",
        bmp: "\u3000-\u303F"
      }, {
        name: "InCJK_Unified_Ideographs",
        bmp: "\u4E00-\u9FFF"
      }, {
        name: "InCJK_Unified_Ideographs_Extension_A",
        bmp: "\u3400-\u4DBF"
      }, {
        name: "InCJK_Unified_Ideographs_Extension_B",
        astral: "[\uD840-\uD868][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDF]"
      }, {
        name: "InCJK_Unified_Ideographs_Extension_C",
        astral: "\uD869[\uDF00-\uDFFF]|[\uD86A-\uD86C][\uDC00-\uDFFF]|\uD86D[\uDC00-\uDF3F]"
      }, {
        name: "InCJK_Unified_Ideographs_Extension_D",
        astral: "\uD86D[\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1F]"
      }, {
        name: "InCJK_Unified_Ideographs_Extension_E",
        astral: "\uD86E[\uDC20-\uDFFF]|[\uD86F-\uD872][\uDC00-\uDFFF]|\uD873[\uDC00-\uDEAF]"
      }, {
        name: "InCarian",
        astral: "\uD800[\uDEA0-\uDEDF]"
      }, {
        name: "InCaucasian_Albanian",
        astral: "\uD801[\uDD30-\uDD6F]"
      }, {
        name: "InChakma",
        astral: "\uD804[\uDD00-\uDD4F]"
      }, {
        name: "InCham",
        bmp: "\uAA00-\uAA5F"
      }, {
        name: "InCherokee",
        bmp: "\u13A0-\u13FF"
      }, {
        name: "InCherokee_Supplement",
        bmp: "\uAB70-\uABBF"
      }, {
        name: "InCombining_Diacritical_Marks",
        bmp: "\u0300-\u036F"
      }, {
        name: "InCombining_Diacritical_Marks_Extended",
        bmp: "\u1AB0-\u1AFF"
      }, {
        name: "InCombining_Diacritical_Marks_Supplement",
        bmp: "\u1DC0-\u1DFF"
      }, {
        name: "InCombining_Diacritical_Marks_for_Symbols",
        bmp: "\u20D0-\u20FF"
      }, {
        name: "InCombining_Half_Marks",
        bmp: "\uFE20-\uFE2F"
      }, {
        name: "InCommon_Indic_Number_Forms",
        bmp: "\uA830-\uA83F"
      }, {
        name: "InControl_Pictures",
        bmp: "\u2400-\u243F"
      }, {
        name: "InCoptic",
        bmp: "\u2C80-\u2CFF"
      }, {
        name: "InCoptic_Epact_Numbers",
        astral: "\uD800[\uDEE0-\uDEFF]"
      }, {
        name: "InCounting_Rod_Numerals",
        astral: "\uD834[\uDF60-\uDF7F]"
      }, {
        name: "InCuneiform",
        astral: "\uD808[\uDC00-\uDFFF]"
      }, {
        name: "InCuneiform_Numbers_and_Punctuation",
        astral: "\uD809[\uDC00-\uDC7F]"
      }, {
        name: "InCurrency_Symbols",
        bmp: "\u20A0-\u20CF"
      }, {
        name: "InCypriot_Syllabary",
        astral: "\uD802[\uDC00-\uDC3F]"
      }, {
        name: "InCyrillic",
        bmp: "\u0400-\u04FF"
      }, {
        name: "InCyrillic_Extended_A",
        bmp: "\u2DE0-\u2DFF"
      }, {
        name: "InCyrillic_Extended_B",
        bmp: "\uA640-\uA69F"
      }, {
        name: "InCyrillic_Extended_C",
        bmp: "\u1C80-\u1C8F"
      }, {
        name: "InCyrillic_Supplement",
        bmp: "\u0500-\u052F"
      }, {
        name: "InDeseret",
        astral: "\uD801[\uDC00-\uDC4F]"
      }, {
        name: "InDevanagari",
        bmp: "\u0900-\u097F"
      }, {
        name: "InDevanagari_Extended",
        bmp: "\uA8E0-\uA8FF"
      }, {
        name: "InDingbats",
        bmp: "\u2700-\u27BF"
      }, {
        name: "InDomino_Tiles",
        astral: "\uD83C[\uDC30-\uDC9F]"
      }, {
        name: "InDuployan",
        astral: "\uD82F[\uDC00-\uDC9F]"
      }, {
        name: "InEarly_Dynastic_Cuneiform",
        astral: "\uD809[\uDC80-\uDD4F]"
      }, {
        name: "InEgyptian_Hieroglyphs",
        astral: "\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F]"
      }, {
        name: "InElbasan",
        astral: "\uD801[\uDD00-\uDD2F]"
      }, {
        name: "InEmoticons",
        astral: "\uD83D[\uDE00-\uDE4F]"
      }, {
        name: "InEnclosed_Alphanumeric_Supplement",
        astral: "\uD83C[\uDD00-\uDDFF]"
      }, {
        name: "InEnclosed_Alphanumerics",
        bmp: "\u2460-\u24FF"
      }, {
        name: "InEnclosed_CJK_Letters_and_Months",
        bmp: "\u3200-\u32FF"
      }, {
        name: "InEnclosed_Ideographic_Supplement",
        astral: "\uD83C[\uDE00-\uDEFF]"
      }, {
        name: "InEthiopic",
        bmp: "\u1200-\u137F"
      }, {
        name: "InEthiopic_Extended",
        bmp: "\u2D80-\u2DDF"
      }, {
        name: "InEthiopic_Extended_A",
        bmp: "\uAB00-\uAB2F"
      }, {
        name: "InEthiopic_Supplement",
        bmp: "\u1380-\u139F"
      }, {
        name: "InGeneral_Punctuation",
        bmp: "\u2000-\u206F"
      }, {
        name: "InGeometric_Shapes",
        bmp: "\u25A0-\u25FF"
      }, {
        name: "InGeometric_Shapes_Extended",
        astral: "\uD83D[\uDF80-\uDFFF]"
      }, {
        name: "InGeorgian",
        bmp: "\u10A0-\u10FF"
      }, {
        name: "InGeorgian_Supplement",
        bmp: "\u2D00-\u2D2F"
      }, {
        name: "InGlagolitic",
        bmp: "\u2C00-\u2C5F"
      }, {
        name: "InGlagolitic_Supplement",
        astral: "\uD838[\uDC00-\uDC2F]"
      }, {
        name: "InGothic",
        astral: "\uD800[\uDF30-\uDF4F]"
      }, {
        name: "InGrantha",
        astral: "\uD804[\uDF00-\uDF7F]"
      }, {
        name: "InGreek_Extended",
        bmp: "\u1F00-\u1FFF"
      }, {
        name: "InGreek_and_Coptic",
        bmp: "\u0370-\u03FF"
      }, {
        name: "InGujarati",
        bmp: "\u0A80-\u0AFF"
      }, {
        name: "InGurmukhi",
        bmp: "\u0A00-\u0A7F"
      }, {
        name: "InHalfwidth_and_Fullwidth_Forms",
        bmp: "\uFF00-\uFFEF"
      }, {
        name: "InHangul_Compatibility_Jamo",
        bmp: "\u3130-\u318F"
      }, {
        name: "InHangul_Jamo",
        bmp: "\u1100-\u11FF"
      }, {
        name: "InHangul_Jamo_Extended_A",
        bmp: "\uA960-\uA97F"
      }, {
        name: "InHangul_Jamo_Extended_B",
        bmp: "\uD7B0-\uD7FF"
      }, {
        name: "InHangul_Syllables",
        bmp: "\uAC00-\uD7AF"
      }, {
        name: "InHanunoo",
        bmp: "\u1720-\u173F"
      }, {
        name: "InHatran",
        astral: "\uD802[\uDCE0-\uDCFF]"
      }, {
        name: "InHebrew",
        bmp: "\u0590-\u05FF"
      }, {
        name: "InHigh_Private_Use_Surrogates",
        bmp: "\uDB80-\uDBFF"
      }, {
        name: "InHigh_Surrogates",
        bmp: "\uD800-\uDB7F"
      }, {
        name: "InHiragana",
        bmp: "\u3040-\u309F"
      }, {
        name: "InIPA_Extensions",
        bmp: "\u0250-\u02AF"
      }, {
        name: "InIdeographic_Description_Characters",
        bmp: "\u2FF0-\u2FFF"
      }, {
        name: "InIdeographic_Symbols_and_Punctuation",
        astral: "\uD81B[\uDFE0-\uDFFF]"
      }, {
        name: "InImperial_Aramaic",
        astral: "\uD802[\uDC40-\uDC5F]"
      }, {
        name: "InInscriptional_Pahlavi",
        astral: "\uD802[\uDF60-\uDF7F]"
      }, {
        name: "InInscriptional_Parthian",
        astral: "\uD802[\uDF40-\uDF5F]"
      }, {
        name: "InJavanese",
        bmp: "\uA980-\uA9DF"
      }, {
        name: "InKaithi",
        astral: "\uD804[\uDC80-\uDCCF]"
      }, {
        name: "InKana_Supplement",
        astral: "\uD82C[\uDC00-\uDCFF]"
      }, {
        name: "InKanbun",
        bmp: "\u3190-\u319F"
      }, {
        name: "InKangxi_Radicals",
        bmp: "\u2F00-\u2FDF"
      }, {
        name: "InKannada",
        bmp: "\u0C80-\u0CFF"
      }, {
        name: "InKatakana",
        bmp: "\u30A0-\u30FF"
      }, {
        name: "InKatakana_Phonetic_Extensions",
        bmp: "\u31F0-\u31FF"
      }, {
        name: "InKayah_Li",
        bmp: "\uA900-\uA92F"
      }, {
        name: "InKharoshthi",
        astral: "\uD802[\uDE00-\uDE5F]"
      }, {
        name: "InKhmer",
        bmp: "\u1780-\u17FF"
      }, {
        name: "InKhmer_Symbols",
        bmp: "\u19E0-\u19FF"
      }, {
        name: "InKhojki",
        astral: "\uD804[\uDE00-\uDE4F]"
      }, {
        name: "InKhudawadi",
        astral: "\uD804[\uDEB0-\uDEFF]"
      }, {
        name: "InLao",
        bmp: "\u0E80-\u0EFF"
      }, {
        name: "InLatin_Extended_Additional",
        bmp: "\u1E00-\u1EFF"
      }, {
        name: "InLatin_Extended_A",
        bmp: "\u0100-\u017F"
      }, {
        name: "InLatin_Extended_B",
        bmp: "\u0180-\u024F"
      }, {
        name: "InLatin_Extended_C",
        bmp: "\u2C60-\u2C7F"
      }, {
        name: "InLatin_Extended_D",
        bmp: "\uA720-\uA7FF"
      }, {
        name: "InLatin_Extended_E",
        bmp: "\uAB30-\uAB6F"
      }, {
        name: "InLatin_1_Supplement",
        bmp: "\x80-\xFF"
      }, {
        name: "InLepcha",
        bmp: "\u1C00-\u1C4F"
      }, {
        name: "InLetterlike_Symbols",
        bmp: "\u2100-\u214F"
      }, {
        name: "InLimbu",
        bmp: "\u1900-\u194F"
      }, {
        name: "InLinear_A",
        astral: "\uD801[\uDE00-\uDF7F]"
      }, {
        name: "InLinear_B_Ideograms",
        astral: "\uD800[\uDC80-\uDCFF]"
      }, {
        name: "InLinear_B_Syllabary",
        astral: "\uD800[\uDC00-\uDC7F]"
      }, {
        name: "InLisu",
        bmp: "\uA4D0-\uA4FF"
      }, {
        name: "InLow_Surrogates",
        bmp: "\uDC00-\uDFFF"
      }, {
        name: "InLycian",
        astral: "\uD800[\uDE80-\uDE9F]"
      }, {
        name: "InLydian",
        astral: "\uD802[\uDD20-\uDD3F]"
      }, {
        name: "InMahajani",
        astral: "\uD804[\uDD50-\uDD7F]"
      }, {
        name: "InMahjong_Tiles",
        astral: "\uD83C[\uDC00-\uDC2F]"
      }, {
        name: "InMalayalam",
        bmp: "\u0D00-\u0D7F"
      }, {
        name: "InMandaic",
        bmp: "\u0840-\u085F"
      }, {
        name: "InManichaean",
        astral: "\uD802[\uDEC0-\uDEFF]"
      }, {
        name: "InMarchen",
        astral: "\uD807[\uDC70-\uDCBF]"
      }, {
        name: "InMathematical_Alphanumeric_Symbols",
        astral: "\uD835[\uDC00-\uDFFF]"
      }, {
        name: "InMathematical_Operators",
        bmp: "\u2200-\u22FF"
      }, {
        name: "InMeetei_Mayek",
        bmp: "\uABC0-\uABFF"
      }, {
        name: "InMeetei_Mayek_Extensions",
        bmp: "\uAAE0-\uAAFF"
      }, {
        name: "InMende_Kikakui",
        astral: "\uD83A[\uDC00-\uDCDF]"
      }, {
        name: "InMeroitic_Cursive",
        astral: "\uD802[\uDDA0-\uDDFF]"
      }, {
        name: "InMeroitic_Hieroglyphs",
        astral: "\uD802[\uDD80-\uDD9F]"
      }, {
        name: "InMiao",
        astral: "\uD81B[\uDF00-\uDF9F]"
      }, {
        name: "InMiscellaneous_Mathematical_Symbols_A",
        bmp: "\u27C0-\u27EF"
      }, {
        name: "InMiscellaneous_Mathematical_Symbols_B",
        bmp: "\u2980-\u29FF"
      }, {
        name: "InMiscellaneous_Symbols",
        bmp: "\u2600-\u26FF"
      }, {
        name: "InMiscellaneous_Symbols_and_Arrows",
        bmp: "\u2B00-\u2BFF"
      }, {
        name: "InMiscellaneous_Symbols_and_Pictographs",
        astral: "\uD83C[\uDF00-\uDFFF]|\uD83D[\uDC00-\uDDFF]"
      }, {
        name: "InMiscellaneous_Technical",
        bmp: "\u2300-\u23FF"
      }, {
        name: "InModi",
        astral: "\uD805[\uDE00-\uDE5F]"
      }, {
        name: "InModifier_Tone_Letters",
        bmp: "\uA700-\uA71F"
      }, {
        name: "InMongolian",
        bmp: "\u1800-\u18AF"
      }, {
        name: "InMongolian_Supplement",
        astral: "\uD805[\uDE60-\uDE7F]"
      }, {
        name: "InMro",
        astral: "\uD81A[\uDE40-\uDE6F]"
      }, {
        name: "InMultani",
        astral: "\uD804[\uDE80-\uDEAF]"
      }, {
        name: "InMusical_Symbols",
        astral: "\uD834[\uDD00-\uDDFF]"
      }, {
        name: "InMyanmar",
        bmp: "\u1000-\u109F"
      }, {
        name: "InMyanmar_Extended_A",
        bmp: "\uAA60-\uAA7F"
      }, {
        name: "InMyanmar_Extended_B",
        bmp: "\uA9E0-\uA9FF"
      }, {
        name: "InNKo",
        bmp: "\u07C0-\u07FF"
      }, {
        name: "InNabataean",
        astral: "\uD802[\uDC80-\uDCAF]"
      }, {
        name: "InNew_Tai_Lue",
        bmp: "\u1980-\u19DF"
      }, {
        name: "InNewa",
        astral: "\uD805[\uDC00-\uDC7F]"
      }, {
        name: "InNumber_Forms",
        bmp: "\u2150-\u218F"
      }, {
        name: "InOgham",
        bmp: "\u1680-\u169F"
      }, {
        name: "InOl_Chiki",
        bmp: "\u1C50-\u1C7F"
      }, {
        name: "InOld_Hungarian",
        astral: "\uD803[\uDC80-\uDCFF]"
      }, {
        name: "InOld_Italic",
        astral: "\uD800[\uDF00-\uDF2F]"
      }, {
        name: "InOld_North_Arabian",
        astral: "\uD802[\uDE80-\uDE9F]"
      }, {
        name: "InOld_Permic",
        astral: "\uD800[\uDF50-\uDF7F]"
      }, {
        name: "InOld_Persian",
        astral: "\uD800[\uDFA0-\uDFDF]"
      }, {
        name: "InOld_South_Arabian",
        astral: "\uD802[\uDE60-\uDE7F]"
      }, {
        name: "InOld_Turkic",
        astral: "\uD803[\uDC00-\uDC4F]"
      }, {
        name: "InOptical_Character_Recognition",
        bmp: "\u2440-\u245F"
      }, {
        name: "InOriya",
        bmp: "\u0B00-\u0B7F"
      }, {
        name: "InOrnamental_Dingbats",
        astral: "\uD83D[\uDE50-\uDE7F]"
      }, {
        name: "InOsage",
        astral: "\uD801[\uDCB0-\uDCFF]"
      }, {
        name: "InOsmanya",
        astral: "\uD801[\uDC80-\uDCAF]"
      }, {
        name: "InPahawh_Hmong",
        astral: "\uD81A[\uDF00-\uDF8F]"
      }, {
        name: "InPalmyrene",
        astral: "\uD802[\uDC60-\uDC7F]"
      }, {
        name: "InPau_Cin_Hau",
        astral: "\uD806[\uDEC0-\uDEFF]"
      }, {
        name: "InPhags_pa",
        bmp: "\uA840-\uA87F"
      }, {
        name: "InPhaistos_Disc",
        astral: "\uD800[\uDDD0-\uDDFF]"
      }, {
        name: "InPhoenician",
        astral: "\uD802[\uDD00-\uDD1F]"
      }, {
        name: "InPhonetic_Extensions",
        bmp: "\u1D00-\u1D7F"
      }, {
        name: "InPhonetic_Extensions_Supplement",
        bmp: "\u1D80-\u1DBF"
      }, {
        name: "InPlaying_Cards",
        astral: "\uD83C[\uDCA0-\uDCFF]"
      }, {
        name: "InPrivate_Use_Area",
        bmp: "\uE000-\uF8FF"
      }, {
        name: "InPsalter_Pahlavi",
        astral: "\uD802[\uDF80-\uDFAF]"
      }, {
        name: "InRejang",
        bmp: "\uA930-\uA95F"
      }, {
        name: "InRumi_Numeral_Symbols",
        astral: "\uD803[\uDE60-\uDE7F]"
      }, {
        name: "InRunic",
        bmp: "\u16A0-\u16FF"
      }, {
        name: "InSamaritan",
        bmp: "\u0800-\u083F"
      }, {
        name: "InSaurashtra",
        bmp: "\uA880-\uA8DF"
      }, {
        name: "InSharada",
        astral: "\uD804[\uDD80-\uDDDF]"
      }, {
        name: "InShavian",
        astral: "\uD801[\uDC50-\uDC7F]"
      }, {
        name: "InShorthand_Format_Controls",
        astral: "\uD82F[\uDCA0-\uDCAF]"
      }, {
        name: "InSiddham",
        astral: "\uD805[\uDD80-\uDDFF]"
      }, {
        name: "InSinhala",
        bmp: "\u0D80-\u0DFF"
      }, {
        name: "InSinhala_Archaic_Numbers",
        astral: "\uD804[\uDDE0-\uDDFF]"
      }, {
        name: "InSmall_Form_Variants",
        bmp: "\uFE50-\uFE6F"
      }, {
        name: "InSora_Sompeng",
        astral: "\uD804[\uDCD0-\uDCFF]"
      }, {
        name: "InSpacing_Modifier_Letters",
        bmp: "\u02B0-\u02FF"
      }, {
        name: "InSpecials",
        bmp: "\uFFF0-\uFFFF"
      }, {
        name: "InSundanese",
        bmp: "\u1B80-\u1BBF"
      }, {
        name: "InSundanese_Supplement",
        bmp: "\u1CC0-\u1CCF"
      }, {
        name: "InSuperscripts_and_Subscripts",
        bmp: "\u2070-\u209F"
      }, {
        name: "InSupplemental_Arrows_A",
        bmp: "\u27F0-\u27FF"
      }, {
        name: "InSupplemental_Arrows_B",
        bmp: "\u2900-\u297F"
      }, {
        name: "InSupplemental_Arrows_C",
        astral: "\uD83E[\uDC00-\uDCFF]"
      }, {
        name: "InSupplemental_Mathematical_Operators",
        bmp: "\u2A00-\u2AFF"
      }, {
        name: "InSupplemental_Punctuation",
        bmp: "\u2E00-\u2E7F"
      }, {
        name: "InSupplemental_Symbols_and_Pictographs",
        astral: "\uD83E[\uDD00-\uDDFF]"
      }, {
        name: "InSupplementary_Private_Use_Area_A",
        astral: "[\uDB80-\uDBBF][\uDC00-\uDFFF]"
      }, {
        name: "InSupplementary_Private_Use_Area_B",
        astral: "[\uDBC0-\uDBFF][\uDC00-\uDFFF]"
      }, {
        name: "InSutton_SignWriting",
        astral: "\uD836[\uDC00-\uDEAF]"
      }, {
        name: "InSyloti_Nagri",
        bmp: "\uA800-\uA82F"
      }, {
        name: "InSyriac",
        bmp: "\u0700-\u074F"
      }, {
        name: "InTagalog",
        bmp: "\u1700-\u171F"
      }, {
        name: "InTagbanwa",
        bmp: "\u1760-\u177F"
      }, {
        name: "InTags",
        astral: "\uDB40[\uDC00-\uDC7F]"
      }, {
        name: "InTai_Le",
        bmp: "\u1950-\u197F"
      }, {
        name: "InTai_Tham",
        bmp: "\u1A20-\u1AAF"
      }, {
        name: "InTai_Viet",
        bmp: "\uAA80-\uAADF"
      }, {
        name: "InTai_Xuan_Jing_Symbols",
        astral: "\uD834[\uDF00-\uDF5F]"
      }, {
        name: "InTakri",
        astral: "\uD805[\uDE80-\uDECF]"
      }, {
        name: "InTamil",
        bmp: "\u0B80-\u0BFF"
      }, {
        name: "InTangut",
        astral: "[\uD81C-\uD821][\uDC00-\uDFFF]"
      }, {
        name: "InTangut_Components",
        astral: "\uD822[\uDC00-\uDEFF]"
      }, {
        name: "InTelugu",
        bmp: "\u0C00-\u0C7F"
      }, {
        name: "InThaana",
        bmp: "\u0780-\u07BF"
      }, {
        name: "InThai",
        bmp: "\u0E00-\u0E7F"
      }, {
        name: "InTibetan",
        bmp: "\u0F00-\u0FFF"
      }, {
        name: "InTifinagh",
        bmp: "\u2D30-\u2D7F"
      }, {
        name: "InTirhuta",
        astral: "\uD805[\uDC80-\uDCDF]"
      }, {
        name: "InTransport_and_Map_Symbols",
        astral: "\uD83D[\uDE80-\uDEFF]"
      }, {
        name: "InUgaritic",
        astral: "\uD800[\uDF80-\uDF9F]"
      }, {
        name: "InUnified_Canadian_Aboriginal_Syllabics",
        bmp: "\u1400-\u167F"
      }, {
        name: "InUnified_Canadian_Aboriginal_Syllabics_Extended",
        bmp: "\u18B0-\u18FF"
      }, {
        name: "InVai",
        bmp: "\uA500-\uA63F"
      }, {
        name: "InVariation_Selectors",
        bmp: "\uFE00-\uFE0F"
      }, {
        name: "InVariation_Selectors_Supplement",
        astral: "\uDB40[\uDD00-\uDDEF]"
      }, {
        name: "InVedic_Extensions",
        bmp: "\u1CD0-\u1CFF"
      }, {
        name: "InVertical_Forms",
        bmp: "\uFE10-\uFE1F"
      }, {
        name: "InWarang_Citi",
        astral: "\uD806[\uDCA0-\uDCFF]"
      }, {
        name: "InYi_Radicals",
        bmp: "\uA490-\uA4CF"
      }, {
        name: "InYi_Syllables",
        bmp: "\uA000-\uA48F"
      }, {
        name: "InYijing_Hexagram_Symbols",
        bmp: "\u4DC0-\u4DFF"
      }]);
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/xregexp/lib/addons/unicode-categories.js
var require_unicode_categories = __commonJS({
  "node_modules/xregexp/lib/addons/unicode-categories.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(XRegExp) {
      if (!XRegExp.addUnicodeData) {
        throw new ReferenceError("Unicode Base must be loaded before Unicode Categories");
      }
      XRegExp.addUnicodeData([{
        name: "C",
        alias: "Other",
        isBmpLast: true,
        bmp: "\0-\x7F-\x9F\xAD\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u0560\u0588\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u0605\u061C\u061D\u06DD\u070E\u070F\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08B5\u08BE-\u08D3\u08E2\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0AFA-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D00\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D50-\u0D53\u0D64\u0D65\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180E\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ABF-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C89-\u1CBF\u1CC8-\u1CCF\u1CF7\u1CFA-\u1CFF\u1DF6-\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u200B-\u200F\u202A-\u202E\u2060-\u206F\u2072\u2073\u208F\u209D-\u209F\u20BF-\u20CF\u20F1-\u20FF\u218C-\u218F\u23FF\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2BEB\u2BF0-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E45-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FD6-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7AF\uA7B8-\uA7F6\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C6-\uA8CD\uA8DA-\uA8DF\uA8FE\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB66-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD-\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF",
        astral: "\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2F\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE34-\uDE37\uDE3B-\uDE3E\uDE48-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD00-\uDE5F\uDE7F-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCBD\uDCC2-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD44-\uDD4F\uDD77-\uDD7F\uDDCE\uDDCF\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF3B\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5A\uDC5C\uDC5E-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEB8-\uDEBF\uDECA-\uDEFF\uDF1A-\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD806[\uDC00-\uDC9F\uDCF3-\uDCFE\uDD00-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD823-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83F\uD874-\uD87D\uD87F-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDEFF\uDF45-\uDF4F\uDF7F-\uDF8E\uDFA0-\uDFDF\uDFE1-\uDFFF]|\uD821[\uDFED-\uDFFF]|\uD822[\uDEF3-\uDFFF]|\uD82C[\uDC02-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA0-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDD73-\uDD7A\uDDE9-\uDDFF\uDE46-\uDEFF\uDF57-\uDF5F\uDF72-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4B-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD6F\uDDAD-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF]|\uD83D[\uDED3-\uDEDF\uDEED-\uDEEF\uDEF7-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDD0F\uDD1F\uDD28-\uDD2F\uDD31\uDD32\uDD3F\uDD4C-\uDD4F\uDD5F-\uDD7F\uDD92-\uDDBF\uDDC1-\uDFFF]|\uD869[\uDED7-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]"
      }, {
        name: "Cc",
        alias: "Control",
        bmp: "\0-\x7F-\x9F"
      }, {
        name: "Cf",
        alias: "Format",
        bmp: "\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB",
        astral: "\u{110BD}|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]"
      }, {
        name: "Cn",
        alias: "Unassigned",
        bmp: "\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u0560\u0588\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u05FF\u061D\u070E\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08B5\u08BE-\u08D3\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0AFA-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D00\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D50-\u0D53\u0D64\u0D65\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ABF-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C89-\u1CBF\u1CC8-\u1CCF\u1CF7\u1CFA-\u1CFF\u1DF6-\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u2065\u2072\u2073\u208F\u209D-\u209F\u20BF-\u20CF\u20F1-\u20FF\u218C-\u218F\u23FF\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2BEB\u2BF0-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E45-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FD6-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7AF\uA7B8-\uA7F6\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C6-\uA8CD\uA8DA-\uA8DF\uA8FE\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB66-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD\uFEFE\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFF8\uFFFE\uFFFF",
        astral: "\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2F\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE34-\uDE37\uDE3B-\uDE3E\uDE48-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD00-\uDE5F\uDE7F-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCC2-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD44-\uDD4F\uDD77-\uDD7F\uDDCE\uDDCF\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF3B\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5A\uDC5C\uDC5E-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEB8-\uDEBF\uDECA-\uDEFF\uDF1A-\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD806[\uDC00-\uDC9F\uDCF3-\uDCFE\uDD00-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD823-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83F\uD874-\uD87D\uD87F-\uDB3F\uDB41-\uDB7F][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDEFF\uDF45-\uDF4F\uDF7F-\uDF8E\uDFA0-\uDFDF\uDFE1-\uDFFF]|\uD821[\uDFED-\uDFFF]|\uD822[\uDEF3-\uDFFF]|\uD82C[\uDC02-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA4-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDDE9-\uDDFF\uDE46-\uDEFF\uDF57-\uDF5F\uDF72-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4B-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD6F\uDDAD-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF]|\uD83D[\uDED3-\uDEDF\uDEED-\uDEEF\uDEF7-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDD0F\uDD1F\uDD28-\uDD2F\uDD31\uDD32\uDD3F\uDD4C-\uDD4F\uDD5F-\uDD7F\uDD92-\uDDBF\uDDC1-\uDFFF]|\uD869[\uDED7-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uDB40[\uDC00\uDC02-\uDC1F\uDC80-\uDCFF\uDDF0-\uDFFF]|[\uDBBF\uDBFF][\uDFFE\uDFFF]"
      }, {
        name: "Co",
        alias: "Private_Use",
        bmp: "\uE000-\uF8FF",
        astral: "[\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uDBBF\uDBFF][\uDC00-\uDFFD]"
      }, {
        name: "Cs",
        alias: "Surrogate",
        bmp: "\uD800-\uDFFF"
      }, {
        name: "L",
        alias: "Letter",
        bmp: "A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
        astral: "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]"
      }, {
        name: "Ll",
        alias: "Lowercase_Letter",
        bmp: "a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A",
        astral: "\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]"
      }, {
        name: "Lm",
        alias: "Modifier_Letter",
        bmp: "\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F",
        astral: "\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]"
      }, {
        name: "Lo",
        alias: "Other_Letter",
        bmp: "\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
        astral: "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]"
      }, {
        name: "Lt",
        alias: "Titlecase_Letter",
        bmp: "\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC"
      }, {
        name: "Lu",
        alias: "Uppercase_Letter",
        bmp: "A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A",
        astral: "\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]"
      }, {
        name: "M",
        alias: "Mark",
        bmp: "\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F",
        astral: "\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDCA-\uDDCC\uDE2C-\uDE37\uDE3E\uDEDF-\uDEEA\uDF00-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC35-\uDC46\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDEAB-\uDEB7\uDF1D-\uDF2B]|\uD807[\uDC2F-\uDC36\uDC38-\uDC3F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]"
      }, {
        name: "Mc",
        alias: "Spacing_Mark",
        bmp: "\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BE-\u09C0\u09C7\u09C8\u09CB\u09CC\u09D7\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD7\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0-\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0D02\u0D03\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D57\u0D82\u0D83\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DF2\u0DF3\u0F3E\u0F3F\u0F7F\u102B\u102C\u1031\u1038\u103B\u103C\u1056\u1057\u1062-\u1064\u1067-\u106D\u1083\u1084\u1087-\u108C\u108F\u109A-\u109C\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1B04\u1B35\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF2\u1CF3\u302E\u302F\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BD-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAA7B\uAA7D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC",
        astral: "\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3E\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB0-\uDCB2\uDCB9\uDCBB-\uDCBE\uDCC1\uDDAF-\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF20\uDF21\uDF26]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4]|\uD81B[\uDF51-\uDF7E]|\uD834[\uDD65\uDD66\uDD6D-\uDD72]"
      }, {
        name: "Me",
        alias: "Enclosing_Mark",
        bmp: "\u0488\u0489\u1ABE\u20DD-\u20E0\u20E2-\u20E4\uA670-\uA672"
      }, {
        name: "Mn",
        alias: "Nonspacing_Mark",
        bmp: "\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D01\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F",
        astral: "\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDCA-\uDDCC\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]"
      }, {
        name: "N",
        alias: "Number",
        bmp: "0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D58-\u0D5E\u0D66-\u0D78\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19",
        astral: "\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE47\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2]|\uD807[\uDC50-\uDC6C]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD834[\uDF60-\uDF71]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83C[\uDD00-\uDD0C]"
      }, {
        name: "Nd",
        alias: "Decimal_Number",
        bmp: "0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19",
        astral: "\uD801[\uDCA0-\uDCA9]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9]|\uD807[\uDC50-\uDC59]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDD50-\uDD59]"
      }, {
        name: "Nl",
        alias: "Letter_Number",
        bmp: "\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF",
        astral: "\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]|\uD809[\uDC00-\uDC6E]"
      }, {
        name: "No",
        alias: "Other_Number",
        bmp: "\xB2\xB3\xB9\xBC-\xBE\u09F4-\u09F9\u0B72-\u0B77\u0BF0-\u0BF2\u0C78-\u0C7E\u0D58-\u0D5E\u0D70-\u0D78\u0F2A-\u0F33\u1369-\u137C\u17F0-\u17F9\u19DA\u2070\u2074-\u2079\u2080-\u2089\u2150-\u215F\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA830-\uA835",
        astral: "\uD800[\uDD07-\uDD33\uDD75-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE47\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E]|\uD804[\uDC52-\uDC65\uDDE1-\uDDF4]|\uD805[\uDF3A\uDF3B]|\uD806[\uDCEA-\uDCF2]|\uD807[\uDC5A-\uDC6C]|\uD81A[\uDF5B-\uDF61]|\uD834[\uDF60-\uDF71]|\uD83A[\uDCC7-\uDCCF]|\uD83C[\uDD00-\uDD0C]"
      }, {
        name: "P",
        alias: "Punctuation",
        bmp: "!-#%-\\x2A,-/:;\\x3F@\\x5B-\\x5D_\\x7B}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65",
        astral: "\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\u{1056F}|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\u{1BC9F}|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]"
      }, {
        name: "Pc",
        alias: "Connector_Punctuation",
        bmp: "_\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F"
      }, {
        name: "Pd",
        alias: "Dash_Punctuation",
        bmp: "\\x2D\u058A\u05BE\u1400\u1806\u2010-\u2015\u2E17\u2E1A\u2E3A\u2E3B\u2E40\u301C\u3030\u30A0\uFE31\uFE32\uFE58\uFE63\uFF0D"
      }, {
        name: "Pe",
        alias: "Close_Punctuation",
        bmp: "\\x29\\x5D}\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u2309\u230B\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3E\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63"
      }, {
        name: "Pf",
        alias: "Final_Punctuation",
        bmp: "\xBB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21"
      }, {
        name: "Pi",
        alias: "Initial_Punctuation",
        bmp: "\xAB\u2018\u201B\u201C\u201F\u2039\u2E02\u2E04\u2E09\u2E0C\u2E1C\u2E20"
      }, {
        name: "Po",
        alias: "Other_Punctuation",
        bmp: "!-#%-'\\x2A,\\x2E/:;\\x3F@\\x5C\xA1\xA7\xB6\xB7\xBF\u037E\u0387\u055A-\u055F\u0589\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u166D\u166E\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u1805\u1807-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2016\u2017\u2020-\u2027\u2030-\u2038\u203B-\u203E\u2041-\u2043\u2047-\u2051\u2053\u2055-\u205E\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E06-\u2E08\u2E0B\u2E0E-\u2E16\u2E18\u2E19\u2E1B\u2E1E\u2E1F\u2E2A-\u2E2E\u2E30-\u2E39\u2E3C-\u2E3F\u2E41\u2E43\u2E44\u3001-\u3003\u303D\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFE10-\uFE16\uFE19\uFE30\uFE45\uFE46\uFE49-\uFE4C\uFE50-\uFE52\uFE54-\uFE57\uFE5F-\uFE61\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF07\uFF0A\uFF0C\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3C\uFF61\uFF64\uFF65",
        astral: "\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\u{1056F}|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\u{1BC9F}|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]"
      }, {
        name: "Ps",
        alias: "Open_Punctuation",
        bmp: "\\x28\\x5B\\x7B\u0F3A\u0F3C\u169B\u201A\u201E\u2045\u207D\u208D\u2308\u230A\u2329\u2768\u276A\u276C\u276E\u2770\u2772\u2774\u27C5\u27E6\u27E8\u27EA\u27EC\u27EE\u2983\u2985\u2987\u2989\u298B\u298D\u298F\u2991\u2993\u2995\u2997\u29D8\u29DA\u29FC\u2E22\u2E24\u2E26\u2E28\u2E42\u3008\u300A\u300C\u300E\u3010\u3014\u3016\u3018\u301A\u301D\uFD3F\uFE17\uFE35\uFE37\uFE39\uFE3B\uFE3D\uFE3F\uFE41\uFE43\uFE47\uFE59\uFE5B\uFE5D\uFF08\uFF3B\uFF5B\uFF5F\uFF62"
      }, {
        name: "S",
        alias: "Symbol",
        bmp: "\\x24\\x2B<->\\x5E`\\x7C~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20BE\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u23FE\u2400-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u32FE\u3300-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uFB29\uFBB2-\uFBC1\uFDFC\uFDFD\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD",
        astral: "\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\u{1173F}|\uD81A[\uDF3C-\uDF3F\uDF45]|\u{1BC9C}|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD83B[\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDDAC\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED2\uDEE0-\uDEEC\uDEF0-\uDEF6\uDF00-\uDF73\uDF80-\uDFD4]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD1E\uDD20-\uDD27\uDD30\uDD33-\uDD3E\uDD40-\uDD4B\uDD50-\uDD5E\uDD80-\uDD91\uDDC0]"
      }, {
        name: "Sc",
        alias: "Currency_Symbol",
        bmp: "\\x24\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20BE\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6"
      }, {
        name: "Sk",
        alias: "Modifier_Symbol",
        bmp: "\\x5E`\xA8\xAF\xB4\xB8\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u309B\u309C\uA700-\uA716\uA720\uA721\uA789\uA78A\uAB5B\uFBB2-\uFBC1\uFF3E\uFF40\uFFE3",
        astral: "\uD83C[\uDFFB-\uDFFF]"
      }, {
        name: "Sm",
        alias: "Math_Symbol",
        bmp: "\\x2B<->\\x7C~\xAC\xB1\xD7\xF7\u03F6\u0606-\u0608\u2044\u2052\u207A-\u207C\u208A-\u208C\u2118\u2140-\u2144\u214B\u2190-\u2194\u219A\u219B\u21A0\u21A3\u21A6\u21AE\u21CE\u21CF\u21D2\u21D4\u21F4-\u22FF\u2320\u2321\u237C\u239B-\u23B3\u23DC-\u23E1\u25B7\u25C1\u25F8-\u25FF\u266F\u27C0-\u27C4\u27C7-\u27E5\u27F0-\u27FF\u2900-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2AFF\u2B30-\u2B44\u2B47-\u2B4C\uFB29\uFE62\uFE64-\uFE66\uFF0B\uFF1C-\uFF1E\uFF5C\uFF5E\uFFE2\uFFE9-\uFFEC",
        astral: "\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD83B[\uDEF0\uDEF1]"
      }, {
        name: "So",
        alias: "Other_Symbol",
        bmp: "\xA6\xA9\xAE\xB0\u0482\u058D\u058E\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u09FA\u0B70\u0BF3-\u0BF8\u0BFA\u0C7F\u0D4F\u0D79\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116\u2117\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u214A\u214C\u214D\u214F\u218A\u218B\u2195-\u2199\u219C-\u219F\u21A1\u21A2\u21A4\u21A5\u21A7-\u21AD\u21AF-\u21CD\u21D0\u21D1\u21D3\u21D5-\u21F3\u2300-\u2307\u230C-\u231F\u2322-\u2328\u232B-\u237B\u237D-\u239A\u23B4-\u23DB\u23E2-\u23FE\u2400-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u25B6\u25B8-\u25C0\u25C2-\u25F7\u2600-\u266E\u2670-\u2767\u2794-\u27BF\u2800-\u28FF\u2B00-\u2B2F\u2B45\u2B46\u2B4D-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u32FE\u3300-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA828-\uA82B\uA836\uA837\uA839\uAA77-\uAA79\uFDFD\uFFE4\uFFE8\uFFED\uFFEE\uFFFC\uFFFD",
        astral: "\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\u{1173F}|\uD81A[\uDF3C-\uDF3F\uDF45]|\u{1BC9C}|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDDAC\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFA]|\uD83D[\uDC00-\uDED2\uDEE0-\uDEEC\uDEF0-\uDEF6\uDF00-\uDF73\uDF80-\uDFD4]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD1E\uDD20-\uDD27\uDD30\uDD33-\uDD3E\uDD40-\uDD4B\uDD50-\uDD5E\uDD80-\uDD91\uDDC0]"
      }, {
        name: "Z",
        alias: "Separator",
        bmp: " \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000"
      }, {
        name: "Zl",
        alias: "Line_Separator",
        bmp: "\u2028"
      }, {
        name: "Zp",
        alias: "Paragraph_Separator",
        bmp: "\u2029"
      }, {
        name: "Zs",
        alias: "Space_Separator",
        bmp: " \xA0\u1680\u2000-\u200A\u202F\u205F\u3000"
      }]);
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/xregexp/lib/addons/unicode-properties.js
var require_unicode_properties = __commonJS({
  "node_modules/xregexp/lib/addons/unicode-properties.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(XRegExp) {
      if (!XRegExp.addUnicodeData) {
        throw new ReferenceError("Unicode Base must be loaded before Unicode Properties");
      }
      var unicodeData = [{
        name: "ASCII",
        bmp: "\0-\x7F"
      }, {
        name: "Alphabetic",
        bmp: "A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0345\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05B0-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0657\u0659-\u065F\u066E-\u06D3\u06D5-\u06DC\u06E1-\u06E8\u06ED-\u06EF\u06FA-\u06FC\u06FF\u0710-\u073F\u074D-\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0817\u081A-\u082C\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08DF\u08E3-\u08E9\u08F0-\u093B\u093D-\u094C\u094E-\u0950\u0955-\u0963\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C4\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09F0\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A42\u0A47\u0A48\u0A4B\u0A4C\u0A51\u0A59-\u0A5C\u0A5E\u0A70-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC5\u0AC7-\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0-\u0AE3\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D-\u0B44\u0B47\u0B48\u0B4B\u0B4C\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4C\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCC\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E46\u0E4D\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0ECD\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F71-\u0F81\u0F88-\u0F97\u0F99-\u0FBC\u1000-\u1036\u1038\u103B-\u103F\u1050-\u1062\u1065-\u1068\u106E-\u1086\u108E\u109C\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1713\u1720-\u1733\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17B3\u17B6-\u17C8\u17D7\u17DC\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u1938\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A1B\u1A20-\u1A5E\u1A61-\u1A74\u1AA7\u1B00-\u1B33\u1B35-\u1B43\u1B45-\u1B4B\u1B80-\u1BA9\u1BAC-\u1BAF\u1BBA-\u1BE5\u1BE7-\u1BF1\u1C00-\u1C35\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1D00-\u1DBF\u1DE7-\u1DF4\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u24B6-\u24E9\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA674-\uA67B\uA67F-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA827\uA840-\uA873\uA880-\uA8C3\uA8C5\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA92A\uA930-\uA952\uA960-\uA97C\uA980-\uA9B2\uA9B4-\uA9BF\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA60-\uAA76\uAA7A\uAA7E-\uAABE\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
        astral: "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC45\uDC82-\uDCB8\uDCD0-\uDCE8\uDD00-\uDD32\uDD50-\uDD72\uDD76\uDD80-\uDDBF\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE34\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEE8\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D-\uDF44\uDF47\uDF48\uDF4B\uDF4C\uDF50\uDF57\uDF5D-\uDF63]|\uD805[\uDC00-\uDC41\uDC43-\uDC45\uDC47-\uDC4A\uDC80-\uDCC1\uDCC4\uDCC5\uDCC7\uDD80-\uDDB5\uDDB8-\uDDBE\uDDD8-\uDDDD\uDE00-\uDE3E\uDE40\uDE44\uDE80-\uDEB5\uDF00-\uDF19\uDF1D-\uDF2A]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC3E\uDC40\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF36\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9E]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD47]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]"
      }, {
        name: "Any",
        isBmpLast: true,
        bmp: "\0-\uFFFF",
        astral: "[\uD800-\uDBFF][\uDC00-\uDFFF]"
      }, {
        name: "Default_Ignorable_Code_Point",
        bmp: "\xAD\u034F\u061C\u115F\u1160\u17B4\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8",
        astral: "\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|[\uDB40-\uDB43][\uDC00-\uDFFF]"
      }, {
        name: "Lowercase",
        bmp: "a-z\xAA\xB5\xBA\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02B8\u02C0\u02C1\u02E0-\u02E4\u0345\u0371\u0373\u0377\u037A-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1DBF\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u2071\u207F\u2090-\u209C\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2170-\u217F\u2184\u24D0-\u24E9\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7D\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B-\uA69D\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7F8-\uA7FA\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A",
        astral: "\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]"
      }, {
        name: "Noncharacter_Code_Point",
        bmp: "\uFDD0-\uFDEF\uFFFE\uFFFF",
        astral: "[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]"
      }, {
        name: "Uppercase",
        bmp: "A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2160-\u216F\u2183\u24B6-\u24CF\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A",
        astral: "\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]"
      }, {
        name: "White_Space",
        bmp: "	-\r \x85\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000"
      }];
      unicodeData.push({
        name: "Assigned",
        // Since this is defined as the inverse of Unicode category Cn (Unassigned), the Unicode
        // Categories addon is required to use this property
        inverseOf: "Cn"
      });
      XRegExp.addUnicodeData(unicodeData);
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/xregexp/lib/addons/unicode-scripts.js
var require_unicode_scripts = __commonJS({
  "node_modules/xregexp/lib/addons/unicode-scripts.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(XRegExp) {
      if (!XRegExp.addUnicodeData) {
        throw new ReferenceError("Unicode Base must be loaded before Unicode Scripts");
      }
      XRegExp.addUnicodeData([{
        name: "Adlam",
        astral: "\uD83A[\uDD00-\uDD4A\uDD50-\uDD59\uDD5E\uDD5F]"
      }, {
        name: "Ahom",
        astral: "\uD805[\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF3F]"
      }, {
        name: "Anatolian_Hieroglyphs",
        astral: "\uD811[\uDC00-\uDE46]"
      }, {
        name: "Arabic",
        bmp: "\u0600-\u0604\u0606-\u060B\u060D-\u061A\u061E\u0620-\u063F\u0641-\u064A\u0656-\u066F\u0671-\u06DC\u06DE-\u06FF\u0750-\u077F\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u08FF\uFB50-\uFBC1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFD\uFE70-\uFE74\uFE76-\uFEFC",
        astral: "\uD803[\uDE60-\uDE7E]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB\uDEF0\uDEF1]"
      }, {
        name: "Armenian",
        bmp: "\u0531-\u0556\u0559-\u055F\u0561-\u0587\u058A\u058D-\u058F\uFB13-\uFB17"
      }, {
        name: "Avestan",
        astral: "\uD802[\uDF00-\uDF35\uDF39-\uDF3F]"
      }, {
        name: "Balinese",
        bmp: "\u1B00-\u1B4B\u1B50-\u1B7C"
      }, {
        name: "Bamum",
        bmp: "\uA6A0-\uA6F7",
        astral: "\uD81A[\uDC00-\uDE38]"
      }, {
        name: "Bassa_Vah",
        astral: "\uD81A[\uDED0-\uDEED\uDEF0-\uDEF5]"
      }, {
        name: "Batak",
        bmp: "\u1BC0-\u1BF3\u1BFC-\u1BFF"
      }, {
        name: "Bengali",
        bmp: "\u0980-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FB"
      }, {
        name: "Bhaiksuki",
        astral: "\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC45\uDC50-\uDC6C]"
      }, {
        name: "Bopomofo",
        bmp: "\u02EA\u02EB\u3105-\u312D\u31A0-\u31BA"
      }, {
        name: "Brahmi",
        astral: "\uD804[\uDC00-\uDC4D\uDC52-\uDC6F\uDC7F]"
      }, {
        name: "Braille",
        bmp: "\u2800-\u28FF"
      }, {
        name: "Buginese",
        bmp: "\u1A00-\u1A1B\u1A1E\u1A1F"
      }, {
        name: "Buhid",
        bmp: "\u1740-\u1753"
      }, {
        name: "Canadian_Aboriginal",
        bmp: "\u1400-\u167F\u18B0-\u18F5"
      }, {
        name: "Carian",
        astral: "\uD800[\uDEA0-\uDED0]"
      }, {
        name: "Caucasian_Albanian",
        astral: "\uD801[\uDD30-\uDD63\uDD6F]"
      }, {
        name: "Chakma",
        astral: "\uD804[\uDD00-\uDD34\uDD36-\uDD43]"
      }, {
        name: "Cham",
        bmp: "\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAA5F"
      }, {
        name: "Cherokee",
        bmp: "\u13A0-\u13F5\u13F8-\u13FD\uAB70-\uABBF"
      }, {
        name: "Common",
        bmp: "\0-@\\x5B-`\\x7B-\xA9\xAB-\xB9\xBB-\xBF\xD7\xF7\u02B9-\u02DF\u02E5-\u02E9\u02EC-\u02FF\u0374\u037E\u0385\u0387\u0589\u0605\u060C\u061B\u061C\u061F\u0640\u06DD\u08E2\u0964\u0965\u0E3F\u0FD5-\u0FD8\u10FB\u16EB-\u16ED\u1735\u1736\u1802\u1803\u1805\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u2000-\u200B\u200E-\u2064\u2066-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20BE\u2100-\u2125\u2127-\u2129\u212C-\u2131\u2133-\u214D\u214F-\u215F\u2189-\u218B\u2190-\u23FE\u2400-\u2426\u2440-\u244A\u2460-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2E00-\u2E44\u2FF0-\u2FFB\u3000-\u3004\u3006\u3008-\u3020\u3030-\u3037\u303C-\u303F\u309B\u309C\u30A0\u30FB\u30FC\u3190-\u319F\u31C0-\u31E3\u3220-\u325F\u327F-\u32CF\u3358-\u33FF\u4DC0-\u4DFF\uA700-\uA721\uA788-\uA78A\uA830-\uA839\uA92E\uA9CF\uAB5B\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFF70\uFF9E\uFF9F\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD",
        astral: "\uD800[\uDD00-\uDD02\uDD07-\uDD33\uDD37-\uDD3F\uDD90-\uDD9B\uDDD0-\uDDFC\uDEE1-\uDEFB]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD66\uDD6A-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDF00-\uDF56\uDF60-\uDF71]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDFCB\uDFCE-\uDFFF]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD00-\uDD0C\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDDAC\uDDE6-\uDDFF\uDE01\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED2\uDEE0-\uDEEC\uDEF0-\uDEF6\uDF00-\uDF73\uDF80-\uDFD4]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD1E\uDD20-\uDD27\uDD30\uDD33-\uDD3E\uDD40-\uDD4B\uDD50-\uDD5E\uDD80-\uDD91\uDDC0]|\uDB40[\uDC01\uDC20-\uDC7F]"
      }, {
        name: "Coptic",
        bmp: "\u03E2-\u03EF\u2C80-\u2CF3\u2CF9-\u2CFF"
      }, {
        name: "Cuneiform",
        astral: "\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC70-\uDC74\uDC80-\uDD43]"
      }, {
        name: "Cypriot",
        astral: "\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F]"
      }, {
        name: "Cyrillic",
        bmp: "\u0400-\u0484\u0487-\u052F\u1C80-\u1C88\u1D2B\u1D78\u2DE0-\u2DFF\uA640-\uA69F\uFE2E\uFE2F"
      }, {
        name: "Deseret",
        astral: "\uD801[\uDC00-\uDC4F]"
      }, {
        name: "Devanagari",
        bmp: "\u0900-\u0950\u0953-\u0963\u0966-\u097F\uA8E0-\uA8FD"
      }, {
        name: "Duployan",
        astral: "\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9C-\uDC9F]"
      }, {
        name: "Egyptian_Hieroglyphs",
        astral: "\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]"
      }, {
        name: "Elbasan",
        astral: "\uD801[\uDD00-\uDD27]"
      }, {
        name: "Ethiopic",
        bmp: "\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E"
      }, {
        name: "Georgian",
        bmp: "\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u10FF\u2D00-\u2D25\u2D27\u2D2D"
      }, {
        name: "Glagolitic",
        bmp: "\u2C00-\u2C2E\u2C30-\u2C5E",
        astral: "\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]"
      }, {
        name: "Gothic",
        astral: "\uD800[\uDF30-\uDF4A]"
      }, {
        name: "Grantha",
        astral: "\uD804[\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]"
      }, {
        name: "Greek",
        bmp: "\u0370-\u0373\u0375-\u0377\u037A-\u037D\u037F\u0384\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03E1\u03F0-\u03FF\u1D26-\u1D2A\u1D5D-\u1D61\u1D66-\u1D6A\u1DBF\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u2126\uAB65",
        astral: "\uD800[\uDD40-\uDD8E\uDDA0]|\uD834[\uDE00-\uDE45]"
      }, {
        name: "Gujarati",
        bmp: "\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9"
      }, {
        name: "Gurmukhi",
        bmp: "\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75"
      }, {
        name: "Han",
        bmp: "\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u3005\u3007\u3021-\u3029\u3038-\u303B\u3400-\u4DB5\u4E00-\u9FD5\uF900-\uFA6D\uFA70-\uFAD9",
        astral: "[\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]"
      }, {
        name: "Hangul",
        bmp: "\u1100-\u11FF\u302E\u302F\u3131-\u318E\u3200-\u321E\u3260-\u327E\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC"
      }, {
        name: "Hanunoo",
        bmp: "\u1720-\u1734"
      }, {
        name: "Hatran",
        astral: "\uD802[\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDCFF]"
      }, {
        name: "Hebrew",
        bmp: "\u0591-\u05C7\u05D0-\u05EA\u05F0-\u05F4\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFB4F"
      }, {
        name: "Hiragana",
        bmp: "\u3041-\u3096\u309D-\u309F",
        astral: "\u{1B001}|\u{1F200}"
      }, {
        name: "Imperial_Aramaic",
        astral: "\uD802[\uDC40-\uDC55\uDC57-\uDC5F]"
      }, {
        name: "Inherited",
        bmp: "\u0300-\u036F\u0485\u0486\u064B-\u0655\u0670\u0951\u0952\u1AB0-\u1ABE\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u200C\u200D\u20D0-\u20F0\u302A-\u302D\u3099\u309A\uFE00-\uFE0F\uFE20-\uFE2D",
        astral: "\uD800[\uDDFD\uDEE0]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD]|\uDB40[\uDD00-\uDDEF]"
      }, {
        name: "Inscriptional_Pahlavi",
        astral: "\uD802[\uDF60-\uDF72\uDF78-\uDF7F]"
      }, {
        name: "Inscriptional_Parthian",
        astral: "\uD802[\uDF40-\uDF55\uDF58-\uDF5F]"
      }, {
        name: "Javanese",
        bmp: "\uA980-\uA9CD\uA9D0-\uA9D9\uA9DE\uA9DF"
      }, {
        name: "Kaithi",
        astral: "\uD804[\uDC80-\uDCC1]"
      }, {
        name: "Kannada",
        bmp: "\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2"
      }, {
        name: "Katakana",
        bmp: "\u30A1-\u30FA\u30FD-\u30FF\u31F0-\u31FF\u32D0-\u32FE\u3300-\u3357\uFF66-\uFF6F\uFF71-\uFF9D",
        astral: "\u{1B000}"
      }, {
        name: "Kayah_Li",
        bmp: "\uA900-\uA92D\uA92F"
      }, {
        name: "Kharoshthi",
        astral: "\uD802[\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F-\uDE47\uDE50-\uDE58]"
      }, {
        name: "Khmer",
        bmp: "\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u19E0-\u19FF"
      }, {
        name: "Khojki",
        astral: "\uD804[\uDE00-\uDE11\uDE13-\uDE3E]"
      }, {
        name: "Khudawadi",
        astral: "\uD804[\uDEB0-\uDEEA\uDEF0-\uDEF9]"
      }, {
        name: "Lao",
        bmp: "\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF"
      }, {
        name: "Latin",
        bmp: "A-Za-z\xAA\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02E0-\u02E4\u1D00-\u1D25\u1D2C-\u1D5C\u1D62-\u1D65\u1D6B-\u1D77\u1D79-\u1DBE\u1E00-\u1EFF\u2071\u207F\u2090-\u209C\u212A\u212B\u2132\u214E\u2160-\u2188\u2C60-\u2C7F\uA722-\uA787\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA7FF\uAB30-\uAB5A\uAB5C-\uAB64\uFB00-\uFB06\uFF21-\uFF3A\uFF41-\uFF5A"
      }, {
        name: "Lepcha",
        bmp: "\u1C00-\u1C37\u1C3B-\u1C49\u1C4D-\u1C4F"
      }, {
        name: "Limbu",
        bmp: "\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u194F"
      }, {
        name: "Linear_A",
        astral: "\uD801[\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]"
      }, {
        name: "Linear_B",
        astral: "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA]"
      }, {
        name: "Lisu",
        bmp: "\uA4D0-\uA4FF"
      }, {
        name: "Lycian",
        astral: "\uD800[\uDE80-\uDE9C]"
      }, {
        name: "Lydian",
        astral: "\uD802[\uDD20-\uDD39\uDD3F]"
      }, {
        name: "Mahajani",
        astral: "\uD804[\uDD50-\uDD76]"
      }, {
        name: "Malayalam",
        bmp: "\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4F\u0D54-\u0D63\u0D66-\u0D7F"
      }, {
        name: "Mandaic",
        bmp: "\u0840-\u085B\u085E"
      }, {
        name: "Manichaean",
        astral: "\uD802[\uDEC0-\uDEE6\uDEEB-\uDEF6]"
      }, {
        name: "Marchen",
        astral: "\uD807[\uDC70-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]"
      }, {
        name: "Meetei_Mayek",
        bmp: "\uAAE0-\uAAF6\uABC0-\uABED\uABF0-\uABF9"
      }, {
        name: "Mende_Kikakui",
        astral: "\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6]"
      }, {
        name: "Meroitic_Cursive",
        astral: "\uD802[\uDDA0-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDDFF]"
      }, {
        name: "Meroitic_Hieroglyphs",
        astral: "\uD802[\uDD80-\uDD9F]"
      }, {
        name: "Miao",
        astral: "\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]"
      }, {
        name: "Modi",
        astral: "\uD805[\uDE00-\uDE44\uDE50-\uDE59]"
      }, {
        name: "Mongolian",
        bmp: "\u1800\u1801\u1804\u1806-\u180E\u1810-\u1819\u1820-\u1877\u1880-\u18AA",
        astral: "\uD805[\uDE60-\uDE6C]"
      }, {
        name: "Mro",
        astral: "\uD81A[\uDE40-\uDE5E\uDE60-\uDE69\uDE6E\uDE6F]"
      }, {
        name: "Multani",
        astral: "\uD804[\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA9]"
      }, {
        name: "Myanmar",
        bmp: "\u1000-\u109F\uA9E0-\uA9FE\uAA60-\uAA7F"
      }, {
        name: "Nabataean",
        astral: "\uD802[\uDC80-\uDC9E\uDCA7-\uDCAF]"
      }, {
        name: "New_Tai_Lue",
        bmp: "\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE\u19DF"
      }, {
        name: "Newa",
        astral: "\uD805[\uDC00-\uDC59\uDC5B\uDC5D]"
      }, {
        name: "Nko",
        bmp: "\u07C0-\u07FA"
      }, {
        name: "Ogham",
        bmp: "\u1680-\u169C"
      }, {
        name: "Ol_Chiki",
        bmp: "\u1C50-\u1C7F"
      }, {
        name: "Old_Hungarian",
        astral: "\uD803[\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDCFF]"
      }, {
        name: "Old_Italic",
        astral: "\uD800[\uDF00-\uDF23]"
      }, {
        name: "Old_North_Arabian",
        astral: "\uD802[\uDE80-\uDE9F]"
      }, {
        name: "Old_Permic",
        astral: "\uD800[\uDF50-\uDF7A]"
      }, {
        name: "Old_Persian",
        astral: "\uD800[\uDFA0-\uDFC3\uDFC8-\uDFD5]"
      }, {
        name: "Old_South_Arabian",
        astral: "\uD802[\uDE60-\uDE7F]"
      }, {
        name: "Old_Turkic",
        astral: "\uD803[\uDC00-\uDC48]"
      }, {
        name: "Oriya",
        bmp: "\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77"
      }, {
        name: "Osage",
        astral: "\uD801[\uDCB0-\uDCD3\uDCD8-\uDCFB]"
      }, {
        name: "Osmanya",
        astral: "\uD801[\uDC80-\uDC9D\uDCA0-\uDCA9]"
      }, {
        name: "Pahawh_Hmong",
        astral: "\uD81A[\uDF00-\uDF45\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]"
      }, {
        name: "Palmyrene",
        astral: "\uD802[\uDC60-\uDC7F]"
      }, {
        name: "Pau_Cin_Hau",
        astral: "\uD806[\uDEC0-\uDEF8]"
      }, {
        name: "Phags_Pa",
        bmp: "\uA840-\uA877"
      }, {
        name: "Phoenician",
        astral: "\uD802[\uDD00-\uDD1B\uDD1F]"
      }, {
        name: "Psalter_Pahlavi",
        astral: "\uD802[\uDF80-\uDF91\uDF99-\uDF9C\uDFA9-\uDFAF]"
      }, {
        name: "Rejang",
        bmp: "\uA930-\uA953\uA95F"
      }, {
        name: "Runic",
        bmp: "\u16A0-\u16EA\u16EE-\u16F8"
      }, {
        name: "Samaritan",
        bmp: "\u0800-\u082D\u0830-\u083E"
      }, {
        name: "Saurashtra",
        bmp: "\uA880-\uA8C5\uA8CE-\uA8D9"
      }, {
        name: "Sharada",
        astral: "\uD804[\uDD80-\uDDCD\uDDD0-\uDDDF]"
      }, {
        name: "Shavian",
        astral: "\uD801[\uDC50-\uDC7F]"
      }, {
        name: "Siddham",
        astral: "\uD805[\uDD80-\uDDB5\uDDB8-\uDDDD]"
      }, {
        name: "SignWriting",
        astral: "\uD836[\uDC00-\uDE8B\uDE9B-\uDE9F\uDEA1-\uDEAF]"
      }, {
        name: "Sinhala",
        bmp: "\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4",
        astral: "\uD804[\uDDE1-\uDDF4]"
      }, {
        name: "Sora_Sompeng",
        astral: "\uD804[\uDCD0-\uDCE8\uDCF0-\uDCF9]"
      }, {
        name: "Sundanese",
        bmp: "\u1B80-\u1BBF\u1CC0-\u1CC7"
      }, {
        name: "Syloti_Nagri",
        bmp: "\uA800-\uA82B"
      }, {
        name: "Syriac",
        bmp: "\u0700-\u070D\u070F-\u074A\u074D-\u074F"
      }, {
        name: "Tagalog",
        bmp: "\u1700-\u170C\u170E-\u1714"
      }, {
        name: "Tagbanwa",
        bmp: "\u1760-\u176C\u176E-\u1770\u1772\u1773"
      }, {
        name: "Tai_Le",
        bmp: "\u1950-\u196D\u1970-\u1974"
      }, {
        name: "Tai_Tham",
        bmp: "\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD"
      }, {
        name: "Tai_Viet",
        bmp: "\uAA80-\uAAC2\uAADB-\uAADF"
      }, {
        name: "Takri",
        astral: "\uD805[\uDE80-\uDEB7\uDEC0-\uDEC9]"
      }, {
        name: "Tamil",
        bmp: "\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA"
      }, {
        name: "Tangut",
        astral: "\u{16FE0}|[\uD81C-\uD820][\uDC00-\uDFFF]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]"
      }, {
        name: "Telugu",
        bmp: "\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7F"
      }, {
        name: "Thaana",
        bmp: "\u0780-\u07B1"
      }, {
        name: "Thai",
        bmp: "\u0E01-\u0E3A\u0E40-\u0E5B"
      }, {
        name: "Tibetan",
        bmp: "\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FD4\u0FD9\u0FDA"
      }, {
        name: "Tifinagh",
        bmp: "\u2D30-\u2D67\u2D6F\u2D70\u2D7F"
      }, {
        name: "Tirhuta",
        astral: "\uD805[\uDC80-\uDCC7\uDCD0-\uDCD9]"
      }, {
        name: "Ugaritic",
        astral: "\uD800[\uDF80-\uDF9D\uDF9F]"
      }, {
        name: "Vai",
        bmp: "\uA500-\uA62B"
      }, {
        name: "Warang_Citi",
        astral: "\uD806[\uDCA0-\uDCF2\uDCFF]"
      }, {
        name: "Yi",
        bmp: "\uA000-\uA48C\uA490-\uA4C6"
      }]);
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/xregexp/lib/index.js
var require_lib = __commonJS({
  "node_modules/xregexp/lib/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _xregexp = require_xregexp();
    var _xregexp2 = _interopRequireDefault(_xregexp);
    var _build = require_build();
    var _build2 = _interopRequireDefault(_build);
    var _matchrecursive = require_matchrecursive();
    var _matchrecursive2 = _interopRequireDefault(_matchrecursive);
    var _unicodeBase = require_unicode_base();
    var _unicodeBase2 = _interopRequireDefault(_unicodeBase);
    var _unicodeBlocks = require_unicode_blocks();
    var _unicodeBlocks2 = _interopRequireDefault(_unicodeBlocks);
    var _unicodeCategories = require_unicode_categories();
    var _unicodeCategories2 = _interopRequireDefault(_unicodeCategories);
    var _unicodeProperties = require_unicode_properties();
    var _unicodeProperties2 = _interopRequireDefault(_unicodeProperties);
    var _unicodeScripts = require_unicode_scripts();
    var _unicodeScripts2 = _interopRequireDefault(_unicodeScripts);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    (0, _build2.default)(_xregexp2.default);
    (0, _matchrecursive2.default)(_xregexp2.default);
    (0, _unicodeBase2.default)(_xregexp2.default);
    (0, _unicodeBlocks2.default)(_xregexp2.default);
    (0, _unicodeCategories2.default)(_xregexp2.default);
    (0, _unicodeProperties2.default)(_xregexp2.default);
    (0, _unicodeScripts2.default)(_xregexp2.default);
    exports2.default = _xregexp2.default;
    module2.exports = exports2["default"];
  }
});

// node_modules/decamelize/index.js
var require_decamelize = __commonJS({
  "node_modules/decamelize/index.js"(exports2, module2) {
    "use strict";
    var xRegExp = require_lib();
    module2.exports = (text, separator) => {
      if (typeof text !== "string") {
        throw new TypeError("Expected a string");
      }
      separator = typeof separator === "undefined" ? "_" : separator;
      const regex1 = xRegExp("([\\p{Ll}\\d])(\\p{Lu})", "g");
      const regex2 = xRegExp("(\\p{Lu}+)(\\p{Lu}[\\p{Ll}\\d]+)", "g");
      return text.replace(regex1, `$1${separator}$2`).replace(regex2, `$1${separator}$2`).toLowerCase();
    };
  }
});

// node_modules/async/dist/async.js
var require_async = __commonJS({
  "node_modules/async/dist/async.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.async = {});
    })(exports2, function(exports3) {
      "use strict";
      function apply(fn, ...args) {
        return (...callArgs) => fn(...args, ...callArgs);
      }
      function initialParams(fn) {
        return function(...args) {
          var callback = args.pop();
          return fn.call(this, args, callback);
        };
      }
      var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
      var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
      var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
      function fallback(fn) {
        setTimeout(fn, 0);
      }
      function wrap(defer) {
        return (fn, ...args) => defer(() => fn(...args));
      }
      var _defer;
      if (hasQueueMicrotask) {
        _defer = queueMicrotask;
      } else if (hasSetImmediate) {
        _defer = setImmediate;
      } else if (hasNextTick) {
        _defer = process.nextTick;
      } else {
        _defer = fallback;
      }
      var setImmediate$1 = wrap(_defer);
      function asyncify(func) {
        if (isAsync(func)) {
          return function(...args) {
            const callback = args.pop();
            const promise = func.apply(this, args);
            return handlePromise(promise, callback);
          };
        }
        return initialParams(function(args, callback) {
          var result;
          try {
            result = func.apply(this, args);
          } catch (e) {
            return callback(e);
          }
          if (result && typeof result.then === "function") {
            return handlePromise(result, callback);
          } else {
            callback(null, result);
          }
        });
      }
      function handlePromise(promise, callback) {
        return promise.then((value) => {
          invokeCallback(callback, null, value);
        }, (err) => {
          invokeCallback(callback, err && err.message ? err : new Error(err));
        });
      }
      function invokeCallback(callback, error, value) {
        try {
          callback(error, value);
        } catch (err) {
          setImmediate$1((e) => {
            throw e;
          }, err);
        }
      }
      function isAsync(fn) {
        return fn[Symbol.toStringTag] === "AsyncFunction";
      }
      function isAsyncGenerator(fn) {
        return fn[Symbol.toStringTag] === "AsyncGenerator";
      }
      function isAsyncIterable(obj) {
        return typeof obj[Symbol.asyncIterator] === "function";
      }
      function wrapAsync(asyncFn) {
        if (typeof asyncFn !== "function") throw new Error("expected a function");
        return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
      }
      function awaitify(asyncFn, arity = asyncFn.length) {
        if (!arity) throw new Error("arity is undefined");
        function awaitable(...args) {
          if (typeof args[arity - 1] === "function") {
            return asyncFn.apply(this, args);
          }
          return new Promise((resolve, reject2) => {
            args[arity - 1] = (err, ...cbArgs) => {
              if (err) return reject2(err);
              resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
            };
            asyncFn.apply(this, args);
          });
        }
        return awaitable;
      }
      function applyEach(eachfn) {
        return function applyEach2(fns, ...callArgs) {
          const go = awaitify(function(callback) {
            var that = this;
            return eachfn(fns, (fn, cb) => {
              wrapAsync(fn).apply(that, callArgs.concat(cb));
            }, callback);
          });
          return go;
        };
      }
      function _asyncMap(eachfn, arr, iteratee, callback) {
        arr = arr || [];
        var results = [];
        var counter = 0;
        var _iteratee = wrapAsync(iteratee);
        return eachfn(arr, (value, _, iterCb) => {
          var index2 = counter++;
          _iteratee(value, (err, v) => {
            results[index2] = v;
            iterCb(err);
          });
        }, (err) => {
          callback(err, results);
        });
      }
      function isArrayLike(value) {
        return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
      }
      const breakLoop = {};
      function once(fn) {
        function wrapper(...args) {
          if (fn === null) return;
          var callFn = fn;
          fn = null;
          callFn.apply(this, args);
        }
        Object.assign(wrapper, fn);
        return wrapper;
      }
      function getIterator(coll) {
        return coll[Symbol.iterator] && coll[Symbol.iterator]();
      }
      function createArrayIterator(coll) {
        var i = -1;
        var len = coll.length;
        return function next() {
          return ++i < len ? { value: coll[i], key: i } : null;
        };
      }
      function createES2015Iterator(iterator) {
        var i = -1;
        return function next() {
          var item = iterator.next();
          if (item.done)
            return null;
          i++;
          return { value: item.value, key: i };
        };
      }
      function createObjectIterator(obj) {
        var okeys = obj ? Object.keys(obj) : [];
        var i = -1;
        var len = okeys.length;
        return function next() {
          var key = okeys[++i];
          if (key === "__proto__") {
            return next();
          }
          return i < len ? { value: obj[key], key } : null;
        };
      }
      function createIterator(coll) {
        if (isArrayLike(coll)) {
          return createArrayIterator(coll);
        }
        var iterator = getIterator(coll);
        return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
      }
      function onlyOnce(fn) {
        return function(...args) {
          if (fn === null) throw new Error("Callback was already called.");
          var callFn = fn;
          fn = null;
          callFn.apply(this, args);
        };
      }
      function asyncEachOfLimit(generator, limit, iteratee, callback) {
        let done = false;
        let canceled = false;
        let awaiting = false;
        let running = 0;
        let idx = 0;
        function replenish() {
          if (running >= limit || awaiting || done) return;
          awaiting = true;
          generator.next().then(({ value, done: iterDone }) => {
            if (canceled || done) return;
            awaiting = false;
            if (iterDone) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running++;
            iteratee(value, idx, iterateeCallback);
            idx++;
            replenish();
          }).catch(handleError);
        }
        function iterateeCallback(err, result) {
          running -= 1;
          if (canceled) return;
          if (err) return handleError(err);
          if (err === false) {
            done = true;
            canceled = true;
            return;
          }
          if (result === breakLoop || done && running <= 0) {
            done = true;
            return callback(null);
          }
          replenish();
        }
        function handleError(err) {
          if (canceled) return;
          awaiting = false;
          done = true;
          callback(err);
        }
        replenish();
      }
      var eachOfLimit = (limit) => {
        return (obj, iteratee, callback) => {
          callback = once(callback);
          if (limit <= 0) {
            throw new RangeError("concurrency limit cannot be less than 1");
          }
          if (!obj) {
            return callback(null);
          }
          if (isAsyncGenerator(obj)) {
            return asyncEachOfLimit(obj, limit, iteratee, callback);
          }
          if (isAsyncIterable(obj)) {
            return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
          }
          var nextElem = createIterator(obj);
          var done = false;
          var canceled = false;
          var running = 0;
          var looping = false;
          function iterateeCallback(err, value) {
            if (canceled) return;
            running -= 1;
            if (err) {
              done = true;
              callback(err);
            } else if (err === false) {
              done = true;
              canceled = true;
            } else if (value === breakLoop || done && running <= 0) {
              done = true;
              return callback(null);
            } else if (!looping) {
              replenish();
            }
          }
          function replenish() {
            looping = true;
            while (running < limit && !done) {
              var elem = nextElem();
              if (elem === null) {
                done = true;
                if (running <= 0) {
                  callback(null);
                }
                return;
              }
              running += 1;
              iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
            }
            looping = false;
          }
          replenish();
        };
      };
      function eachOfLimit$1(coll, limit, iteratee, callback) {
        return eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
      }
      var eachOfLimit$2 = awaitify(eachOfLimit$1, 4);
      function eachOfArrayLike(coll, iteratee, callback) {
        callback = once(callback);
        var index2 = 0, completed = 0, { length } = coll, canceled = false;
        if (length === 0) {
          callback(null);
        }
        function iteratorCallback(err, value) {
          if (err === false) {
            canceled = true;
          }
          if (canceled === true) return;
          if (err) {
            callback(err);
          } else if (++completed === length || value === breakLoop) {
            callback(null);
          }
        }
        for (; index2 < length; index2++) {
          iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
        }
      }
      function eachOfGeneric(coll, iteratee, callback) {
        return eachOfLimit$2(coll, Infinity, iteratee, callback);
      }
      function eachOf(coll, iteratee, callback) {
        var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
        return eachOfImplementation(coll, wrapAsync(iteratee), callback);
      }
      var eachOf$1 = awaitify(eachOf, 3);
      function map(coll, iteratee, callback) {
        return _asyncMap(eachOf$1, coll, iteratee, callback);
      }
      var map$1 = awaitify(map, 3);
      var applyEach$1 = applyEach(map$1);
      function eachOfSeries(coll, iteratee, callback) {
        return eachOfLimit$2(coll, 1, iteratee, callback);
      }
      var eachOfSeries$1 = awaitify(eachOfSeries, 3);
      function mapSeries(coll, iteratee, callback) {
        return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
      }
      var mapSeries$1 = awaitify(mapSeries, 3);
      var applyEachSeries = applyEach(mapSeries$1);
      const PROMISE_SYMBOL = Symbol("promiseCallback");
      function promiseCallback() {
        let resolve, reject2;
        function callback(err, ...args) {
          if (err) return reject2(err);
          resolve(args.length > 1 ? args : args[0]);
        }
        callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
          resolve = res, reject2 = rej;
        });
        return callback;
      }
      function auto(tasks, concurrency, callback) {
        if (typeof concurrency !== "number") {
          callback = concurrency;
          concurrency = null;
        }
        callback = once(callback || promiseCallback());
        var numTasks = Object.keys(tasks).length;
        if (!numTasks) {
          return callback(null);
        }
        if (!concurrency) {
          concurrency = numTasks;
        }
        var results = {};
        var runningTasks = 0;
        var canceled = false;
        var hasError = false;
        var listeners = /* @__PURE__ */ Object.create(null);
        var readyTasks = [];
        var readyToCheck = [];
        var uncheckedDependencies = {};
        Object.keys(tasks).forEach((key) => {
          var task = tasks[key];
          if (!Array.isArray(task)) {
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
          }
          var dependencies = task.slice(0, task.length - 1);
          var remainingDependencies = dependencies.length;
          if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
          }
          uncheckedDependencies[key] = remainingDependencies;
          dependencies.forEach((dependencyName) => {
            if (!tasks[dependencyName]) {
              throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
            }
            addListener(dependencyName, () => {
              remainingDependencies--;
              if (remainingDependencies === 0) {
                enqueueTask(key, task);
              }
            });
          });
        });
        checkForDeadlocks();
        processQueue();
        function enqueueTask(key, task) {
          readyTasks.push(() => runTask(key, task));
        }
        function processQueue() {
          if (canceled) return;
          if (readyTasks.length === 0 && runningTasks === 0) {
            return callback(null, results);
          }
          while (readyTasks.length && runningTasks < concurrency) {
            var run = readyTasks.shift();
            run();
          }
        }
        function addListener(taskName, fn) {
          var taskListeners = listeners[taskName];
          if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
          }
          taskListeners.push(fn);
        }
        function taskComplete(taskName) {
          var taskListeners = listeners[taskName] || [];
          taskListeners.forEach((fn) => fn());
          processQueue();
        }
        function runTask(key, task) {
          if (hasError) return;
          var taskCallback = onlyOnce((err, ...result) => {
            runningTasks--;
            if (err === false) {
              canceled = true;
              return;
            }
            if (result.length < 2) {
              [result] = result;
            }
            if (err) {
              var safeResults = {};
              Object.keys(results).forEach((rkey) => {
                safeResults[rkey] = results[rkey];
              });
              safeResults[key] = result;
              hasError = true;
              listeners = /* @__PURE__ */ Object.create(null);
              if (canceled) return;
              callback(err, safeResults);
            } else {
              results[key] = result;
              taskComplete(key);
            }
          });
          runningTasks++;
          var taskFn = wrapAsync(task[task.length - 1]);
          if (task.length > 1) {
            taskFn(results, taskCallback);
          } else {
            taskFn(taskCallback);
          }
        }
        function checkForDeadlocks() {
          var currentTask;
          var counter = 0;
          while (readyToCheck.length) {
            currentTask = readyToCheck.pop();
            counter++;
            getDependents(currentTask).forEach((dependent) => {
              if (--uncheckedDependencies[dependent] === 0) {
                readyToCheck.push(dependent);
              }
            });
          }
          if (counter !== numTasks) {
            throw new Error(
              "async.auto cannot execute tasks due to a recursive dependency"
            );
          }
        }
        function getDependents(taskName) {
          var result = [];
          Object.keys(tasks).forEach((key) => {
            const task = tasks[key];
            if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
              result.push(key);
            }
          });
          return result;
        }
        return callback[PROMISE_SYMBOL];
      }
      var FN_ARGS = /^(?:async\s+)?(?:function)?\s*\w*\s*\(\s*([^)]+)\s*\)(?:\s*{)/;
      var ARROW_FN_ARGS = /^(?:async\s+)?\(?\s*([^)=]+)\s*\)?(?:\s*=>)/;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /(=.+)?(\s*)$/;
      function stripComments(string) {
        let stripped = "";
        let index2 = 0;
        let endBlockComment = string.indexOf("*/");
        while (index2 < string.length) {
          if (string[index2] === "/" && string[index2 + 1] === "/") {
            let endIndex = string.indexOf("\n", index2);
            index2 = endIndex === -1 ? string.length : endIndex;
          } else if (endBlockComment !== -1 && string[index2] === "/" && string[index2 + 1] === "*") {
            let endIndex = string.indexOf("*/", index2);
            if (endIndex !== -1) {
              index2 = endIndex + 2;
              endBlockComment = string.indexOf("*/", index2);
            } else {
              stripped += string[index2];
              index2++;
            }
          } else {
            stripped += string[index2];
            index2++;
          }
        }
        return stripped;
      }
      function parseParams(func) {
        const src = stripComments(func.toString());
        let match = src.match(FN_ARGS);
        if (!match) {
          match = src.match(ARROW_FN_ARGS);
        }
        if (!match) throw new Error("could not parse args in autoInject\nSource:\n" + src);
        let [, args] = match;
        return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
      }
      function autoInject(tasks, callback) {
        var newTasks = {};
        Object.keys(tasks).forEach((key) => {
          var taskFn = tasks[key];
          var params;
          var fnIsAsync = isAsync(taskFn);
          var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
          if (Array.isArray(taskFn)) {
            params = [...taskFn];
            taskFn = params.pop();
            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
          } else if (hasNoDeps) {
            newTasks[key] = taskFn;
          } else {
            params = parseParams(taskFn);
            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
              throw new Error("autoInject task functions require explicit parameters.");
            }
            if (!fnIsAsync) params.pop();
            newTasks[key] = params.concat(newTask);
          }
          function newTask(results, taskCb) {
            var newArgs = params.map((name) => results[name]);
            newArgs.push(taskCb);
            wrapAsync(taskFn)(...newArgs);
          }
        });
        return auto(newTasks, callback);
      }
      class DLL {
        constructor() {
          this.head = this.tail = null;
          this.length = 0;
        }
        removeLink(node) {
          if (node.prev) node.prev.next = node.next;
          else this.head = node.next;
          if (node.next) node.next.prev = node.prev;
          else this.tail = node.prev;
          node.prev = node.next = null;
          this.length -= 1;
          return node;
        }
        empty() {
          while (this.head) this.shift();
          return this;
        }
        insertAfter(node, newNode) {
          newNode.prev = node;
          newNode.next = node.next;
          if (node.next) node.next.prev = newNode;
          else this.tail = newNode;
          node.next = newNode;
          this.length += 1;
        }
        insertBefore(node, newNode) {
          newNode.prev = node.prev;
          newNode.next = node;
          if (node.prev) node.prev.next = newNode;
          else this.head = newNode;
          node.prev = newNode;
          this.length += 1;
        }
        unshift(node) {
          if (this.head) this.insertBefore(this.head, node);
          else setInitial(this, node);
        }
        push(node) {
          if (this.tail) this.insertAfter(this.tail, node);
          else setInitial(this, node);
        }
        shift() {
          return this.head && this.removeLink(this.head);
        }
        pop() {
          return this.tail && this.removeLink(this.tail);
        }
        toArray() {
          return [...this];
        }
        *[Symbol.iterator]() {
          var cur = this.head;
          while (cur) {
            yield cur.data;
            cur = cur.next;
          }
        }
        remove(testFn) {
          var curr = this.head;
          while (curr) {
            var { next } = curr;
            if (testFn(curr)) {
              this.removeLink(curr);
            }
            curr = next;
          }
          return this;
        }
      }
      function setInitial(dll, node) {
        dll.length = 1;
        dll.head = dll.tail = node;
      }
      function queue(worker, concurrency, payload) {
        if (concurrency == null) {
          concurrency = 1;
        } else if (concurrency === 0) {
          throw new RangeError("Concurrency must not be zero");
        }
        var _worker = wrapAsync(worker);
        var numRunning = 0;
        var workersList = [];
        const events = {
          error: [],
          drain: [],
          saturated: [],
          unsaturated: [],
          empty: []
        };
        function on(event, handler) {
          events[event].push(handler);
        }
        function once2(event, handler) {
          const handleAndRemove = (...args) => {
            off(event, handleAndRemove);
            handler(...args);
          };
          events[event].push(handleAndRemove);
        }
        function off(event, handler) {
          if (!event) return Object.keys(events).forEach((ev) => events[ev] = []);
          if (!handler) return events[event] = [];
          events[event] = events[event].filter((ev) => ev !== handler);
        }
        function trigger(event, ...args) {
          events[event].forEach((handler) => handler(...args));
        }
        var processingScheduled = false;
        function _insert(data, insertAtFront, rejectOnError, callback) {
          if (callback != null && typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          q.started = true;
          var res, rej;
          function promiseCallback2(err, ...args) {
            if (err) return rejectOnError ? rej(err) : res();
            if (args.length <= 1) return res(args[0]);
            res(args);
          }
          var item = {
            data,
            callback: rejectOnError ? promiseCallback2 : callback || promiseCallback2
          };
          if (insertAtFront) {
            q._tasks.unshift(item);
          } else {
            q._tasks.push(item);
          }
          if (!processingScheduled) {
            processingScheduled = true;
            setImmediate$1(() => {
              processingScheduled = false;
              q.process();
            });
          }
          if (rejectOnError || !callback) {
            return new Promise((resolve, reject2) => {
              res = resolve;
              rej = reject2;
            });
          }
        }
        function _createCB(tasks) {
          return function(err, ...args) {
            numRunning -= 1;
            for (var i = 0, l = tasks.length; i < l; i++) {
              var task = tasks[i];
              var index2 = workersList.indexOf(task);
              if (index2 === 0) {
                workersList.shift();
              } else if (index2 > 0) {
                workersList.splice(index2, 1);
              }
              task.callback(err, ...args);
              if (err != null) {
                trigger("error", err, task.data);
              }
            }
            if (numRunning <= q.concurrency - q.buffer) {
              trigger("unsaturated");
            }
            if (q.idle()) {
              trigger("drain");
            }
            q.process();
          };
        }
        function _maybeDrain(data) {
          if (data.length === 0 && q.idle()) {
            setImmediate$1(() => trigger("drain"));
            return true;
          }
          return false;
        }
        const eventMethod = (name) => (handler) => {
          if (!handler) {
            return new Promise((resolve, reject2) => {
              once2(name, (err, data) => {
                if (err) return reject2(err);
                resolve(data);
              });
            });
          }
          off(name);
          on(name, handler);
        };
        var isProcessing = false;
        var q = {
          _tasks: new DLL(),
          *[Symbol.iterator]() {
            yield* q._tasks[Symbol.iterator]();
          },
          concurrency,
          payload,
          buffer: concurrency / 4,
          started: false,
          paused: false,
          push(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data)) return;
              return data.map((datum) => _insert(datum, false, false, callback));
            }
            return _insert(data, false, false, callback);
          },
          pushAsync(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data)) return;
              return data.map((datum) => _insert(datum, false, true, callback));
            }
            return _insert(data, false, true, callback);
          },
          kill() {
            off();
            q._tasks.empty();
          },
          unshift(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data)) return;
              return data.map((datum) => _insert(datum, true, false, callback));
            }
            return _insert(data, true, false, callback);
          },
          unshiftAsync(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data)) return;
              return data.map((datum) => _insert(datum, true, true, callback));
            }
            return _insert(data, true, true, callback);
          },
          remove(testFn) {
            q._tasks.remove(testFn);
          },
          process() {
            if (isProcessing) {
              return;
            }
            isProcessing = true;
            while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
              var tasks = [], data = [];
              var l = q._tasks.length;
              if (q.payload) l = Math.min(l, q.payload);
              for (var i = 0; i < l; i++) {
                var node = q._tasks.shift();
                tasks.push(node);
                workersList.push(node);
                data.push(node.data);
              }
              numRunning += 1;
              if (q._tasks.length === 0) {
                trigger("empty");
              }
              if (numRunning === q.concurrency) {
                trigger("saturated");
              }
              var cb = onlyOnce(_createCB(tasks));
              _worker(data, cb);
            }
            isProcessing = false;
          },
          length() {
            return q._tasks.length;
          },
          running() {
            return numRunning;
          },
          workersList() {
            return workersList;
          },
          idle() {
            return q._tasks.length + numRunning === 0;
          },
          pause() {
            q.paused = true;
          },
          resume() {
            if (q.paused === false) {
              return;
            }
            q.paused = false;
            setImmediate$1(q.process);
          }
        };
        Object.defineProperties(q, {
          saturated: {
            writable: false,
            value: eventMethod("saturated")
          },
          unsaturated: {
            writable: false,
            value: eventMethod("unsaturated")
          },
          empty: {
            writable: false,
            value: eventMethod("empty")
          },
          drain: {
            writable: false,
            value: eventMethod("drain")
          },
          error: {
            writable: false,
            value: eventMethod("error")
          }
        });
        return q;
      }
      function cargo(worker, payload) {
        return queue(worker, 1, payload);
      }
      function cargo$1(worker, concurrency, payload) {
        return queue(worker, concurrency, payload);
      }
      function reduce(coll, memo, iteratee, callback) {
        callback = once(callback);
        var _iteratee = wrapAsync(iteratee);
        return eachOfSeries$1(coll, (x, i, iterCb) => {
          _iteratee(memo, x, (err, v) => {
            memo = v;
            iterCb(err);
          });
        }, (err) => callback(err, memo));
      }
      var reduce$1 = awaitify(reduce, 4);
      function seq(...functions) {
        var _functions = functions.map(wrapAsync);
        return function(...args) {
          var that = this;
          var cb = args[args.length - 1];
          if (typeof cb == "function") {
            args.pop();
          } else {
            cb = promiseCallback();
          }
          reduce$1(
            _functions,
            args,
            (newargs, fn, iterCb) => {
              fn.apply(that, newargs.concat((err, ...nextargs) => {
                iterCb(err, nextargs);
              }));
            },
            (err, results) => cb(err, ...results)
          );
          return cb[PROMISE_SYMBOL];
        };
      }
      function compose(...args) {
        return seq(...args.reverse());
      }
      function mapLimit(coll, limit, iteratee, callback) {
        return _asyncMap(eachOfLimit(limit), coll, iteratee, callback);
      }
      var mapLimit$1 = awaitify(mapLimit, 4);
      function concatLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
          _iteratee(val, (err, ...args) => {
            if (err) return iterCb(err);
            return iterCb(err, args);
          });
        }, (err, mapResults) => {
          var result = [];
          for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
              result = result.concat(...mapResults[i]);
            }
          }
          return callback(err, result);
        });
      }
      var concatLimit$1 = awaitify(concatLimit, 4);
      function concat(coll, iteratee, callback) {
        return concatLimit$1(coll, Infinity, iteratee, callback);
      }
      var concat$1 = awaitify(concat, 3);
      function concatSeries(coll, iteratee, callback) {
        return concatLimit$1(coll, 1, iteratee, callback);
      }
      var concatSeries$1 = awaitify(concatSeries, 3);
      function constant(...args) {
        return function(...ignoredArgs) {
          var callback = ignoredArgs.pop();
          return callback(null, ...args);
        };
      }
      function _createTester(check, getResult) {
        return (eachfn, arr, _iteratee, cb) => {
          var testPassed = false;
          var testResult;
          const iteratee = wrapAsync(_iteratee);
          eachfn(arr, (value, _, callback) => {
            iteratee(value, (err, result) => {
              if (err || err === false) return callback(err);
              if (check(result) && !testResult) {
                testPassed = true;
                testResult = getResult(true, value);
                return callback(null, breakLoop);
              }
              callback();
            });
          }, (err) => {
            if (err) return cb(err);
            cb(null, testPassed ? testResult : getResult(false));
          });
        };
      }
      function detect(coll, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
      }
      var detect$1 = awaitify(detect, 3);
      function detectLimit(coll, limit, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(limit), coll, iteratee, callback);
      }
      var detectLimit$1 = awaitify(detectLimit, 4);
      function detectSeries(coll, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(1), coll, iteratee, callback);
      }
      var detectSeries$1 = awaitify(detectSeries, 3);
      function consoleFunc(name) {
        return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
          if (typeof console === "object") {
            if (err) {
              if (console.error) {
                console.error(err);
              }
            } else if (console[name]) {
              resultArgs.forEach((x) => console[name](x));
            }
          }
        });
      }
      var dir = consoleFunc("dir");
      function doWhilst(iteratee, test, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results;
        function next(err, ...args) {
          if (err) return callback(err);
          if (err === false) return;
          results = args;
          _test(...args, check);
        }
        function check(err, truth) {
          if (err) return callback(err);
          if (err === false) return;
          if (!truth) return callback(null, ...results);
          _fn(next);
        }
        return check(null, true);
      }
      var doWhilst$1 = awaitify(doWhilst, 3);
      function doUntil(iteratee, test, callback) {
        const _test = wrapAsync(test);
        return doWhilst$1(iteratee, (...args) => {
          const cb = args.pop();
          _test(...args, (err, truth) => cb(err, !truth));
        }, callback);
      }
      function _withoutIndex(iteratee) {
        return (value, index2, callback) => iteratee(value, callback);
      }
      function eachLimit(coll, iteratee, callback) {
        return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var each = awaitify(eachLimit, 3);
      function eachLimit$1(coll, limit, iteratee, callback) {
        return eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var eachLimit$2 = awaitify(eachLimit$1, 4);
      function eachSeries(coll, iteratee, callback) {
        return eachLimit$2(coll, 1, iteratee, callback);
      }
      var eachSeries$1 = awaitify(eachSeries, 3);
      function ensureAsync(fn) {
        if (isAsync(fn)) return fn;
        return function(...args) {
          var callback = args.pop();
          var sync = true;
          args.push((...innerArgs) => {
            if (sync) {
              setImmediate$1(() => callback(...innerArgs));
            } else {
              callback(...innerArgs);
            }
          });
          fn.apply(this, args);
          sync = false;
        };
      }
      function every(coll, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
      }
      var every$1 = awaitify(every, 3);
      function everyLimit(coll, limit, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOfLimit(limit), coll, iteratee, callback);
      }
      var everyLimit$1 = awaitify(everyLimit, 4);
      function everySeries(coll, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
      }
      var everySeries$1 = awaitify(everySeries, 3);
      function filterArray(eachfn, arr, iteratee, callback) {
        var truthValues = new Array(arr.length);
        eachfn(arr, (x, index2, iterCb) => {
          iteratee(x, (err, v) => {
            truthValues[index2] = !!v;
            iterCb(err);
          });
        }, (err) => {
          if (err) return callback(err);
          var results = [];
          for (var i = 0; i < arr.length; i++) {
            if (truthValues[i]) results.push(arr[i]);
          }
          callback(null, results);
        });
      }
      function filterGeneric(eachfn, coll, iteratee, callback) {
        var results = [];
        eachfn(coll, (x, index2, iterCb) => {
          iteratee(x, (err, v) => {
            if (err) return iterCb(err);
            if (v) {
              results.push({ index: index2, value: x });
            }
            iterCb(err);
          });
        }, (err) => {
          if (err) return callback(err);
          callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
        });
      }
      function _filter(eachfn, coll, iteratee, callback) {
        var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
        return filter2(eachfn, coll, wrapAsync(iteratee), callback);
      }
      function filter(coll, iteratee, callback) {
        return _filter(eachOf$1, coll, iteratee, callback);
      }
      var filter$1 = awaitify(filter, 3);
      function filterLimit(coll, limit, iteratee, callback) {
        return _filter(eachOfLimit(limit), coll, iteratee, callback);
      }
      var filterLimit$1 = awaitify(filterLimit, 4);
      function filterSeries(coll, iteratee, callback) {
        return _filter(eachOfSeries$1, coll, iteratee, callback);
      }
      var filterSeries$1 = awaitify(filterSeries, 3);
      function forever(fn, errback) {
        var done = onlyOnce(errback);
        var task = wrapAsync(ensureAsync(fn));
        function next(err) {
          if (err) return done(err);
          if (err === false) return;
          task(next);
        }
        return next();
      }
      var forever$1 = awaitify(forever, 2);
      function groupByLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
          _iteratee(val, (err, key) => {
            if (err) return iterCb(err);
            return iterCb(err, { key, val });
          });
        }, (err, mapResults) => {
          var result = {};
          var { hasOwnProperty } = Object.prototype;
          for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
              var { key } = mapResults[i];
              var { val } = mapResults[i];
              if (hasOwnProperty.call(result, key)) {
                result[key].push(val);
              } else {
                result[key] = [val];
              }
            }
          }
          return callback(err, result);
        });
      }
      var groupByLimit$1 = awaitify(groupByLimit, 4);
      function groupBy(coll, iteratee, callback) {
        return groupByLimit$1(coll, Infinity, iteratee, callback);
      }
      function groupBySeries(coll, iteratee, callback) {
        return groupByLimit$1(coll, 1, iteratee, callback);
      }
      var log = consoleFunc("log");
      function mapValuesLimit(obj, limit, iteratee, callback) {
        callback = once(callback);
        var newObj = {};
        var _iteratee = wrapAsync(iteratee);
        return eachOfLimit(limit)(obj, (val, key, next) => {
          _iteratee(val, key, (err, result) => {
            if (err) return next(err);
            newObj[key] = result;
            next(err);
          });
        }, (err) => callback(err, newObj));
      }
      var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
      function mapValues(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, Infinity, iteratee, callback);
      }
      function mapValuesSeries(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, 1, iteratee, callback);
      }
      function memoize(fn, hasher = (v) => v) {
        var memo = /* @__PURE__ */ Object.create(null);
        var queues = /* @__PURE__ */ Object.create(null);
        var _fn = wrapAsync(fn);
        var memoized = initialParams((args, callback) => {
          var key = hasher(...args);
          if (key in memo) {
            setImmediate$1(() => callback(null, ...memo[key]));
          } else if (key in queues) {
            queues[key].push(callback);
          } else {
            queues[key] = [callback];
            _fn(...args, (err, ...resultArgs) => {
              if (!err) {
                memo[key] = resultArgs;
              }
              var q = queues[key];
              delete queues[key];
              for (var i = 0, l = q.length; i < l; i++) {
                q[i](err, ...resultArgs);
              }
            });
          }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
      }
      var _defer$1;
      if (hasNextTick) {
        _defer$1 = process.nextTick;
      } else if (hasSetImmediate) {
        _defer$1 = setImmediate;
      } else {
        _defer$1 = fallback;
      }
      var nextTick = wrap(_defer$1);
      var _parallel = awaitify((eachfn, tasks, callback) => {
        var results = isArrayLike(tasks) ? [] : {};
        eachfn(tasks, (task, key, taskCb) => {
          wrapAsync(task)((err, ...result) => {
            if (result.length < 2) {
              [result] = result;
            }
            results[key] = result;
            taskCb(err);
          });
        }, (err) => callback(err, results));
      }, 3);
      function parallel(tasks, callback) {
        return _parallel(eachOf$1, tasks, callback);
      }
      function parallelLimit(tasks, limit, callback) {
        return _parallel(eachOfLimit(limit), tasks, callback);
      }
      function queue$1(worker, concurrency) {
        var _worker = wrapAsync(worker);
        return queue((items, cb) => {
          _worker(items[0], cb);
        }, concurrency, 1);
      }
      class Heap {
        constructor() {
          this.heap = [];
          this.pushCount = Number.MIN_SAFE_INTEGER;
        }
        get length() {
          return this.heap.length;
        }
        empty() {
          this.heap = [];
          return this;
        }
        percUp(index2) {
          let p;
          while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
            let t = this.heap[index2];
            this.heap[index2] = this.heap[p];
            this.heap[p] = t;
            index2 = p;
          }
        }
        percDown(index2) {
          let l;
          while ((l = leftChi(index2)) < this.heap.length) {
            if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {
              l = l + 1;
            }
            if (smaller(this.heap[index2], this.heap[l])) {
              break;
            }
            let t = this.heap[index2];
            this.heap[index2] = this.heap[l];
            this.heap[l] = t;
            index2 = l;
          }
        }
        push(node) {
          node.pushCount = ++this.pushCount;
          this.heap.push(node);
          this.percUp(this.heap.length - 1);
        }
        unshift(node) {
          return this.heap.push(node);
        }
        shift() {
          let [top] = this.heap;
          this.heap[0] = this.heap[this.heap.length - 1];
          this.heap.pop();
          this.percDown(0);
          return top;
        }
        toArray() {
          return [...this];
        }
        *[Symbol.iterator]() {
          for (let i = 0; i < this.heap.length; i++) {
            yield this.heap[i].data;
          }
        }
        remove(testFn) {
          let j = 0;
          for (let i = 0; i < this.heap.length; i++) {
            if (!testFn(this.heap[i])) {
              this.heap[j] = this.heap[i];
              j++;
            }
          }
          this.heap.splice(j);
          for (let i = parent(this.heap.length - 1); i >= 0; i--) {
            this.percDown(i);
          }
          return this;
        }
      }
      function leftChi(i) {
        return (i << 1) + 1;
      }
      function parent(i) {
        return (i + 1 >> 1) - 1;
      }
      function smaller(x, y) {
        if (x.priority !== y.priority) {
          return x.priority < y.priority;
        } else {
          return x.pushCount < y.pushCount;
        }
      }
      function priorityQueue(worker, concurrency) {
        var q = queue$1(worker, concurrency);
        var processingScheduled = false;
        q._tasks = new Heap();
        q.push = function(data, priority = 0, callback = () => {
        }) {
          if (typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          q.started = true;
          if (!Array.isArray(data)) {
            data = [data];
          }
          if (data.length === 0 && q.idle()) {
            return setImmediate$1(() => q.drain());
          }
          for (var i = 0, l = data.length; i < l; i++) {
            var item = {
              data: data[i],
              priority,
              callback
            };
            q._tasks.push(item);
          }
          if (!processingScheduled) {
            processingScheduled = true;
            setImmediate$1(() => {
              processingScheduled = false;
              q.process();
            });
          }
        };
        delete q.unshift;
        return q;
      }
      function race(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks)) return callback(new TypeError("First argument to race must be an array of functions"));
        if (!tasks.length) return callback();
        for (var i = 0, l = tasks.length; i < l; i++) {
          wrapAsync(tasks[i])(callback);
        }
      }
      var race$1 = awaitify(race, 2);
      function reduceRight(array, memo, iteratee, callback) {
        var reversed = [...array].reverse();
        return reduce$1(reversed, memo, iteratee, callback);
      }
      function reflect(fn) {
        var _fn = wrapAsync(fn);
        return initialParams(function reflectOn(args, reflectCallback) {
          args.push((error, ...cbArgs) => {
            let retVal = {};
            if (error) {
              retVal.error = error;
            }
            if (cbArgs.length > 0) {
              var value = cbArgs;
              if (cbArgs.length <= 1) {
                [value] = cbArgs;
              }
              retVal.value = value;
            }
            reflectCallback(null, retVal);
          });
          return _fn.apply(this, args);
        });
      }
      function reflectAll(tasks) {
        var results;
        if (Array.isArray(tasks)) {
          results = tasks.map(reflect);
        } else {
          results = {};
          Object.keys(tasks).forEach((key) => {
            results[key] = reflect.call(this, tasks[key]);
          });
        }
        return results;
      }
      function reject(eachfn, arr, _iteratee, callback) {
        const iteratee = wrapAsync(_iteratee);
        return _filter(eachfn, arr, (value, cb) => {
          iteratee(value, (err, v) => {
            cb(err, !v);
          });
        }, callback);
      }
      function reject$1(coll, iteratee, callback) {
        return reject(eachOf$1, coll, iteratee, callback);
      }
      var reject$2 = awaitify(reject$1, 3);
      function rejectLimit(coll, limit, iteratee, callback) {
        return reject(eachOfLimit(limit), coll, iteratee, callback);
      }
      var rejectLimit$1 = awaitify(rejectLimit, 4);
      function rejectSeries(coll, iteratee, callback) {
        return reject(eachOfSeries$1, coll, iteratee, callback);
      }
      var rejectSeries$1 = awaitify(rejectSeries, 3);
      function constant$1(value) {
        return function() {
          return value;
        };
      }
      const DEFAULT_TIMES = 5;
      const DEFAULT_INTERVAL = 0;
      function retry(opts, task, callback) {
        var options = {
          times: DEFAULT_TIMES,
          intervalFunc: constant$1(DEFAULT_INTERVAL)
        };
        if (arguments.length < 3 && typeof opts === "function") {
          callback = task || promiseCallback();
          task = opts;
        } else {
          parseTimes(options, opts);
          callback = callback || promiseCallback();
        }
        if (typeof task !== "function") {
          throw new Error("Invalid arguments for async.retry");
        }
        var _task = wrapAsync(task);
        var attempt = 1;
        function retryAttempt() {
          _task((err, ...args) => {
            if (err === false) return;
            if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
              setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
            } else {
              callback(err, ...args);
            }
          });
        }
        retryAttempt();
        return callback[PROMISE_SYMBOL];
      }
      function parseTimes(acc, t) {
        if (typeof t === "object") {
          acc.times = +t.times || DEFAULT_TIMES;
          acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);
          acc.errorFilter = t.errorFilter;
        } else if (typeof t === "number" || typeof t === "string") {
          acc.times = +t || DEFAULT_TIMES;
        } else {
          throw new Error("Invalid arguments for async.retry");
        }
      }
      function retryable(opts, task) {
        if (!task) {
          task = opts;
          opts = null;
        }
        let arity = opts && opts.arity || task.length;
        if (isAsync(task)) {
          arity += 1;
        }
        var _task = wrapAsync(task);
        return initialParams((args, callback) => {
          if (args.length < arity - 1 || callback == null) {
            args.push(callback);
            callback = promiseCallback();
          }
          function taskFn(cb) {
            _task(...args, cb);
          }
          if (opts) retry(opts, taskFn, callback);
          else retry(taskFn, callback);
          return callback[PROMISE_SYMBOL];
        });
      }
      function series(tasks, callback) {
        return _parallel(eachOfSeries$1, tasks, callback);
      }
      function some(coll, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
      }
      var some$1 = awaitify(some, 3);
      function someLimit(coll, limit, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOfLimit(limit), coll, iteratee, callback);
      }
      var someLimit$1 = awaitify(someLimit, 4);
      function someSeries(coll, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
      }
      var someSeries$1 = awaitify(someSeries, 3);
      function sortBy(coll, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return map$1(coll, (x, iterCb) => {
          _iteratee(x, (err, criteria) => {
            if (err) return iterCb(err);
            iterCb(err, { value: x, criteria });
          });
        }, (err, results) => {
          if (err) return callback(err);
          callback(null, results.sort(comparator).map((v) => v.value));
        });
        function comparator(left, right) {
          var a = left.criteria, b = right.criteria;
          return a < b ? -1 : a > b ? 1 : 0;
        }
      }
      var sortBy$1 = awaitify(sortBy, 3);
      function timeout(asyncFn, milliseconds, info) {
        var fn = wrapAsync(asyncFn);
        return initialParams((args, callback) => {
          var timedOut = false;
          var timer;
          function timeoutCallback() {
            var name = asyncFn.name || "anonymous";
            var error = new Error('Callback function "' + name + '" timed out.');
            error.code = "ETIMEDOUT";
            if (info) {
              error.info = info;
            }
            timedOut = true;
            callback(error);
          }
          args.push((...cbArgs) => {
            if (!timedOut) {
              callback(...cbArgs);
              clearTimeout(timer);
            }
          });
          timer = setTimeout(timeoutCallback, milliseconds);
          fn(...args);
        });
      }
      function range(size) {
        var result = Array(size);
        while (size--) {
          result[size] = size;
        }
        return result;
      }
      function timesLimit(count, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(range(count), limit, _iteratee, callback);
      }
      function times(n, iteratee, callback) {
        return timesLimit(n, Infinity, iteratee, callback);
      }
      function timesSeries(n, iteratee, callback) {
        return timesLimit(n, 1, iteratee, callback);
      }
      function transform(coll, accumulator, iteratee, callback) {
        if (arguments.length <= 3 && typeof accumulator === "function") {
          callback = iteratee;
          iteratee = accumulator;
          accumulator = Array.isArray(coll) ? [] : {};
        }
        callback = once(callback || promiseCallback());
        var _iteratee = wrapAsync(iteratee);
        eachOf$1(coll, (v, k, cb) => {
          _iteratee(accumulator, v, k, cb);
        }, (err) => callback(err, accumulator));
        return callback[PROMISE_SYMBOL];
      }
      function tryEach(tasks, callback) {
        var error = null;
        var result;
        return eachSeries$1(tasks, (task, taskCb) => {
          wrapAsync(task)((err, ...args) => {
            if (err === false) return taskCb(err);
            if (args.length < 2) {
              [result] = args;
            } else {
              result = args;
            }
            error = err;
            taskCb(err ? null : {});
          });
        }, () => callback(error, result));
      }
      var tryEach$1 = awaitify(tryEach);
      function unmemoize(fn) {
        return (...args) => {
          return (fn.unmemoized || fn)(...args);
        };
      }
      function whilst(test, iteratee, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results = [];
        function next(err, ...rest) {
          if (err) return callback(err);
          results = rest;
          if (err === false) return;
          _test(check);
        }
        function check(err, truth) {
          if (err) return callback(err);
          if (err === false) return;
          if (!truth) return callback(null, ...results);
          _fn(next);
        }
        return _test(check);
      }
      var whilst$1 = awaitify(whilst, 3);
      function until(test, iteratee, callback) {
        const _test = wrapAsync(test);
        return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
      }
      function waterfall(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks)) return callback(new Error("First argument to waterfall must be an array of functions"));
        if (!tasks.length) return callback();
        var taskIndex = 0;
        function nextTask(args) {
          var task = wrapAsync(tasks[taskIndex++]);
          task(...args, onlyOnce(next));
        }
        function next(err, ...args) {
          if (err === false) return;
          if (err || taskIndex === tasks.length) {
            return callback(err, ...args);
          }
          nextTask(args);
        }
        nextTask([]);
      }
      var waterfall$1 = awaitify(waterfall);
      var index = {
        apply,
        applyEach: applyEach$1,
        applyEachSeries,
        asyncify,
        auto,
        autoInject,
        cargo,
        cargoQueue: cargo$1,
        compose,
        concat: concat$1,
        concatLimit: concatLimit$1,
        concatSeries: concatSeries$1,
        constant,
        detect: detect$1,
        detectLimit: detectLimit$1,
        detectSeries: detectSeries$1,
        dir,
        doUntil,
        doWhilst: doWhilst$1,
        each,
        eachLimit: eachLimit$2,
        eachOf: eachOf$1,
        eachOfLimit: eachOfLimit$2,
        eachOfSeries: eachOfSeries$1,
        eachSeries: eachSeries$1,
        ensureAsync,
        every: every$1,
        everyLimit: everyLimit$1,
        everySeries: everySeries$1,
        filter: filter$1,
        filterLimit: filterLimit$1,
        filterSeries: filterSeries$1,
        forever: forever$1,
        groupBy,
        groupByLimit: groupByLimit$1,
        groupBySeries,
        log,
        map: map$1,
        mapLimit: mapLimit$1,
        mapSeries: mapSeries$1,
        mapValues,
        mapValuesLimit: mapValuesLimit$1,
        mapValuesSeries,
        memoize,
        nextTick,
        parallel,
        parallelLimit,
        priorityQueue,
        queue: queue$1,
        race: race$1,
        reduce: reduce$1,
        reduceRight,
        reflect,
        reflectAll,
        reject: reject$2,
        rejectLimit: rejectLimit$1,
        rejectSeries: rejectSeries$1,
        retry,
        retryable,
        seq,
        series,
        setImmediate: setImmediate$1,
        some: some$1,
        someLimit: someLimit$1,
        someSeries: someSeries$1,
        sortBy: sortBy$1,
        timeout,
        times,
        timesLimit,
        timesSeries,
        transform,
        tryEach: tryEach$1,
        unmemoize,
        until,
        waterfall: waterfall$1,
        whilst: whilst$1,
        // aliases
        all: every$1,
        allLimit: everyLimit$1,
        allSeries: everySeries$1,
        any: some$1,
        anyLimit: someLimit$1,
        anySeries: someSeries$1,
        find: detect$1,
        findLimit: detectLimit$1,
        findSeries: detectSeries$1,
        flatMap: concat$1,
        flatMapLimit: concatLimit$1,
        flatMapSeries: concatSeries$1,
        forEach: each,
        forEachSeries: eachSeries$1,
        forEachLimit: eachLimit$2,
        forEachOf: eachOf$1,
        forEachOfSeries: eachOfSeries$1,
        forEachOfLimit: eachOfLimit$2,
        inject: reduce$1,
        foldl: reduce$1,
        foldr: reduceRight,
        select: filter$1,
        selectLimit: filterLimit$1,
        selectSeries: filterSeries$1,
        wrapSync: asyncify,
        during: whilst$1,
        doDuring: doWhilst$1
      };
      exports3.default = index;
      exports3.apply = apply;
      exports3.applyEach = applyEach$1;
      exports3.applyEachSeries = applyEachSeries;
      exports3.asyncify = asyncify;
      exports3.auto = auto;
      exports3.autoInject = autoInject;
      exports3.cargo = cargo;
      exports3.cargoQueue = cargo$1;
      exports3.compose = compose;
      exports3.concat = concat$1;
      exports3.concatLimit = concatLimit$1;
      exports3.concatSeries = concatSeries$1;
      exports3.constant = constant;
      exports3.detect = detect$1;
      exports3.detectLimit = detectLimit$1;
      exports3.detectSeries = detectSeries$1;
      exports3.dir = dir;
      exports3.doUntil = doUntil;
      exports3.doWhilst = doWhilst$1;
      exports3.each = each;
      exports3.eachLimit = eachLimit$2;
      exports3.eachOf = eachOf$1;
      exports3.eachOfLimit = eachOfLimit$2;
      exports3.eachOfSeries = eachOfSeries$1;
      exports3.eachSeries = eachSeries$1;
      exports3.ensureAsync = ensureAsync;
      exports3.every = every$1;
      exports3.everyLimit = everyLimit$1;
      exports3.everySeries = everySeries$1;
      exports3.filter = filter$1;
      exports3.filterLimit = filterLimit$1;
      exports3.filterSeries = filterSeries$1;
      exports3.forever = forever$1;
      exports3.groupBy = groupBy;
      exports3.groupByLimit = groupByLimit$1;
      exports3.groupBySeries = groupBySeries;
      exports3.log = log;
      exports3.map = map$1;
      exports3.mapLimit = mapLimit$1;
      exports3.mapSeries = mapSeries$1;
      exports3.mapValues = mapValues;
      exports3.mapValuesLimit = mapValuesLimit$1;
      exports3.mapValuesSeries = mapValuesSeries;
      exports3.memoize = memoize;
      exports3.nextTick = nextTick;
      exports3.parallel = parallel;
      exports3.parallelLimit = parallelLimit;
      exports3.priorityQueue = priorityQueue;
      exports3.queue = queue$1;
      exports3.race = race$1;
      exports3.reduce = reduce$1;
      exports3.reduceRight = reduceRight;
      exports3.reflect = reflect;
      exports3.reflectAll = reflectAll;
      exports3.reject = reject$2;
      exports3.rejectLimit = rejectLimit$1;
      exports3.rejectSeries = rejectSeries$1;
      exports3.retry = retry;
      exports3.retryable = retryable;
      exports3.seq = seq;
      exports3.series = series;
      exports3.setImmediate = setImmediate$1;
      exports3.some = some$1;
      exports3.someLimit = someLimit$1;
      exports3.someSeries = someSeries$1;
      exports3.sortBy = sortBy$1;
      exports3.timeout = timeout;
      exports3.times = times;
      exports3.timesLimit = timesLimit;
      exports3.timesSeries = timesSeries;
      exports3.transform = transform;
      exports3.tryEach = tryEach$1;
      exports3.unmemoize = unmemoize;
      exports3.until = until;
      exports3.waterfall = waterfall$1;
      exports3.whilst = whilst$1;
      exports3.all = every$1;
      exports3.allLimit = everyLimit$1;
      exports3.allSeries = everySeries$1;
      exports3.any = some$1;
      exports3.anyLimit = someLimit$1;
      exports3.anySeries = someSeries$1;
      exports3.find = detect$1;
      exports3.findLimit = detectLimit$1;
      exports3.findSeries = detectSeries$1;
      exports3.flatMap = concat$1;
      exports3.flatMapLimit = concatLimit$1;
      exports3.flatMapSeries = concatSeries$1;
      exports3.forEach = each;
      exports3.forEachSeries = eachSeries$1;
      exports3.forEachLimit = eachLimit$2;
      exports3.forEachOf = eachOf$1;
      exports3.forEachOfSeries = eachOfSeries$1;
      exports3.forEachOfLimit = eachOfLimit$2;
      exports3.inject = reduce$1;
      exports3.foldl = reduce$1;
      exports3.foldr = reduceRight;
      exports3.select = filter$1;
      exports3.selectLimit = filterLimit$1;
      exports3.selectSeries = filterSeries$1;
      exports3.wrapSync = asyncify;
      exports3.during = whilst$1;
      exports3.doDuring = doWhilst$1;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/ini/ini.js
var require_ini = __commonJS({
  "node_modules/ini/ini.js"(exports2, module2) {
    var { hasOwnProperty } = Object.prototype;
    var eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
    var encode = (obj, opt) => {
      const children = [];
      let out = "";
      if (typeof opt === "string") {
        opt = {
          section: opt,
          whitespace: false
        };
      } else {
        opt = opt || /* @__PURE__ */ Object.create(null);
        opt.whitespace = opt.whitespace === true;
      }
      const separator = opt.whitespace ? " = " : "=";
      for (const k of Object.keys(obj)) {
        const val = obj[k];
        if (val && Array.isArray(val)) {
          for (const item of val)
            out += safe(k + "[]") + separator + safe(item) + "\n";
        } else if (val && typeof val === "object")
          children.push(k);
        else
          out += safe(k) + separator + safe(val) + eol;
      }
      if (opt.section && out.length)
        out = "[" + safe(opt.section) + "]" + eol + out;
      for (const k of children) {
        const nk = dotSplit(k).join("\\.");
        const section = (opt.section ? opt.section + "." : "") + nk;
        const { whitespace } = opt;
        const child = encode(obj[k], {
          section,
          whitespace
        });
        if (out.length && child.length)
          out += eol;
        out += child;
      }
      return out;
    };
    var dotSplit = (str) => str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map((part) => part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, ""));
    var decode = (str) => {
      const out = /* @__PURE__ */ Object.create(null);
      let p = out;
      let section = null;
      const re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
      const lines = str.split(/[\r\n]+/g);
      for (const line of lines) {
        if (!line || line.match(/^\s*[;#]/))
          continue;
        const match = line.match(re);
        if (!match)
          continue;
        if (match[1] !== void 0) {
          section = unsafe(match[1]);
          if (section === "__proto__") {
            p = /* @__PURE__ */ Object.create(null);
            continue;
          }
          p = out[section] = out[section] || /* @__PURE__ */ Object.create(null);
          continue;
        }
        const keyRaw = unsafe(match[2]);
        const isArray = keyRaw.length > 2 && keyRaw.slice(-2) === "[]";
        const key = isArray ? keyRaw.slice(0, -2) : keyRaw;
        if (key === "__proto__")
          continue;
        const valueRaw = match[3] ? unsafe(match[4]) : true;
        const value = valueRaw === "true" || valueRaw === "false" || valueRaw === "null" ? JSON.parse(valueRaw) : valueRaw;
        if (isArray) {
          if (!hasOwnProperty.call(p, key))
            p[key] = [];
          else if (!Array.isArray(p[key]))
            p[key] = [p[key]];
        }
        if (Array.isArray(p[key]))
          p[key].push(value);
        else
          p[key] = value;
      }
      const remove = [];
      for (const k of Object.keys(out)) {
        if (!hasOwnProperty.call(out, k) || typeof out[k] !== "object" || Array.isArray(out[k]))
          continue;
        const parts = dotSplit(k);
        let p2 = out;
        const l = parts.pop();
        const nl = l.replace(/\\\./g, ".");
        for (const part of parts) {
          if (part === "__proto__")
            continue;
          if (!hasOwnProperty.call(p2, part) || typeof p2[part] !== "object")
            p2[part] = /* @__PURE__ */ Object.create(null);
          p2 = p2[part];
        }
        if (p2 === out && nl === l)
          continue;
        p2[nl] = out[k];
        remove.push(k);
      }
      for (const del of remove)
        delete out[del];
      return out;
    };
    var isQuoted = (val) => val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
    var safe = (val) => typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
    var unsafe = (val, doUnesc) => {
      val = (val || "").trim();
      if (isQuoted(val)) {
        if (val.charAt(0) === "'")
          val = val.substr(1, val.length - 2);
        try {
          val = JSON.parse(val);
        } catch (_) {
        }
      } else {
        let esc = false;
        let unesc = "";
        for (let i = 0, l = val.length; i < l; i++) {
          const c = val.charAt(i);
          if (esc) {
            if ("\\;#".indexOf(c) !== -1)
              unesc += c;
            else
              unesc += "\\" + c;
            esc = false;
          } else if (";#".indexOf(c) !== -1)
            break;
          else if (c === "\\")
            esc = true;
          else
            unesc += c;
        }
        if (esc)
          unesc += "\\";
        return unesc.trim();
      }
      return val;
    };
    module2.exports = {
      parse: decode,
      decode,
      stringify: encode,
      encode,
      safe,
      unsafe
    };
  }
});

// node_modules/nconf/lib/nconf/formats.js
var require_formats = __commonJS({
  "node_modules/nconf/lib/nconf/formats.js"(exports2) {
    var ini = require_ini();
    var formats = exports2;
    formats.json = {
      stringify: function(obj, replacer, spacing) {
        return JSON.stringify(obj, replacer || null, spacing || 2);
      },
      parse: JSON.parse
    };
    formats.ini = ini;
  }
});

// node_modules/nconf/lib/nconf/stores/memory.js
var require_memory = __commonJS({
  "node_modules/nconf/lib/nconf/stores/memory.js"(exports2) {
    var common = require_common3();
    var Memory = exports2.Memory = function(options) {
      options = options || {};
      this.type = "memory";
      this.store = {};
      this.mtimes = {};
      this.readOnly = false;
      this.loadFrom = options.loadFrom || null;
      this.logicalSeparator = options.logicalSeparator || ":";
      this.parseValues = options.parseValues || false;
      if (this.loadFrom) {
        this.store = common.loadFilesSync(this.loadFrom);
      }
    };
    Memory.prototype.get = function(key) {
      var target = this.store, path = common.path(key, this.logicalSeparator);
      while (path.length > 0) {
        key = path.shift();
        if (target && typeof target !== "string" && Object.hasOwnProperty.call(target, key)) {
          target = target[key];
          continue;
        }
        return void 0;
      }
      return target;
    };
    Memory.prototype.set = function(key, value) {
      if (this.readOnly) {
        return false;
      }
      var target = this.store, path = common.path(key, this.logicalSeparator);
      if (path.length === 0) {
        if (!value || typeof value !== "object") {
          return false;
        } else {
          this.reset();
          this.store = value;
          return true;
        }
      }
      this.mtimes[key] = Date.now();
      while (path.length > 1) {
        key = path.shift();
        if (!target[key] || typeof target[key] !== "object" || !Object.hasOwnProperty.call(target, key)) {
          target[key] = {};
        }
        target = target[key];
      }
      key = path.shift();
      if (this.parseValues) {
        value = common.parseValues.call(common, value);
      }
      target[key] = value;
      return true;
    };
    Memory.prototype.clear = function(key) {
      if (this.readOnly) {
        return false;
      }
      var target = this.store, value = target, path = common.path(key, this.logicalSeparator);
      delete this.mtimes[key];
      for (var i = 0; i < path.length - 1; i++) {
        key = path[i];
        value = target[key];
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        target = value;
      }
      key = path[i];
      delete target[key];
      return true;
    };
    Memory.prototype.merge = function(key, value) {
      if (this.readOnly) {
        return false;
      }
      if (typeof value !== "object" || Array.isArray(value) || value === null) {
        return this.set(key, value);
      }
      var self2 = this, target = this.store, path = common.path(key, this.logicalSeparator), fullKey = key;
      this.mtimes[key] = Date.now();
      while (path.length > 1) {
        key = path.shift();
        if (!target[key]) {
          target[key] = {};
        }
        target = target[key];
      }
      key = path.shift();
      if (typeof target[key] !== "object" || Array.isArray(target[key])) {
        target[key] = value;
        return true;
      }
      return Object.keys(value).every(function(nested) {
        return self2.merge(common.keyed(self2.logicalSeparator, fullKey, nested), value[nested]);
      });
    };
    Memory.prototype.reset = function() {
      if (this.readOnly) {
        return false;
      }
      this.mtimes = {};
      this.store = {};
      return true;
    };
    Memory.prototype.loadSync = function() {
      return this.store || {};
    };
  }
});

// node_modules/nconf/lib/nconf/common.js
var require_common3 = __commonJS({
  "node_modules/nconf/lib/nconf/common.js"(exports2) {
    var fs = require("fs");
    var async = require_async();
    var formats = require_formats();
    var Memory = require_memory().Memory;
    var common = exports2;
    common.path = function(key, separator) {
      separator = separator || ":";
      return key == null ? [] : key.split(separator);
    };
    common.key = function() {
      return Array.prototype.slice.call(arguments).join(":");
    };
    common.keyed = function() {
      return Array.prototype.slice.call(arguments, 1).join(arguments[0]);
    };
    common.loadFiles = function(files, callback) {
      if (!files) {
        return callback(null, {});
      }
      var options = Array.isArray(files) ? { files } : files;
      options.format = options.format || formats.json;
      function parseFile(file, next) {
        fs.readFile(file, function(err, data) {
          return !err ? next(null, options.format.parse(data.toString())) : next(err);
        });
      }
      async.map(options.files, parseFile, function(err, objs) {
        return err ? callback(err) : callback(null, common.merge(objs));
      });
    };
    common.loadFilesSync = function(files) {
      if (!files) {
        return;
      }
      var options = Array.isArray(files) ? { files } : files;
      options.format = options.format || formats.json;
      return common.merge(options.files.map(function(file) {
        return options.format.parse(fs.readFileSync(file, "utf8"));
      }));
    };
    common.merge = function(objs) {
      var store = new Memory();
      objs.forEach(function(obj) {
        Object.keys(obj).forEach(function(key) {
          store.merge(key, obj[key]);
        });
      });
      return store.store;
    };
    common.capitalize = function(str) {
      return str && str[0].toUpperCase() + str.slice(1);
    };
    common.parseValues = function(value) {
      var val = value;
      try {
        val = JSON.parse(value);
      } catch (ignore) {
        if (value === "undefined") {
          val = void 0;
        }
      }
      return val;
    };
    common.transform = function(map, fn) {
      var pairs = Object.keys(map).map(function(key) {
        var obj = { key, value: map[key] };
        var result = fn.call(null, obj);
        if (!result) {
          return null;
        } else if (result.key) {
          return result;
        }
        var error = new Error("Transform function passed to store returned an invalid format: " + JSON.stringify(result));
        error.name = "RuntimeError";
        throw error;
      });
      return pairs.filter(function(pair) {
        return pair !== null;
      }).reduce(function(accumulator, pair) {
        accumulator[pair.key] = pair.value;
        return accumulator;
      }, {});
    };
  }
});

// node_modules/y18n/build/index.cjs
var require_build2 = __commonJS({
  "node_modules/y18n/build/index.cjs"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var util = require("util");
    var path = require("path");
    var shim;
    var Y18N = class {
      constructor(opts) {
        opts = opts || {};
        this.directory = opts.directory || "./locales";
        this.updateFiles = typeof opts.updateFiles === "boolean" ? opts.updateFiles : true;
        this.locale = opts.locale || "en";
        this.fallbackToLanguage = typeof opts.fallbackToLanguage === "boolean" ? opts.fallbackToLanguage : true;
        this.cache = /* @__PURE__ */ Object.create(null);
        this.writeQueue = [];
      }
      __(...args) {
        if (typeof arguments[0] !== "string") {
          return this._taggedLiteral(arguments[0], ...arguments);
        }
        const str = args.shift();
        let cb = function() {
        };
        if (typeof args[args.length - 1] === "function")
          cb = args.pop();
        cb = cb || function() {
        };
        if (!this.cache[this.locale])
          this._readLocaleFile();
        if (!this.cache[this.locale][str] && this.updateFiles) {
          this.cache[this.locale][str] = str;
          this._enqueueWrite({
            directory: this.directory,
            locale: this.locale,
            cb
          });
        } else {
          cb();
        }
        return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args));
      }
      __n() {
        const args = Array.prototype.slice.call(arguments);
        const singular = args.shift();
        const plural = args.shift();
        const quantity = args.shift();
        let cb = function() {
        };
        if (typeof args[args.length - 1] === "function")
          cb = args.pop();
        if (!this.cache[this.locale])
          this._readLocaleFile();
        let str = quantity === 1 ? singular : plural;
        if (this.cache[this.locale][singular]) {
          const entry = this.cache[this.locale][singular];
          str = entry[quantity === 1 ? "one" : "other"];
        }
        if (!this.cache[this.locale][singular] && this.updateFiles) {
          this.cache[this.locale][singular] = {
            one: singular,
            other: plural
          };
          this._enqueueWrite({
            directory: this.directory,
            locale: this.locale,
            cb
          });
        } else {
          cb();
        }
        const values = [str];
        if (~str.indexOf("%d"))
          values.push(quantity);
        return shim.format.apply(shim.format, values.concat(args));
      }
      setLocale(locale) {
        this.locale = locale;
      }
      getLocale() {
        return this.locale;
      }
      updateLocale(obj) {
        if (!this.cache[this.locale])
          this._readLocaleFile();
        for (const key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            this.cache[this.locale][key] = obj[key];
          }
        }
      }
      _taggedLiteral(parts, ...args) {
        let str = "";
        parts.forEach(function(part, i) {
          const arg = args[i + 1];
          str += part;
          if (typeof arg !== "undefined") {
            str += "%s";
          }
        });
        return this.__.apply(this, [str].concat([].slice.call(args, 1)));
      }
      _enqueueWrite(work) {
        this.writeQueue.push(work);
        if (this.writeQueue.length === 1)
          this._processWriteQueue();
      }
      _processWriteQueue() {
        const _this = this;
        const work = this.writeQueue[0];
        const directory = work.directory;
        const locale = work.locale;
        const cb = work.cb;
        const languageFile = this._resolveLocaleFile(directory, locale);
        const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
        shim.fs.writeFile(languageFile, serializedLocale, "utf-8", function(err) {
          _this.writeQueue.shift();
          if (_this.writeQueue.length > 0)
            _this._processWriteQueue();
          cb(err);
        });
      }
      _readLocaleFile() {
        let localeLookup = {};
        const languageFile = this._resolveLocaleFile(this.directory, this.locale);
        try {
          if (shim.fs.readFileSync) {
            localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, "utf-8"));
          }
        } catch (err) {
          if (err instanceof SyntaxError) {
            err.message = "syntax error in " + languageFile;
          }
          if (err.code === "ENOENT")
            localeLookup = {};
          else
            throw err;
        }
        this.cache[this.locale] = localeLookup;
      }
      _resolveLocaleFile(directory, locale) {
        let file = shim.resolve(directory, "./", locale + ".json");
        if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf("_")) {
          const languageFile = shim.resolve(directory, "./", locale.split("_")[0] + ".json");
          if (this._fileExistsSync(languageFile))
            file = languageFile;
        }
        return file;
      }
      _fileExistsSync(file) {
        return shim.exists(file);
      }
    };
    function y18n$1(opts, _shim) {
      shim = _shim;
      const y18n2 = new Y18N(opts);
      return {
        __: y18n2.__.bind(y18n2),
        __n: y18n2.__n.bind(y18n2),
        setLocale: y18n2.setLocale.bind(y18n2),
        getLocale: y18n2.getLocale.bind(y18n2),
        updateLocale: y18n2.updateLocale.bind(y18n2),
        locale: y18n2.locale
      };
    }
    var nodePlatformShim = {
      fs: {
        readFileSync: fs.readFileSync,
        writeFile: fs.writeFile
      },
      format: util.format,
      resolve: path.resolve,
      exists: (file) => {
        try {
          return fs.statSync(file).isFile();
        } catch (err) {
          return false;
        }
      }
    };
    var y18n = (opts) => {
      return y18n$1(opts, nodePlatformShim);
    };
    module2.exports = y18n;
  }
});

// node_modules/yargs-parser/build/index.cjs
var require_build3 = __commonJS({
  "node_modules/yargs-parser/build/index.cjs"(exports2, module2) {
    "use strict";
    var util = require("util");
    var fs = require("fs");
    var path = require("path");
    function camelCase(str) {
      const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
      if (!isCamelCase) {
        str = str.toLowerCase();
      }
      if (str.indexOf("-") === -1 && str.indexOf("_") === -1) {
        return str;
      } else {
        let camelcase = "";
        let nextChrUpper = false;
        const leadingHyphens = str.match(/^-+/);
        for (let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++) {
          let chr = str.charAt(i);
          if (nextChrUpper) {
            nextChrUpper = false;
            chr = chr.toUpperCase();
          }
          if (i !== 0 && (chr === "-" || chr === "_")) {
            nextChrUpper = true;
          } else if (chr !== "-" && chr !== "_") {
            camelcase += chr;
          }
        }
        return camelcase;
      }
    }
    function decamelize(str, joinString) {
      const lowercase = str.toLowerCase();
      joinString = joinString || "-";
      let notCamelcase = "";
      for (let i = 0; i < str.length; i++) {
        const chrLower = lowercase.charAt(i);
        const chrString = str.charAt(i);
        if (chrLower !== chrString && i > 0) {
          notCamelcase += `${joinString}${lowercase.charAt(i)}`;
        } else {
          notCamelcase += chrString;
        }
      }
      return notCamelcase;
    }
    function looksLikeNumber(x) {
      if (x === null || x === void 0)
        return false;
      if (typeof x === "number")
        return true;
      if (/^0x[0-9a-f]+$/i.test(x))
        return true;
      if (/^0[^.]/.test(x))
        return false;
      return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    function tokenizeArgString(argString) {
      if (Array.isArray(argString)) {
        return argString.map((e) => typeof e !== "string" ? e + "" : e);
      }
      argString = argString.trim();
      let i = 0;
      let prevC = null;
      let c = null;
      let opening = null;
      const args = [];
      for (let ii = 0; ii < argString.length; ii++) {
        prevC = c;
        c = argString.charAt(ii);
        if (c === " " && !opening) {
          if (!(prevC === " ")) {
            i++;
          }
          continue;
        }
        if (c === opening) {
          opening = null;
        } else if ((c === "'" || c === '"') && !opening) {
          opening = c;
        }
        if (!args[i])
          args[i] = "";
        args[i] += c;
      }
      return args;
    }
    var DefaultValuesForTypeKey;
    (function(DefaultValuesForTypeKey2) {
      DefaultValuesForTypeKey2["BOOLEAN"] = "boolean";
      DefaultValuesForTypeKey2["STRING"] = "string";
      DefaultValuesForTypeKey2["NUMBER"] = "number";
      DefaultValuesForTypeKey2["ARRAY"] = "array";
    })(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));
    var mixin;
    var YargsParser = class {
      constructor(_mixin) {
        mixin = _mixin;
      }
      parse(argsInput, options) {
        const opts = Object.assign({
          alias: void 0,
          array: void 0,
          boolean: void 0,
          config: void 0,
          configObjects: void 0,
          configuration: void 0,
          coerce: void 0,
          count: void 0,
          default: void 0,
          envPrefix: void 0,
          narg: void 0,
          normalize: void 0,
          string: void 0,
          number: void 0,
          __: void 0,
          key: void 0
        }, options);
        const args = tokenizeArgString(argsInput);
        const aliases = combineAliases(Object.assign(/* @__PURE__ */ Object.create(null), opts.alias));
        const configuration = Object.assign({
          "boolean-negation": true,
          "camel-case-expansion": true,
          "combine-arrays": false,
          "dot-notation": true,
          "duplicate-arguments-array": true,
          "flatten-duplicate-arrays": true,
          "greedy-arrays": true,
          "halt-at-non-option": false,
          "nargs-eats-options": false,
          "negation-prefix": "no-",
          "parse-numbers": true,
          "parse-positional-numbers": true,
          "populate--": false,
          "set-placeholder-key": false,
          "short-option-groups": true,
          "strip-aliased": false,
          "strip-dashed": false,
          "unknown-options-as-args": false
        }, opts.configuration);
        const defaults = Object.assign(/* @__PURE__ */ Object.create(null), opts.default);
        const configObjects = opts.configObjects || [];
        const envPrefix = opts.envPrefix;
        const notFlagsOption = configuration["populate--"];
        const notFlagsArgv = notFlagsOption ? "--" : "_";
        const newAliases = /* @__PURE__ */ Object.create(null);
        const defaulted = /* @__PURE__ */ Object.create(null);
        const __ = opts.__ || mixin.format;
        const flags = {
          aliases: /* @__PURE__ */ Object.create(null),
          arrays: /* @__PURE__ */ Object.create(null),
          bools: /* @__PURE__ */ Object.create(null),
          strings: /* @__PURE__ */ Object.create(null),
          numbers: /* @__PURE__ */ Object.create(null),
          counts: /* @__PURE__ */ Object.create(null),
          normalize: /* @__PURE__ */ Object.create(null),
          configs: /* @__PURE__ */ Object.create(null),
          nargs: /* @__PURE__ */ Object.create(null),
          coercions: /* @__PURE__ */ Object.create(null),
          keys: []
        };
        const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
        const negatedBoolean = new RegExp("^--" + configuration["negation-prefix"] + "(.+)");
        [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
          const key = typeof opt === "object" ? opt.key : opt;
          const assignment = Object.keys(opt).map(function(key2) {
            const arrayFlagKeys = {
              boolean: "bools",
              string: "strings",
              number: "numbers"
            };
            return arrayFlagKeys[key2];
          }).filter(Boolean).pop();
          if (assignment) {
            flags[assignment][key] = true;
          }
          flags.arrays[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {
          flags.bools[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.string || []).filter(Boolean).forEach(function(key) {
          flags.strings[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.number || []).filter(Boolean).forEach(function(key) {
          flags.numbers[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.count || []).filter(Boolean).forEach(function(key) {
          flags.counts[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {
          flags.normalize[key] = true;
          flags.keys.push(key);
        });
        if (typeof opts.narg === "object") {
          Object.entries(opts.narg).forEach(([key, value]) => {
            if (typeof value === "number") {
              flags.nargs[key] = value;
              flags.keys.push(key);
            }
          });
        }
        if (typeof opts.coerce === "object") {
          Object.entries(opts.coerce).forEach(([key, value]) => {
            if (typeof value === "function") {
              flags.coercions[key] = value;
              flags.keys.push(key);
            }
          });
        }
        if (typeof opts.config !== "undefined") {
          if (Array.isArray(opts.config) || typeof opts.config === "string") {
            [].concat(opts.config).filter(Boolean).forEach(function(key) {
              flags.configs[key] = true;
            });
          } else if (typeof opts.config === "object") {
            Object.entries(opts.config).forEach(([key, value]) => {
              if (typeof value === "boolean" || typeof value === "function") {
                flags.configs[key] = value;
              }
            });
          }
        }
        extendAliases(opts.key, aliases, opts.default, flags.arrays);
        Object.keys(defaults).forEach(function(key) {
          (flags.aliases[key] || []).forEach(function(alias) {
            defaults[alias] = defaults[key];
          });
        });
        let error = null;
        checkConfiguration();
        let notFlags = [];
        const argv = Object.assign(/* @__PURE__ */ Object.create(null), { _: [] });
        const argvReturn = {};
        for (let i = 0; i < args.length; i++) {
          const arg = args[i];
          const truncatedArg = arg.replace(/^-{3,}/, "---");
          let broken;
          let key;
          let letters;
          let m;
          let next;
          let value;
          if (arg !== "--" && isUnknownOptionAsArg(arg)) {
            pushPositional(arg);
          } else if (truncatedArg.match(/---+(=|$)/)) {
            pushPositional(arg);
            continue;
          } else if (arg.match(/^--.+=/) || !configuration["short-option-groups"] && arg.match(/^-.+=/)) {
            m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
            if (m !== null && Array.isArray(m) && m.length >= 3) {
              if (checkAllAliases(m[1], flags.arrays)) {
                i = eatArray(i, m[1], args, m[2]);
              } else if (checkAllAliases(m[1], flags.nargs) !== false) {
                i = eatNargs(i, m[1], args, m[2]);
              } else {
                setArg(m[1], m[2]);
              }
            }
          } else if (arg.match(negatedBoolean) && configuration["boolean-negation"]) {
            m = arg.match(negatedBoolean);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
            }
          } else if (arg.match(/^--.+/) || !configuration["short-option-groups"] && arg.match(/^-[^-]+/)) {
            m = arg.match(/^--?(.+)/);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              if (checkAllAliases(key, flags.arrays)) {
                i = eatArray(i, key, args);
              } else if (checkAllAliases(key, flags.nargs) !== false) {
                i = eatNargs(i, key, args);
              } else {
                next = args[i + 1];
                if (next !== void 0 && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                  setArg(key, next);
                  i++;
                } else if (/^(true|false)$/.test(next)) {
                  setArg(key, next);
                  i++;
                } else {
                  setArg(key, defaultValue(key));
                }
              }
            }
          } else if (arg.match(/^-.\..+=/)) {
            m = arg.match(/^-([^=]+)=([\s\S]*)$/);
            if (m !== null && Array.isArray(m) && m.length >= 3) {
              setArg(m[1], m[2]);
            }
          } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
            next = args[i + 1];
            m = arg.match(/^-(.\..+)/);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              if (next !== void 0 && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                setArg(key, next);
                i++;
              } else {
                setArg(key, defaultValue(key));
              }
            }
          } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
            letters = arg.slice(1, -1).split("");
            broken = false;
            for (let j = 0; j < letters.length; j++) {
              next = arg.slice(j + 2);
              if (letters[j + 1] && letters[j + 1] === "=") {
                value = arg.slice(j + 3);
                key = letters[j];
                if (checkAllAliases(key, flags.arrays)) {
                  i = eatArray(i, key, args, value);
                } else if (checkAllAliases(key, flags.nargs) !== false) {
                  i = eatNargs(i, key, args, value);
                } else {
                  setArg(key, value);
                }
                broken = true;
                break;
              }
              if (next === "-") {
                setArg(letters[j], next);
                continue;
              }
              if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
                setArg(letters[j], next);
                broken = true;
                break;
              }
              if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                setArg(letters[j], next);
                broken = true;
                break;
              } else {
                setArg(letters[j], defaultValue(letters[j]));
              }
            }
            key = arg.slice(-1)[0];
            if (!broken && key !== "-") {
              if (checkAllAliases(key, flags.arrays)) {
                i = eatArray(i, key, args);
              } else if (checkAllAliases(key, flags.nargs) !== false) {
                i = eatNargs(i, key, args);
              } else {
                next = args[i + 1];
                if (next !== void 0 && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                  setArg(key, next);
                  i++;
                } else if (/^(true|false)$/.test(next)) {
                  setArg(key, next);
                  i++;
                } else {
                  setArg(key, defaultValue(key));
                }
              }
            }
          } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
            key = arg.slice(1);
            setArg(key, defaultValue(key));
          } else if (arg === "--") {
            notFlags = args.slice(i + 1);
            break;
          } else if (configuration["halt-at-non-option"]) {
            notFlags = args.slice(i);
            break;
          } else {
            pushPositional(arg);
          }
        }
        applyEnvVars(argv, true);
        applyEnvVars(argv, false);
        setConfig(argv);
        setConfigObjects();
        applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
        applyCoercions(argv);
        if (configuration["set-placeholder-key"])
          setPlaceholderKeys(argv);
        Object.keys(flags.counts).forEach(function(key) {
          if (!hasKey(argv, key.split(".")))
            setArg(key, 0);
        });
        if (notFlagsOption && notFlags.length)
          argv[notFlagsArgv] = [];
        notFlags.forEach(function(key) {
          argv[notFlagsArgv].push(key);
        });
        if (configuration["camel-case-expansion"] && configuration["strip-dashed"]) {
          Object.keys(argv).filter((key) => key !== "--" && key.includes("-")).forEach((key) => {
            delete argv[key];
          });
        }
        if (configuration["strip-aliased"]) {
          [].concat(...Object.keys(aliases).map((k) => aliases[k])).forEach((alias) => {
            if (configuration["camel-case-expansion"] && alias.includes("-")) {
              delete argv[alias.split(".").map((prop) => camelCase(prop)).join(".")];
            }
            delete argv[alias];
          });
        }
        function pushPositional(arg) {
          const maybeCoercedNumber = maybeCoerceNumber("_", arg);
          if (typeof maybeCoercedNumber === "string" || typeof maybeCoercedNumber === "number") {
            argv._.push(maybeCoercedNumber);
          }
        }
        function eatNargs(i, key, args2, argAfterEqualSign) {
          let ii;
          let toEat = checkAllAliases(key, flags.nargs);
          toEat = typeof toEat !== "number" || isNaN(toEat) ? 1 : toEat;
          if (toEat === 0) {
            if (!isUndefined(argAfterEqualSign)) {
              error = Error(__("Argument unexpected for: %s", key));
            }
            setArg(key, defaultValue(key));
            return i;
          }
          let available = isUndefined(argAfterEqualSign) ? 0 : 1;
          if (configuration["nargs-eats-options"]) {
            if (args2.length - (i + 1) + available < toEat) {
              error = Error(__("Not enough arguments following: %s", key));
            }
            available = toEat;
          } else {
            for (ii = i + 1; ii < args2.length; ii++) {
              if (!args2[ii].match(/^-[^0-9]/) || args2[ii].match(negative) || isUnknownOptionAsArg(args2[ii]))
                available++;
              else
                break;
            }
            if (available < toEat)
              error = Error(__("Not enough arguments following: %s", key));
          }
          let consumed = Math.min(available, toEat);
          if (!isUndefined(argAfterEqualSign) && consumed > 0) {
            setArg(key, argAfterEqualSign);
            consumed--;
          }
          for (ii = i + 1; ii < consumed + i + 1; ii++) {
            setArg(key, args2[ii]);
          }
          return i + consumed;
        }
        function eatArray(i, key, args2, argAfterEqualSign) {
          let argsToSet = [];
          let next = argAfterEqualSign || args2[i + 1];
          const nargsCount = checkAllAliases(key, flags.nargs);
          if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
            argsToSet.push(true);
          } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
            if (defaults[key] !== void 0) {
              const defVal = defaults[key];
              argsToSet = Array.isArray(defVal) ? defVal : [defVal];
            }
          } else {
            if (!isUndefined(argAfterEqualSign)) {
              argsToSet.push(processValue(key, argAfterEqualSign));
            }
            for (let ii = i + 1; ii < args2.length; ii++) {
              if (!configuration["greedy-arrays"] && argsToSet.length > 0 || nargsCount && typeof nargsCount === "number" && argsToSet.length >= nargsCount)
                break;
              next = args2[ii];
              if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
                break;
              i = ii;
              argsToSet.push(processValue(key, next));
            }
          }
          if (typeof nargsCount === "number" && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
            error = Error(__("Not enough arguments following: %s", key));
          }
          setArg(key, argsToSet);
          return i;
        }
        function setArg(key, val) {
          if (/-/.test(key) && configuration["camel-case-expansion"]) {
            const alias = key.split(".").map(function(prop) {
              return camelCase(prop);
            }).join(".");
            addNewAlias(key, alias);
          }
          const value = processValue(key, val);
          const splitKey = key.split(".");
          setKey(argv, splitKey, value);
          if (flags.aliases[key]) {
            flags.aliases[key].forEach(function(x) {
              const keyProperties = x.split(".");
              setKey(argv, keyProperties, value);
            });
          }
          if (splitKey.length > 1 && configuration["dot-notation"]) {
            (flags.aliases[splitKey[0]] || []).forEach(function(x) {
              let keyProperties = x.split(".");
              const a = [].concat(splitKey);
              a.shift();
              keyProperties = keyProperties.concat(a);
              if (!(flags.aliases[key] || []).includes(keyProperties.join("."))) {
                setKey(argv, keyProperties, value);
              }
            });
          }
          if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
            const keys = [key].concat(flags.aliases[key] || []);
            keys.forEach(function(key2) {
              Object.defineProperty(argvReturn, key2, {
                enumerable: true,
                get() {
                  return val;
                },
                set(value2) {
                  val = typeof value2 === "string" ? mixin.normalize(value2) : value2;
                }
              });
            });
          }
        }
        function addNewAlias(key, alias) {
          if (!(flags.aliases[key] && flags.aliases[key].length)) {
            flags.aliases[key] = [alias];
            newAliases[alias] = true;
          }
          if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
            addNewAlias(alias, key);
          }
        }
        function processValue(key, val) {
          if (typeof val === "string" && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0]) {
            val = val.substring(1, val.length - 1);
          }
          if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
            if (typeof val === "string")
              val = val === "true";
          }
          let value = Array.isArray(val) ? val.map(function(v) {
            return maybeCoerceNumber(key, v);
          }) : maybeCoerceNumber(key, val);
          if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === "boolean")) {
            value = increment();
          }
          if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
            if (Array.isArray(val))
              value = val.map((val2) => {
                return mixin.normalize(val2);
              });
            else
              value = mixin.normalize(val);
          }
          return value;
        }
        function maybeCoerceNumber(key, value) {
          if (!configuration["parse-positional-numbers"] && key === "_")
            return value;
          if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
            const shouldCoerceNumber = looksLikeNumber(value) && configuration["parse-numbers"] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));
            if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) {
              value = Number(value);
            }
          }
          return value;
        }
        function setConfig(argv2) {
          const configLookup = /* @__PURE__ */ Object.create(null);
          applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
          Object.keys(flags.configs).forEach(function(configKey) {
            const configPath = argv2[configKey] || configLookup[configKey];
            if (configPath) {
              try {
                let config = null;
                const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
                const resolveConfig = flags.configs[configKey];
                if (typeof resolveConfig === "function") {
                  try {
                    config = resolveConfig(resolvedConfigPath);
                  } catch (e) {
                    config = e;
                  }
                  if (config instanceof Error) {
                    error = config;
                    return;
                  }
                } else {
                  config = mixin.require(resolvedConfigPath);
                }
                setConfigObject(config);
              } catch (ex) {
                if (ex.name === "PermissionDenied")
                  error = ex;
                else if (argv2[configKey])
                  error = Error(__("Invalid JSON config file: %s", configPath));
              }
            }
          });
        }
        function setConfigObject(config, prev) {
          Object.keys(config).forEach(function(key) {
            const value = config[key];
            const fullKey = prev ? prev + "." + key : key;
            if (typeof value === "object" && value !== null && !Array.isArray(value) && configuration["dot-notation"]) {
              setConfigObject(value, fullKey);
            } else {
              if (!hasKey(argv, fullKey.split(".")) || checkAllAliases(fullKey, flags.arrays) && configuration["combine-arrays"]) {
                setArg(fullKey, value);
              }
            }
          });
        }
        function setConfigObjects() {
          if (typeof configObjects !== "undefined") {
            configObjects.forEach(function(configObject) {
              setConfigObject(configObject);
            });
          }
        }
        function applyEnvVars(argv2, configOnly) {
          if (typeof envPrefix === "undefined")
            return;
          const prefix = typeof envPrefix === "string" ? envPrefix : "";
          const env2 = mixin.env();
          Object.keys(env2).forEach(function(envVar) {
            if (prefix === "" || envVar.lastIndexOf(prefix, 0) === 0) {
              const keys = envVar.split("__").map(function(key, i) {
                if (i === 0) {
                  key = key.substring(prefix.length);
                }
                return camelCase(key);
              });
              if ((configOnly && flags.configs[keys.join(".")] || !configOnly) && !hasKey(argv2, keys)) {
                setArg(keys.join("."), env2[envVar]);
              }
            }
          });
        }
        function applyCoercions(argv2) {
          let coerce;
          const applied = /* @__PURE__ */ new Set();
          Object.keys(argv2).forEach(function(key) {
            if (!applied.has(key)) {
              coerce = checkAllAliases(key, flags.coercions);
              if (typeof coerce === "function") {
                try {
                  const value = maybeCoerceNumber(key, coerce(argv2[key]));
                  [].concat(flags.aliases[key] || [], key).forEach((ali) => {
                    applied.add(ali);
                    argv2[ali] = value;
                  });
                } catch (err) {
                  error = err;
                }
              }
            }
          });
        }
        function setPlaceholderKeys(argv2) {
          flags.keys.forEach((key) => {
            if (~key.indexOf("."))
              return;
            if (typeof argv2[key] === "undefined")
              argv2[key] = void 0;
          });
          return argv2;
        }
        function applyDefaultsAndAliases(obj, aliases2, defaults2, canLog = false) {
          Object.keys(defaults2).forEach(function(key) {
            if (!hasKey(obj, key.split("."))) {
              setKey(obj, key.split("."), defaults2[key]);
              if (canLog)
                defaulted[key] = true;
              (aliases2[key] || []).forEach(function(x) {
                if (hasKey(obj, x.split(".")))
                  return;
                setKey(obj, x.split("."), defaults2[key]);
              });
            }
          });
        }
        function hasKey(obj, keys) {
          let o = obj;
          if (!configuration["dot-notation"])
            keys = [keys.join(".")];
          keys.slice(0, -1).forEach(function(key2) {
            o = o[key2] || {};
          });
          const key = keys[keys.length - 1];
          if (typeof o !== "object")
            return false;
          else
            return key in o;
        }
        function setKey(obj, keys, value) {
          let o = obj;
          if (!configuration["dot-notation"])
            keys = [keys.join(".")];
          keys.slice(0, -1).forEach(function(key2) {
            key2 = sanitizeKey(key2);
            if (typeof o === "object" && o[key2] === void 0) {
              o[key2] = {};
            }
            if (typeof o[key2] !== "object" || Array.isArray(o[key2])) {
              if (Array.isArray(o[key2])) {
                o[key2].push({});
              } else {
                o[key2] = [o[key2], {}];
              }
              o = o[key2][o[key2].length - 1];
            } else {
              o = o[key2];
            }
          });
          const key = sanitizeKey(keys[keys.length - 1]);
          const isTypeArray = checkAllAliases(keys.join("."), flags.arrays);
          const isValueArray = Array.isArray(value);
          let duplicate = configuration["duplicate-arguments-array"];
          if (!duplicate && checkAllAliases(key, flags.nargs)) {
            duplicate = true;
            if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {
              o[key] = void 0;
            }
          }
          if (value === increment()) {
            o[key] = increment(o[key]);
          } else if (Array.isArray(o[key])) {
            if (duplicate && isTypeArray && isValueArray) {
              o[key] = configuration["flatten-duplicate-arrays"] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
            } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
              o[key] = value;
            } else {
              o[key] = o[key].concat([value]);
            }
          } else if (o[key] === void 0 && isTypeArray) {
            o[key] = isValueArray ? value : [value];
          } else if (duplicate && !(o[key] === void 0 || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
            o[key] = [o[key], value];
          } else {
            o[key] = value;
          }
        }
        function extendAliases(...args2) {
          args2.forEach(function(obj) {
            Object.keys(obj || {}).forEach(function(key) {
              if (flags.aliases[key])
                return;
              flags.aliases[key] = [].concat(aliases[key] || []);
              flags.aliases[key].concat(key).forEach(function(x) {
                if (/-/.test(x) && configuration["camel-case-expansion"]) {
                  const c = camelCase(x);
                  if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                    flags.aliases[key].push(c);
                    newAliases[c] = true;
                  }
                }
              });
              flags.aliases[key].concat(key).forEach(function(x) {
                if (x.length > 1 && /[A-Z]/.test(x) && configuration["camel-case-expansion"]) {
                  const c = decamelize(x, "-");
                  if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                    flags.aliases[key].push(c);
                    newAliases[c] = true;
                  }
                }
              });
              flags.aliases[key].forEach(function(x) {
                flags.aliases[x] = [key].concat(flags.aliases[key].filter(function(y) {
                  return x !== y;
                }));
              });
            });
          });
        }
        function checkAllAliases(key, flag) {
          const toCheck = [].concat(flags.aliases[key] || [], key);
          const keys = Object.keys(flag);
          const setAlias = toCheck.find((key2) => keys.includes(key2));
          return setAlias ? flag[setAlias] : false;
        }
        function hasAnyFlag(key) {
          const flagsKeys = Object.keys(flags);
          const toCheck = [].concat(flagsKeys.map((k) => flags[k]));
          return toCheck.some(function(flag) {
            return Array.isArray(flag) ? flag.includes(key) : flag[key];
          });
        }
        function hasFlagsMatching(arg, ...patterns) {
          const toCheck = [].concat(...patterns);
          return toCheck.some(function(pattern) {
            const match = arg.match(pattern);
            return match && hasAnyFlag(match[1]);
          });
        }
        function hasAllShortFlags(arg) {
          if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
            return false;
          }
          let hasAllFlags = true;
          let next;
          const letters = arg.slice(1).split("");
          for (let j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2);
            if (!hasAnyFlag(letters[j])) {
              hasAllFlags = false;
              break;
            }
            if (letters[j + 1] && letters[j + 1] === "=" || next === "-" || /[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\W/)) {
              break;
            }
          }
          return hasAllFlags;
        }
        function isUnknownOptionAsArg(arg) {
          return configuration["unknown-options-as-args"] && isUnknownOption(arg);
        }
        function isUnknownOption(arg) {
          arg = arg.replace(/^-{3,}/, "--");
          if (arg.match(negative)) {
            return false;
          }
          if (hasAllShortFlags(arg)) {
            return false;
          }
          const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
          const normalFlag = /^-+([^=]+?)$/;
          const flagEndingInHyphen = /^-+([^=]+?)-$/;
          const flagEndingInDigits = /^-+([^=]+?\d+)$/;
          const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
          return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
        }
        function defaultValue(key) {
          if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {
            return defaults[key];
          } else {
            return defaultForType(guessType(key));
          }
        }
        function defaultForType(type) {
          const def = {
            [DefaultValuesForTypeKey.BOOLEAN]: true,
            [DefaultValuesForTypeKey.STRING]: "",
            [DefaultValuesForTypeKey.NUMBER]: void 0,
            [DefaultValuesForTypeKey.ARRAY]: []
          };
          return def[type];
        }
        function guessType(key) {
          let type = DefaultValuesForTypeKey.BOOLEAN;
          if (checkAllAliases(key, flags.strings))
            type = DefaultValuesForTypeKey.STRING;
          else if (checkAllAliases(key, flags.numbers))
            type = DefaultValuesForTypeKey.NUMBER;
          else if (checkAllAliases(key, flags.bools))
            type = DefaultValuesForTypeKey.BOOLEAN;
          else if (checkAllAliases(key, flags.arrays))
            type = DefaultValuesForTypeKey.ARRAY;
          return type;
        }
        function isUndefined(num) {
          return num === void 0;
        }
        function checkConfiguration() {
          Object.keys(flags.counts).find((key) => {
            if (checkAllAliases(key, flags.arrays)) {
              error = Error(__("Invalid configuration: %s, opts.count excludes opts.array.", key));
              return true;
            } else if (checkAllAliases(key, flags.nargs)) {
              error = Error(__("Invalid configuration: %s, opts.count excludes opts.narg.", key));
              return true;
            }
            return false;
          });
        }
        return {
          aliases: Object.assign({}, flags.aliases),
          argv: Object.assign(argvReturn, argv),
          configuration,
          defaulted: Object.assign({}, defaulted),
          error,
          newAliases: Object.assign({}, newAliases)
        };
      }
    };
    function combineAliases(aliases) {
      const aliasArrays = [];
      const combined = /* @__PURE__ */ Object.create(null);
      let change = true;
      Object.keys(aliases).forEach(function(key) {
        aliasArrays.push([].concat(aliases[key], key));
      });
      while (change) {
        change = false;
        for (let i = 0; i < aliasArrays.length; i++) {
          for (let ii = i + 1; ii < aliasArrays.length; ii++) {
            const intersect = aliasArrays[i].filter(function(v) {
              return aliasArrays[ii].indexOf(v) !== -1;
            });
            if (intersect.length) {
              aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
              aliasArrays.splice(ii, 1);
              change = true;
              break;
            }
          }
        }
      }
      aliasArrays.forEach(function(aliasArray) {
        aliasArray = aliasArray.filter(function(v, i, self2) {
          return self2.indexOf(v) === i;
        });
        const lastAlias = aliasArray.pop();
        if (lastAlias !== void 0 && typeof lastAlias === "string") {
          combined[lastAlias] = aliasArray;
        }
      });
      return combined;
    }
    function increment(orig) {
      return orig !== void 0 ? orig + 1 : 1;
    }
    function sanitizeKey(key) {
      if (key === "__proto__")
        return "___proto___";
      return key;
    }
    var minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 10;
    if (process && process.version) {
      const major = Number(process.version.match(/v([^.]+)/)[1]);
      if (major < minNodeVersion) {
        throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
      }
    }
    var env = process ? process.env : {};
    var parser = new YargsParser({
      cwd: process.cwd,
      env: () => {
        return env;
      },
      format: util.format,
      normalize: path.normalize,
      resolve: path.resolve,
      require: (path2) => {
        if (typeof require !== "undefined") {
          return require(path2);
        } else if (path2.match(/\.json$/)) {
          return fs.readFileSync(path2, "utf8");
        } else {
          throw Error("only .json config files are supported in ESM");
        }
      }
    });
    var yargsParser = function Parser(args, opts) {
      const result = parser.parse(args.slice(), opts);
      return result.argv;
    };
    yargsParser.detailed = function(args, opts) {
      return parser.parse(args.slice(), opts);
    };
    yargsParser.camelCase = camelCase;
    yargsParser.decamelize = decamelize;
    yargsParser.looksLikeNumber = looksLikeNumber;
    module2.exports = yargsParser;
  }
});

// node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "node_modules/ansi-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "node_modules/strip-ansi/index.js"(exports2, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex();
    module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
  }
});

// node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS({
  "node_modules/is-fullwidth-code-point/index.js"(exports2, module2) {
    "use strict";
    var isFullwidthCodePoint = (codePoint) => {
      if (Number.isNaN(codePoint)) {
        return false;
      }
      if (codePoint >= 4352 && (codePoint <= 4447 || // Hangul Jamo
      codePoint === 9001 || // LEFT-POINTING ANGLE BRACKET
      codePoint === 9002 || // RIGHT-POINTING ANGLE BRACKET
      // CJK Radicals Supplement .. Enclosed CJK Letters and Months
      11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
      12880 <= codePoint && codePoint <= 19903 || // CJK Unified Ideographs .. Yi Radicals
      19968 <= codePoint && codePoint <= 42182 || // Hangul Jamo Extended-A
      43360 <= codePoint && codePoint <= 43388 || // Hangul Syllables
      44032 <= codePoint && codePoint <= 55203 || // CJK Compatibility Ideographs
      63744 <= codePoint && codePoint <= 64255 || // Vertical Forms
      65040 <= codePoint && codePoint <= 65049 || // CJK Compatibility Forms .. Small Form Variants
      65072 <= codePoint && codePoint <= 65131 || // Halfwidth and Fullwidth Forms
      65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || // Kana Supplement
      110592 <= codePoint && codePoint <= 110593 || // Enclosed Ideographic Supplement
      127488 <= codePoint && codePoint <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
      131072 <= codePoint && codePoint <= 262141)) {
        return true;
      }
      return false;
    };
    module2.exports = isFullwidthCodePoint;
    module2.exports.default = isFullwidthCodePoint;
  }
});

// node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS({
  "node_modules/emoji-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
  }
});

// node_modules/string-width/index.js
var require_string_width = __commonJS({
  "node_modules/string-width/index.js"(exports2, module2) {
    "use strict";
    var stripAnsi = require_strip_ansi();
    var isFullwidthCodePoint = require_is_fullwidth_code_point();
    var emojiRegex = require_emoji_regex();
    var stringWidth = (string) => {
      if (typeof string !== "string" || string.length === 0) {
        return 0;
      }
      string = stripAnsi(string);
      if (string.length === 0) {
        return 0;
      }
      string = string.replace(emojiRegex(), "  ");
      let width = 0;
      for (let i = 0; i < string.length; i++) {
        const code = string.codePointAt(i);
        if (code <= 31 || code >= 127 && code <= 159) {
          continue;
        }
        if (code >= 768 && code <= 879) {
          continue;
        }
        if (code > 65535) {
          i++;
        }
        width += isFullwidthCodePoint(code) ? 2 : 1;
      }
      return width;
    };
    module2.exports = stringWidth;
    module2.exports.default = stringWidth;
  }
});

// node_modules/wrap-ansi/node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "node_modules/wrap-ansi/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/wrap-ansi/node_modules/color-convert/conversions.js
var require_conversions2 = __commonJS({
  "node_modules/wrap-ansi/node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/wrap-ansi/node_modules/color-convert/route.js
var require_route2 = __commonJS({
  "node_modules/wrap-ansi/node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions2();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/wrap-ansi/node_modules/color-convert/index.js
var require_color_convert2 = __commonJS({
  "node_modules/wrap-ansi/node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions2();
    var route = require_route2();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/wrap-ansi/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/wrap-ansi/node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert2();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/wrap-ansi/index.js
var require_wrap_ansi = __commonJS({
  "node_modules/wrap-ansi/index.js"(exports2, module2) {
    "use strict";
    var stringWidth = require_string_width();
    var stripAnsi = require_strip_ansi();
    var ansiStyles = require_ansi_styles();
    var ESCAPES = /* @__PURE__ */ new Set([
      "\x1B",
      "\x9B"
    ]);
    var END_CODE = 39;
    var ANSI_ESCAPE_BELL = "\x07";
    var ANSI_CSI = "[";
    var ANSI_OSC = "]";
    var ANSI_SGR_TERMINATOR = "m";
    var ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;
    var wrapAnsi = (code) => `${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;
    var wrapAnsiHyperlink = (uri) => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${uri}${ANSI_ESCAPE_BELL}`;
    var wordLengths = (string) => string.split(" ").map((character) => stringWidth(character));
    var wrapWord = (rows, word, columns) => {
      const characters = [...word];
      let isInsideEscape = false;
      let isInsideLinkEscape = false;
      let visible = stringWidth(stripAnsi(rows[rows.length - 1]));
      for (const [index, character] of characters.entries()) {
        const characterLength = stringWidth(character);
        if (visible + characterLength <= columns) {
          rows[rows.length - 1] += character;
        } else {
          rows.push(character);
          visible = 0;
        }
        if (ESCAPES.has(character)) {
          isInsideEscape = true;
          isInsideLinkEscape = characters.slice(index + 1).join("").startsWith(ANSI_ESCAPE_LINK);
        }
        if (isInsideEscape) {
          if (isInsideLinkEscape) {
            if (character === ANSI_ESCAPE_BELL) {
              isInsideEscape = false;
              isInsideLinkEscape = false;
            }
          } else if (character === ANSI_SGR_TERMINATOR) {
            isInsideEscape = false;
          }
          continue;
        }
        visible += characterLength;
        if (visible === columns && index < characters.length - 1) {
          rows.push("");
          visible = 0;
        }
      }
      if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
        rows[rows.length - 2] += rows.pop();
      }
    };
    var stringVisibleTrimSpacesRight = (string) => {
      const words = string.split(" ");
      let last = words.length;
      while (last > 0) {
        if (stringWidth(words[last - 1]) > 0) {
          break;
        }
        last--;
      }
      if (last === words.length) {
        return string;
      }
      return words.slice(0, last).join(" ") + words.slice(last).join("");
    };
    var exec = (string, columns, options = {}) => {
      if (options.trim !== false && string.trim() === "") {
        return "";
      }
      let returnValue = "";
      let escapeCode;
      let escapeUrl;
      const lengths = wordLengths(string);
      let rows = [""];
      for (const [index, word] of string.split(" ").entries()) {
        if (options.trim !== false) {
          rows[rows.length - 1] = rows[rows.length - 1].trimStart();
        }
        let rowLength = stringWidth(rows[rows.length - 1]);
        if (index !== 0) {
          if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
            rows.push("");
            rowLength = 0;
          }
          if (rowLength > 0 || options.trim === false) {
            rows[rows.length - 1] += " ";
            rowLength++;
          }
        }
        if (options.hard && lengths[index] > columns) {
          const remainingColumns = columns - rowLength;
          const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
          const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
          if (breaksStartingNextLine < breaksStartingThisLine) {
            rows.push("");
          }
          wrapWord(rows, word, columns);
          continue;
        }
        if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
          if (options.wordWrap === false && rowLength < columns) {
            wrapWord(rows, word, columns);
            continue;
          }
          rows.push("");
        }
        if (rowLength + lengths[index] > columns && options.wordWrap === false) {
          wrapWord(rows, word, columns);
          continue;
        }
        rows[rows.length - 1] += word;
      }
      if (options.trim !== false) {
        rows = rows.map(stringVisibleTrimSpacesRight);
      }
      const pre = [...rows.join("\n")];
      for (const [index, character] of pre.entries()) {
        returnValue += character;
        if (ESCAPES.has(character)) {
          const { groups } = new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(pre.slice(index).join("")) || { groups: {} };
          if (groups.code !== void 0) {
            const code2 = Number.parseFloat(groups.code);
            escapeCode = code2 === END_CODE ? void 0 : code2;
          } else if (groups.uri !== void 0) {
            escapeUrl = groups.uri.length === 0 ? void 0 : groups.uri;
          }
        }
        const code = ansiStyles.codes.get(Number(escapeCode));
        if (pre[index + 1] === "\n") {
          if (escapeUrl) {
            returnValue += wrapAnsiHyperlink("");
          }
          if (escapeCode && code) {
            returnValue += wrapAnsi(code);
          }
        } else if (character === "\n") {
          if (escapeCode && code) {
            returnValue += wrapAnsi(escapeCode);
          }
          if (escapeUrl) {
            returnValue += wrapAnsiHyperlink(escapeUrl);
          }
        }
      }
      return returnValue;
    };
    module2.exports = (string, columns, options) => {
      return String(string).normalize().replace(/\r\n/g, "\n").split("\n").map((line) => exec(line, columns, options)).join("\n");
    };
  }
});

// node_modules/cliui/build/index.cjs
var require_build4 = __commonJS({
  "node_modules/cliui/build/index.cjs"(exports2, module2) {
    "use strict";
    var align = {
      right: alignRight,
      center: alignCenter
    };
    var top = 0;
    var right = 1;
    var bottom = 2;
    var left = 3;
    var UI = class {
      constructor(opts) {
        var _a;
        this.width = opts.width;
        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;
        this.rows = [];
      }
      span(...args) {
        const cols = this.div(...args);
        cols.span = true;
      }
      resetOutput() {
        this.rows = [];
      }
      div(...args) {
        if (args.length === 0) {
          this.div("");
        }
        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === "string") {
          return this.applyLayoutDSL(args[0]);
        }
        const cols = args.map((arg) => {
          if (typeof arg === "string") {
            return this.colFromString(arg);
          }
          return arg;
        });
        this.rows.push(cols);
        return cols;
      }
      shouldApplyLayoutDSL(...args) {
        return args.length === 1 && typeof args[0] === "string" && /[\t\n]/.test(args[0]);
      }
      applyLayoutDSL(str) {
        const rows = str.split("\n").map((row) => row.split("	"));
        let leftColumnWidth = 0;
        rows.forEach((columns) => {
          if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
            leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
          }
        });
        rows.forEach((columns) => {
          this.div(...columns.map((r, i) => {
            return {
              text: r.trim(),
              padding: this.measurePadding(r),
              width: i === 0 && columns.length > 1 ? leftColumnWidth : void 0
            };
          }));
        });
        return this.rows[this.rows.length - 1];
      }
      colFromString(text) {
        return {
          text,
          padding: this.measurePadding(text)
        };
      }
      measurePadding(str) {
        const noAnsi = mixin.stripAnsi(str);
        return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
      }
      toString() {
        const lines = [];
        this.rows.forEach((row) => {
          this.rowToString(row, lines);
        });
        return lines.filter((line) => !line.hidden).map((line) => line.text).join("\n");
      }
      rowToString(row, lines) {
        this.rasterize(row).forEach((rrow, r) => {
          let str = "";
          rrow.forEach((col, c) => {
            const { width } = row[c];
            const wrapWidth = this.negatePadding(row[c]);
            let ts = col;
            if (wrapWidth > mixin.stringWidth(col)) {
              ts += " ".repeat(wrapWidth - mixin.stringWidth(col));
            }
            if (row[c].align && row[c].align !== "left" && this.wrap) {
              const fn = align[row[c].align];
              ts = fn(ts, wrapWidth);
              if (mixin.stringWidth(ts) < wrapWidth) {
                ts += " ".repeat((width || 0) - mixin.stringWidth(ts) - 1);
              }
            }
            const padding = row[c].padding || [0, 0, 0, 0];
            if (padding[left]) {
              str += " ".repeat(padding[left]);
            }
            str += addBorder(row[c], ts, "| ");
            str += ts;
            str += addBorder(row[c], ts, " |");
            if (padding[right]) {
              str += " ".repeat(padding[right]);
            }
            if (r === 0 && lines.length > 0) {
              str = this.renderInline(str, lines[lines.length - 1]);
            }
          });
          lines.push({
            text: str.replace(/ +$/, ""),
            span: row.span
          });
        });
        return lines;
      }
      // if the full 'source' can render in
      // the target line, do so.
      renderInline(source, previousLine) {
        const match = source.match(/^ */);
        const leadingWhitespace = match ? match[0].length : 0;
        const target = previousLine.text;
        const targetTextWidth = mixin.stringWidth(target.trimRight());
        if (!previousLine.span) {
          return source;
        }
        if (!this.wrap) {
          previousLine.hidden = true;
          return target + source;
        }
        if (leadingWhitespace < targetTextWidth) {
          return source;
        }
        previousLine.hidden = true;
        return target.trimRight() + " ".repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
      }
      rasterize(row) {
        const rrows = [];
        const widths = this.columnWidths(row);
        let wrapped;
        row.forEach((col, c) => {
          col.width = widths[c];
          if (this.wrap) {
            wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split("\n");
          } else {
            wrapped = col.text.split("\n");
          }
          if (col.border) {
            wrapped.unshift("." + "-".repeat(this.negatePadding(col) + 2) + ".");
            wrapped.push("'" + "-".repeat(this.negatePadding(col) + 2) + "'");
          }
          if (col.padding) {
            wrapped.unshift(...new Array(col.padding[top] || 0).fill(""));
            wrapped.push(...new Array(col.padding[bottom] || 0).fill(""));
          }
          wrapped.forEach((str, r) => {
            if (!rrows[r]) {
              rrows.push([]);
            }
            const rrow = rrows[r];
            for (let i = 0; i < c; i++) {
              if (rrow[i] === void 0) {
                rrow.push("");
              }
            }
            rrow.push(str);
          });
        });
        return rrows;
      }
      negatePadding(col) {
        let wrapWidth = col.width || 0;
        if (col.padding) {
          wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
        }
        if (col.border) {
          wrapWidth -= 4;
        }
        return wrapWidth;
      }
      columnWidths(row) {
        if (!this.wrap) {
          return row.map((col) => {
            return col.width || mixin.stringWidth(col.text);
          });
        }
        let unset = row.length;
        let remainingWidth = this.width;
        const widths = row.map((col) => {
          if (col.width) {
            unset--;
            remainingWidth -= col.width;
            return col.width;
          }
          return void 0;
        });
        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
        return widths.map((w, i) => {
          if (w === void 0) {
            return Math.max(unsetWidth, _minWidth(row[i]));
          }
          return w;
        });
      }
    };
    function addBorder(col, ts, style) {
      if (col.border) {
        if (/[.']-+[.']/.test(ts)) {
          return "";
        }
        if (ts.trim().length !== 0) {
          return style;
        }
        return "  ";
      }
      return "";
    }
    function _minWidth(col) {
      const padding = col.padding || [];
      const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
      if (col.border) {
        return minWidth + 4;
      }
      return minWidth;
    }
    function getWindowWidth() {
      if (typeof process === "object" && process.stdout && process.stdout.columns) {
        return process.stdout.columns;
      }
      return 80;
    }
    function alignRight(str, width) {
      str = str.trim();
      const strWidth = mixin.stringWidth(str);
      if (strWidth < width) {
        return " ".repeat(width - strWidth) + str;
      }
      return str;
    }
    function alignCenter(str, width) {
      str = str.trim();
      const strWidth = mixin.stringWidth(str);
      if (strWidth >= width) {
        return str;
      }
      return " ".repeat(width - strWidth >> 1) + str;
    }
    var mixin;
    function cliui(opts, _mixin) {
      mixin = _mixin;
      return new UI({
        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),
        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap
      });
    }
    var stringWidth = require_string_width();
    var stripAnsi = require_strip_ansi();
    var wrap = require_wrap_ansi();
    function ui(opts) {
      return cliui(opts, {
        stringWidth,
        stripAnsi,
        wrap
      });
    }
    module2.exports = ui;
  }
});

// node_modules/escalade/sync/index.js
var require_sync = __commonJS({
  "node_modules/escalade/sync/index.js"(exports2, module2) {
    var { dirname, resolve } = require("path");
    var { readdirSync, statSync } = require("fs");
    module2.exports = function(start, callback) {
      let dir = resolve(".", start);
      let tmp, stats = statSync(dir);
      if (!stats.isDirectory()) {
        dir = dirname(dir);
      }
      while (true) {
        tmp = callback(dir, readdirSync(dir));
        if (tmp) return resolve(dir, tmp);
        dir = dirname(tmp = dir);
        if (tmp === dir) break;
      }
    };
  }
});

// node_modules/get-caller-file/index.js
var require_get_caller_file = __commonJS({
  "node_modules/get-caller-file/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function getCallerFile(position) {
      if (position === void 0) {
        position = 2;
      }
      if (position >= Error.stackTraceLimit) {
        throw new TypeError("getCallerFile(position) requires position be less then Error.stackTraceLimit but position was: `" + position + "` and Error.stackTraceLimit was: `" + Error.stackTraceLimit + "`");
      }
      var oldPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = oldPrepareStackTrace;
      if (stack !== null && typeof stack === "object") {
        return stack[position] ? stack[position].getFileName() : void 0;
      }
    };
  }
});

// node_modules/require-directory/index.js
var require_require_directory = __commonJS({
  "node_modules/require-directory/index.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var join = require("path").join;
    var resolve = require("path").resolve;
    var dirname = require("path").dirname;
    var defaultOptions = {
      extensions: ["js", "json", "coffee"],
      recurse: true,
      rename: function(name) {
        return name;
      },
      visit: function(obj) {
        return obj;
      }
    };
    function checkFileInclusion(path, filename, options) {
      return (
        // verify file has valid extension
        new RegExp("\\.(" + options.extensions.join("|") + ")$", "i").test(filename) && // if options.include is a RegExp, evaluate it and make sure the path passes
        !(options.include && options.include instanceof RegExp && !options.include.test(path)) && // if options.include is a function, evaluate it and make sure the path passes
        !(options.include && typeof options.include === "function" && !options.include(path, filename)) && // if options.exclude is a RegExp, evaluate it and make sure the path doesn't pass
        !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) && // if options.exclude is a function, evaluate it and make sure the path doesn't pass
        !(options.exclude && typeof options.exclude === "function" && options.exclude(path, filename))
      );
    }
    function requireDirectory(m, path, options) {
      var retval = {};
      if (path && !options && typeof path !== "string") {
        options = path;
        path = null;
      }
      options = options || {};
      for (var prop in defaultOptions) {
        if (typeof options[prop] === "undefined") {
          options[prop] = defaultOptions[prop];
        }
      }
      path = !path ? dirname(m.filename) : resolve(dirname(m.filename), path);
      fs.readdirSync(path).forEach(function(filename) {
        var joined = join(path, filename), files, key, obj;
        if (fs.statSync(joined).isDirectory() && options.recurse) {
          files = requireDirectory(m, joined, options);
          if (Object.keys(files).length) {
            retval[options.rename(filename, joined, filename)] = files;
          }
        } else {
          if (joined !== m.filename && checkFileInclusion(joined, filename, options)) {
            key = filename.substring(0, filename.lastIndexOf("."));
            obj = m.require(joined);
            retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;
          }
        }
      });
      return retval;
    }
    module2.exports = requireDirectory;
    module2.exports.defaults = defaultOptions;
  }
});

// node_modules/yargs/build/index.cjs
var require_build5 = __commonJS({
  "node_modules/yargs/build/index.cjs"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var YError = class _YError extends Error {
      constructor(msg) {
        super(msg || "yargs error");
        this.name = "YError";
        Error.captureStackTrace(this, _YError);
      }
    };
    var previouslyVisitedConfigs = [];
    var shim;
    function applyExtends(config, cwd, mergeExtends, _shim) {
      shim = _shim;
      let defaultConfig = {};
      if (Object.prototype.hasOwnProperty.call(config, "extends")) {
        if (typeof config.extends !== "string")
          return defaultConfig;
        const isPath = /\.json|\..*rc$/.test(config.extends);
        let pathToDefault = null;
        if (!isPath) {
          try {
            pathToDefault = require.resolve(config.extends);
          } catch (_err) {
            return config;
          }
        } else {
          pathToDefault = getPathToDefaultConfig(cwd, config.extends);
        }
        checkForCircularExtends(pathToDefault);
        previouslyVisitedConfigs.push(pathToDefault);
        defaultConfig = isPath ? JSON.parse(shim.readFileSync(pathToDefault, "utf8")) : require(config.extends);
        delete config.extends;
        defaultConfig = applyExtends(defaultConfig, shim.path.dirname(pathToDefault), mergeExtends, shim);
      }
      previouslyVisitedConfigs = [];
      return mergeExtends ? mergeDeep(defaultConfig, config) : Object.assign({}, defaultConfig, config);
    }
    function checkForCircularExtends(cfgPath) {
      if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {
        throw new YError(`Circular extended configurations: '${cfgPath}'.`);
      }
    }
    function getPathToDefaultConfig(cwd, pathToExtend) {
      return shim.path.resolve(cwd, pathToExtend);
    }
    function mergeDeep(config1, config2) {
      const target = {};
      function isObject(obj) {
        return obj && typeof obj === "object" && !Array.isArray(obj);
      }
      Object.assign(target, config1);
      for (const key of Object.keys(config2)) {
        if (isObject(config2[key]) && isObject(target[key])) {
          target[key] = mergeDeep(config1[key], config2[key]);
        } else {
          target[key] = config2[key];
        }
      }
      return target;
    }
    function parseCommand(cmd) {
      const extraSpacesStrippedCommand = cmd.replace(/\s{2,}/g, " ");
      const splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/);
      const bregex = /\.*[\][<>]/g;
      const firstCommand = splitCommand.shift();
      if (!firstCommand)
        throw new Error(`No command found in: ${cmd}`);
      const parsedCommand = {
        cmd: firstCommand.replace(bregex, ""),
        demanded: [],
        optional: []
      };
      splitCommand.forEach((cmd2, i) => {
        let variadic = false;
        cmd2 = cmd2.replace(/\s/g, "");
        if (/\.+[\]>]/.test(cmd2) && i === splitCommand.length - 1)
          variadic = true;
        if (/^\[/.test(cmd2)) {
          parsedCommand.optional.push({
            cmd: cmd2.replace(bregex, "").split("|"),
            variadic
          });
        } else {
          parsedCommand.demanded.push({
            cmd: cmd2.replace(bregex, "").split("|"),
            variadic
          });
        }
      });
      return parsedCommand;
    }
    var positionName = ["first", "second", "third", "fourth", "fifth", "sixth"];
    function argsert(arg1, arg2, arg3) {
      function parseArgs() {
        return typeof arg1 === "object" ? [{ demanded: [], optional: [] }, arg1, arg2] : [
          parseCommand(`cmd ${arg1}`),
          arg2,
          arg3
        ];
      }
      try {
        let position = 0;
        const [parsed, callerArguments, _length] = parseArgs();
        const args = [].slice.call(callerArguments);
        while (args.length && args[args.length - 1] === void 0)
          args.pop();
        const length = _length || args.length;
        if (length < parsed.demanded.length) {
          throw new YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);
        }
        const totalCommands = parsed.demanded.length + parsed.optional.length;
        if (length > totalCommands) {
          throw new YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);
        }
        parsed.demanded.forEach((demanded) => {
          const arg = args.shift();
          const observedType = guessType(arg);
          const matchingTypes = demanded.cmd.filter((type) => type === observedType || type === "*");
          if (matchingTypes.length === 0)
            argumentTypeError(observedType, demanded.cmd, position);
          position += 1;
        });
        parsed.optional.forEach((optional) => {
          if (args.length === 0)
            return;
          const arg = args.shift();
          const observedType = guessType(arg);
          const matchingTypes = optional.cmd.filter((type) => type === observedType || type === "*");
          if (matchingTypes.length === 0)
            argumentTypeError(observedType, optional.cmd, position);
          position += 1;
        });
      } catch (err) {
        console.warn(err.stack);
      }
    }
    function guessType(arg) {
      if (Array.isArray(arg)) {
        return "array";
      } else if (arg === null) {
        return "null";
      }
      return typeof arg;
    }
    function argumentTypeError(observedType, allowedTypes, position) {
      throw new YError(`Invalid ${positionName[position] || "manyith"} argument. Expected ${allowedTypes.join(" or ")} but received ${observedType}.`);
    }
    function isPromise(maybePromise) {
      return !!maybePromise && !!maybePromise.then && typeof maybePromise.then === "function";
    }
    function assertNotStrictEqual(actual, expected, shim2, message) {
      shim2.assert.notStrictEqual(actual, expected, message);
    }
    function assertSingleKey(actual, shim2) {
      shim2.assert.strictEqual(typeof actual, "string");
    }
    function objectKeys(object) {
      return Object.keys(object);
    }
    function objFilter(original = {}, filter = () => true) {
      const obj = {};
      objectKeys(original).forEach((key) => {
        if (filter(key, original[key])) {
          obj[key] = original[key];
        }
      });
      return obj;
    }
    function globalMiddlewareFactory(globalMiddleware, context) {
      return function(callback, applyBeforeValidation = false) {
        argsert("<array|function> [boolean]", [callback, applyBeforeValidation], arguments.length);
        if (Array.isArray(callback)) {
          for (let i = 0; i < callback.length; i++) {
            if (typeof callback[i] !== "function") {
              throw Error("middleware must be a function");
            }
            callback[i].applyBeforeValidation = applyBeforeValidation;
          }
          Array.prototype.push.apply(globalMiddleware, callback);
        } else if (typeof callback === "function") {
          callback.applyBeforeValidation = applyBeforeValidation;
          globalMiddleware.push(callback);
        }
        return context;
      };
    }
    function commandMiddlewareFactory(commandMiddleware) {
      if (!commandMiddleware)
        return [];
      return commandMiddleware.map((middleware) => {
        middleware.applyBeforeValidation = false;
        return middleware;
      });
    }
    function applyMiddleware(argv, yargs, middlewares, beforeValidation) {
      const beforeValidationError = new Error("middleware cannot return a promise when applyBeforeValidation is true");
      return middlewares.reduce((acc, middleware) => {
        if (middleware.applyBeforeValidation !== beforeValidation) {
          return acc;
        }
        if (isPromise(acc)) {
          return acc.then((initialObj) => Promise.all([
            initialObj,
            middleware(initialObj, yargs)
          ])).then(([initialObj, middlewareObj]) => Object.assign(initialObj, middlewareObj));
        } else {
          const result = middleware(acc, yargs);
          if (beforeValidation && isPromise(result))
            throw beforeValidationError;
          return isPromise(result) ? result.then((middlewareObj) => Object.assign(acc, middlewareObj)) : Object.assign(acc, result);
        }
      }, argv);
    }
    function getProcessArgvBinIndex() {
      if (isBundledElectronApp())
        return 0;
      return 1;
    }
    function isBundledElectronApp() {
      return isElectronApp() && !process.defaultApp;
    }
    function isElectronApp() {
      return !!process.versions.electron;
    }
    function hideBin(argv) {
      return argv.slice(getProcessArgvBinIndex() + 1);
    }
    function getProcessArgvBin() {
      return process.argv[getProcessArgvBinIndex()];
    }
    var processArgv = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      hideBin,
      getProcessArgvBin
    });
    function whichModule(exported) {
      if (typeof require === "undefined")
        return null;
      for (let i = 0, files = Object.keys(require.cache), mod; i < files.length; i++) {
        mod = require.cache[files[i]];
        if (mod.exports === exported)
          return mod;
      }
      return null;
    }
    var DEFAULT_MARKER = /(^\*)|(^\$0)/;
    function command(yargs, usage2, validation2, globalMiddleware = [], shim2) {
      const self2 = {};
      let handlers = {};
      let aliasMap = {};
      let defaultCommand;
      self2.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {
        let aliases = [];
        const middlewares = commandMiddlewareFactory(commandMiddleware);
        handler = handler || (() => {
        });
        if (Array.isArray(cmd)) {
          if (isCommandAndAliases(cmd)) {
            [cmd, ...aliases] = cmd;
          } else {
            for (const command2 of cmd) {
              self2.addHandler(command2);
            }
          }
        } else if (isCommandHandlerDefinition(cmd)) {
          let command2 = Array.isArray(cmd.command) || typeof cmd.command === "string" ? cmd.command : moduleName(cmd);
          if (cmd.aliases)
            command2 = [].concat(command2).concat(cmd.aliases);
          self2.addHandler(command2, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);
          return;
        } else if (isCommandBuilderDefinition(builder)) {
          self2.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);
          return;
        }
        if (typeof cmd === "string") {
          const parsedCommand = parseCommand(cmd);
          aliases = aliases.map((alias) => parseCommand(alias).cmd);
          let isDefault = false;
          const parsedAliases = [parsedCommand.cmd].concat(aliases).filter((c) => {
            if (DEFAULT_MARKER.test(c)) {
              isDefault = true;
              return false;
            }
            return true;
          });
          if (parsedAliases.length === 0 && isDefault)
            parsedAliases.push("$0");
          if (isDefault) {
            parsedCommand.cmd = parsedAliases[0];
            aliases = parsedAliases.slice(1);
            cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
          }
          aliases.forEach((alias) => {
            aliasMap[alias] = parsedCommand.cmd;
          });
          if (description !== false) {
            usage2.command(cmd, description, isDefault, aliases, deprecated);
          }
          handlers[parsedCommand.cmd] = {
            original: cmd,
            description,
            handler,
            builder: builder || {},
            middlewares,
            deprecated,
            demanded: parsedCommand.demanded,
            optional: parsedCommand.optional
          };
          if (isDefault)
            defaultCommand = handlers[parsedCommand.cmd];
        }
      };
      self2.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {
        opts = opts || {};
        if (typeof opts.recurse !== "boolean")
          opts.recurse = false;
        if (!Array.isArray(opts.extensions))
          opts.extensions = ["js"];
        const parentVisit = typeof opts.visit === "function" ? opts.visit : (o) => o;
        opts.visit = function visit(obj, joined, filename) {
          const visited = parentVisit(obj, joined, filename);
          if (visited) {
            if (~context.files.indexOf(joined))
              return visited;
            context.files.push(joined);
            self2.addHandler(visited);
          }
          return visited;
        };
        shim2.requireDirectory({ require: req, filename: callerFile }, dir, opts);
      };
      function moduleName(obj) {
        const mod = whichModule(obj);
        if (!mod)
          throw new Error(`No command name given for module: ${shim2.inspect(obj)}`);
        return commandFromFilename(mod.filename);
      }
      function commandFromFilename(filename) {
        return shim2.path.basename(filename, shim2.path.extname(filename));
      }
      function extractDesc({ describe: describe2, description, desc }) {
        for (const test of [describe2, description, desc]) {
          if (typeof test === "string" || test === false)
            return test;
          assertNotStrictEqual(test, true, shim2);
        }
        return false;
      }
      self2.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap));
      self2.getCommandHandlers = () => handlers;
      self2.hasDefaultCommand = () => !!defaultCommand;
      self2.runCommand = function runCommand(command2, yargs2, parsed, commandIndex) {
        let aliases = parsed.aliases;
        const commandHandler = handlers[command2] || handlers[aliasMap[command2]] || defaultCommand;
        const currentContext = yargs2.getContext();
        let numFiles = currentContext.files.length;
        const parentCommands = currentContext.commands.slice();
        let innerArgv = parsed.argv;
        let positionalMap = {};
        if (command2) {
          currentContext.commands.push(command2);
          currentContext.fullCommands.push(commandHandler.original);
        }
        const builder = commandHandler.builder;
        if (isCommandBuilderCallback(builder)) {
          const builderOutput = builder(yargs2.reset(parsed.aliases));
          const innerYargs = isYargsInstance(builderOutput) ? builderOutput : yargs2;
          if (shouldUpdateUsage(innerYargs)) {
            innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
          }
          innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);
          aliases = innerYargs.parsed.aliases;
        } else if (isCommandBuilderOptionDefinitions(builder)) {
          const innerYargs = yargs2.reset(parsed.aliases);
          if (shouldUpdateUsage(innerYargs)) {
            innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
          }
          Object.keys(commandHandler.builder).forEach((key) => {
            innerYargs.option(key, builder[key]);
          });
          innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);
          aliases = innerYargs.parsed.aliases;
        }
        if (!yargs2._hasOutput()) {
          positionalMap = populatePositionals(commandHandler, innerArgv, currentContext);
        }
        const middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares);
        applyMiddleware(innerArgv, yargs2, middlewares, true);
        if (!yargs2._hasOutput()) {
          yargs2._runValidation(innerArgv, aliases, positionalMap, yargs2.parsed.error, !command2);
        }
        if (commandHandler.handler && !yargs2._hasOutput()) {
          yargs2._setHasOutput();
          const populateDoubleDash = !!yargs2.getOptions().configuration["populate--"];
          yargs2._postProcess(innerArgv, populateDoubleDash);
          innerArgv = applyMiddleware(innerArgv, yargs2, middlewares, false);
          let handlerResult;
          if (isPromise(innerArgv)) {
            handlerResult = innerArgv.then((argv) => commandHandler.handler(argv));
          } else {
            handlerResult = commandHandler.handler(innerArgv);
          }
          const handlerFinishCommand = yargs2.getHandlerFinishCommand();
          if (isPromise(handlerResult)) {
            yargs2.getUsageInstance().cacheHelpMessage();
            handlerResult.then((value) => {
              if (handlerFinishCommand) {
                handlerFinishCommand(value);
              }
            }).catch((error) => {
              try {
                yargs2.getUsageInstance().fail(null, error);
              } catch (err) {
              }
            }).then(() => {
              yargs2.getUsageInstance().clearCachedHelpMessage();
            });
          } else {
            if (handlerFinishCommand) {
              handlerFinishCommand(handlerResult);
            }
          }
        }
        if (command2) {
          currentContext.commands.pop();
          currentContext.fullCommands.pop();
        }
        numFiles = currentContext.files.length - numFiles;
        if (numFiles > 0)
          currentContext.files.splice(numFiles * -1, numFiles);
        return innerArgv;
      };
      function shouldUpdateUsage(yargs2) {
        return !yargs2.getUsageInstance().getUsageDisabled() && yargs2.getUsageInstance().getUsage().length === 0;
      }
      function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {
        const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, "").trim() : commandHandler.original;
        const pc = parentCommands.filter((c2) => {
          return !DEFAULT_MARKER.test(c2);
        });
        pc.push(c);
        return `$0 ${pc.join(" ")}`;
      }
      self2.runDefaultBuilderOn = function(yargs2) {
        assertNotStrictEqual(defaultCommand, void 0, shim2);
        if (shouldUpdateUsage(yargs2)) {
          const commandString = DEFAULT_MARKER.test(defaultCommand.original) ? defaultCommand.original : defaultCommand.original.replace(/^[^[\]<>]*/, "$0 ");
          yargs2.getUsageInstance().usage(commandString, defaultCommand.description);
        }
        const builder = defaultCommand.builder;
        if (isCommandBuilderCallback(builder)) {
          builder(yargs2);
        } else if (!isCommandBuilderDefinition(builder)) {
          Object.keys(builder).forEach((key) => {
            yargs2.option(key, builder[key]);
          });
        }
      };
      function populatePositionals(commandHandler, argv, context) {
        argv._ = argv._.slice(context.commands.length);
        const demanded = commandHandler.demanded.slice(0);
        const optional = commandHandler.optional.slice(0);
        const positionalMap = {};
        validation2.positionalCount(demanded.length, argv._.length);
        while (demanded.length) {
          const demand = demanded.shift();
          populatePositional(demand, argv, positionalMap);
        }
        while (optional.length) {
          const maybe = optional.shift();
          populatePositional(maybe, argv, positionalMap);
        }
        argv._ = context.commands.concat(argv._.map((a) => "" + a));
        postProcessPositionals(argv, positionalMap, self2.cmdToParseOptions(commandHandler.original));
        return positionalMap;
      }
      function populatePositional(positional, argv, positionalMap) {
        const cmd = positional.cmd[0];
        if (positional.variadic) {
          positionalMap[cmd] = argv._.splice(0).map(String);
        } else {
          if (argv._.length)
            positionalMap[cmd] = [String(argv._.shift())];
        }
      }
      function postProcessPositionals(argv, positionalMap, parseOptions) {
        const options = Object.assign({}, yargs.getOptions());
        options.default = Object.assign(parseOptions.default, options.default);
        for (const key of Object.keys(parseOptions.alias)) {
          options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);
        }
        options.array = options.array.concat(parseOptions.array);
        options.config = {};
        const unparsed = [];
        Object.keys(positionalMap).forEach((key) => {
          positionalMap[key].map((value) => {
            if (options.configuration["unknown-options-as-args"])
              options.key[key] = true;
            unparsed.push(`--${key}`);
            unparsed.push(value);
          });
        });
        if (!unparsed.length)
          return;
        const config = Object.assign({}, options.configuration, {
          "populate--": true
        });
        const parsed = shim2.Parser.detailed(unparsed, Object.assign({}, options, {
          configuration: config
        }));
        if (parsed.error) {
          yargs.getUsageInstance().fail(parsed.error.message, parsed.error);
        } else {
          const positionalKeys = Object.keys(positionalMap);
          Object.keys(positionalMap).forEach((key) => {
            positionalKeys.push(...parsed.aliases[key]);
          });
          Object.keys(parsed.argv).forEach((key) => {
            if (positionalKeys.indexOf(key) !== -1) {
              if (!positionalMap[key])
                positionalMap[key] = parsed.argv[key];
              argv[key] = parsed.argv[key];
            }
          });
        }
      }
      self2.cmdToParseOptions = function(cmdString) {
        const parseOptions = {
          array: [],
          default: {},
          alias: {},
          demand: {}
        };
        const parsed = parseCommand(cmdString);
        parsed.demanded.forEach((d) => {
          const [cmd, ...aliases] = d.cmd;
          if (d.variadic) {
            parseOptions.array.push(cmd);
            parseOptions.default[cmd] = [];
          }
          parseOptions.alias[cmd] = aliases;
          parseOptions.demand[cmd] = true;
        });
        parsed.optional.forEach((o) => {
          const [cmd, ...aliases] = o.cmd;
          if (o.variadic) {
            parseOptions.array.push(cmd);
            parseOptions.default[cmd] = [];
          }
          parseOptions.alias[cmd] = aliases;
        });
        return parseOptions;
      };
      self2.reset = () => {
        handlers = {};
        aliasMap = {};
        defaultCommand = void 0;
        return self2;
      };
      const frozens = [];
      self2.freeze = () => {
        frozens.push({
          handlers,
          aliasMap,
          defaultCommand
        });
      };
      self2.unfreeze = () => {
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, void 0, shim2);
        ({ handlers, aliasMap, defaultCommand } = frozen);
      };
      return self2;
    }
    function isCommandBuilderDefinition(builder) {
      return typeof builder === "object" && !!builder.builder && typeof builder.handler === "function";
    }
    function isCommandAndAliases(cmd) {
      if (cmd.every((c) => typeof c === "string")) {
        return true;
      } else {
        return false;
      }
    }
    function isCommandBuilderCallback(builder) {
      return typeof builder === "function";
    }
    function isCommandBuilderOptionDefinitions(builder) {
      return typeof builder === "object";
    }
    function isCommandHandlerDefinition(cmd) {
      return typeof cmd === "object" && !Array.isArray(cmd);
    }
    function setBlocking(blocking) {
      if (typeof process === "undefined")
        return;
      [process.stdout, process.stderr].forEach((_stream) => {
        const stream = _stream;
        if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === "function") {
          stream._handle.setBlocking(blocking);
        }
      });
    }
    function usage(yargs, y18n2, shim2) {
      const __ = y18n2.__;
      const self2 = {};
      const fails = [];
      self2.failFn = function failFn(f) {
        fails.push(f);
      };
      let failMessage = null;
      let showHelpOnFail = true;
      self2.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) {
        function parseFunctionArgs() {
          return typeof arg1 === "string" ? [true, arg1] : [arg1, arg2];
        }
        const [enabled, message] = parseFunctionArgs();
        failMessage = message;
        showHelpOnFail = enabled;
        return self2;
      };
      let failureOutput = false;
      self2.fail = function fail(msg, err) {
        const logger = yargs._getLoggerInstance();
        if (fails.length) {
          for (let i = fails.length - 1; i >= 0; --i) {
            fails[i](msg, err, self2);
          }
        } else {
          if (yargs.getExitProcess())
            setBlocking(true);
          if (!failureOutput) {
            failureOutput = true;
            if (showHelpOnFail) {
              yargs.showHelp("error");
              logger.error();
            }
            if (msg || err)
              logger.error(msg || err);
            if (failMessage) {
              if (msg || err)
                logger.error("");
              logger.error(failMessage);
            }
          }
          err = err || new YError(msg);
          if (yargs.getExitProcess()) {
            return yargs.exit(1);
          } else if (yargs._hasParseCallback()) {
            return yargs.exit(1, err);
          } else {
            throw err;
          }
        }
      };
      let usages = [];
      let usageDisabled = false;
      self2.usage = (msg, description) => {
        if (msg === null) {
          usageDisabled = true;
          usages = [];
          return self2;
        }
        usageDisabled = false;
        usages.push([msg, description || ""]);
        return self2;
      };
      self2.getUsage = () => {
        return usages;
      };
      self2.getUsageDisabled = () => {
        return usageDisabled;
      };
      self2.getPositionalGroupName = () => {
        return __("Positionals:");
      };
      let examples = [];
      self2.example = (cmd, description) => {
        examples.push([cmd, description || ""]);
      };
      let commands = [];
      self2.command = function command2(cmd, description, isDefault, aliases, deprecated = false) {
        if (isDefault) {
          commands = commands.map((cmdArray) => {
            cmdArray[2] = false;
            return cmdArray;
          });
        }
        commands.push([cmd, description || "", isDefault, aliases, deprecated]);
      };
      self2.getCommands = () => commands;
      let descriptions = {};
      self2.describe = function describe2(keyOrKeys, desc) {
        if (Array.isArray(keyOrKeys)) {
          keyOrKeys.forEach((k) => {
            self2.describe(k, desc);
          });
        } else if (typeof keyOrKeys === "object") {
          Object.keys(keyOrKeys).forEach((k) => {
            self2.describe(k, keyOrKeys[k]);
          });
        } else {
          descriptions[keyOrKeys] = desc;
        }
      };
      self2.getDescriptions = () => descriptions;
      let epilogs = [];
      self2.epilog = (msg) => {
        epilogs.push(msg);
      };
      let wrapSet = false;
      let wrap;
      self2.wrap = (cols) => {
        wrapSet = true;
        wrap = cols;
      };
      function getWrap() {
        if (!wrapSet) {
          wrap = windowWidth();
          wrapSet = true;
        }
        return wrap;
      }
      const deferY18nLookupPrefix = "__yargsString__:";
      self2.deferY18nLookup = (str) => deferY18nLookupPrefix + str;
      self2.help = function help() {
        if (cachedHelpMessage)
          return cachedHelpMessage;
        normalizeAliases();
        const base$0 = yargs.customScriptName ? yargs.$0 : shim2.path.basename(yargs.$0);
        const demandedOptions = yargs.getDemandedOptions();
        const demandedCommands = yargs.getDemandedCommands();
        const deprecatedOptions = yargs.getDeprecatedOptions();
        const groups = yargs.getGroups();
        const options = yargs.getOptions();
        let keys = [];
        keys = keys.concat(Object.keys(descriptions));
        keys = keys.concat(Object.keys(demandedOptions));
        keys = keys.concat(Object.keys(demandedCommands));
        keys = keys.concat(Object.keys(options.default));
        keys = keys.filter(filterHiddenOptions);
        keys = Object.keys(keys.reduce((acc, key) => {
          if (key !== "_")
            acc[key] = true;
          return acc;
        }, {}));
        const theWrap = getWrap();
        const ui = shim2.cliui({
          width: theWrap,
          wrap: !!theWrap
        });
        if (!usageDisabled) {
          if (usages.length) {
            usages.forEach((usage2) => {
              ui.div(`${usage2[0].replace(/\$0/g, base$0)}`);
              if (usage2[1]) {
                ui.div({ text: `${usage2[1]}`, padding: [1, 0, 0, 0] });
              }
            });
            ui.div();
          } else if (commands.length) {
            let u = null;
            if (demandedCommands._) {
              u = `${base$0} <${__("command")}>
`;
            } else {
              u = `${base$0} [${__("command")}]
`;
            }
            ui.div(`${u}`);
          }
        }
        if (commands.length) {
          ui.div(__("Commands:"));
          const context = yargs.getContext();
          const parentCommands = context.commands.length ? `${context.commands.join(" ")} ` : "";
          if (yargs.getParserConfiguration()["sort-commands"] === true) {
            commands = commands.sort((a, b) => a[0].localeCompare(b[0]));
          }
          commands.forEach((command2) => {
            const commandString = `${base$0} ${parentCommands}${command2[0].replace(/^\$0 ?/, "")}`;
            ui.span({
              text: commandString,
              padding: [0, 2, 0, 2],
              width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4
            }, { text: command2[1] });
            const hints = [];
            if (command2[2])
              hints.push(`[${__("default")}]`);
            if (command2[3] && command2[3].length) {
              hints.push(`[${__("aliases:")} ${command2[3].join(", ")}]`);
            }
            if (command2[4]) {
              if (typeof command2[4] === "string") {
                hints.push(`[${__("deprecated: %s", command2[4])}]`);
              } else {
                hints.push(`[${__("deprecated")}]`);
              }
            }
            if (hints.length) {
              ui.div({
                text: hints.join(" "),
                padding: [0, 0, 0, 2],
                align: "right"
              });
            } else {
              ui.div();
            }
          });
          ui.div();
        }
        const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);
        keys = keys.filter((key) => !yargs.parsed.newAliases[key] && aliasKeys.every((alias) => (options.alias[alias] || []).indexOf(key) === -1));
        const defaultGroup = __("Options:");
        if (!groups[defaultGroup])
          groups[defaultGroup] = [];
        addUngroupedKeys(keys, options.alias, groups, defaultGroup);
        const isLongSwitch = (sw) => /^--/.test(getText(sw));
        const displayedGroups = Object.keys(groups).filter((groupName) => groups[groupName].length > 0).map((groupName) => {
          const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key) => {
            if (~aliasKeys.indexOf(key))
              return key;
            for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== void 0; i++) {
              if (~(options.alias[aliasKey] || []).indexOf(key))
                return aliasKey;
            }
            return key;
          });
          return { groupName, normalizedKeys };
        }).filter(({ normalizedKeys }) => normalizedKeys.length > 0).map(({ groupName, normalizedKeys }) => {
          const switches = normalizedKeys.reduce((acc, key) => {
            acc[key] = [key].concat(options.alias[key] || []).map((sw) => {
              if (groupName === self2.getPositionalGroupName())
                return sw;
              else {
                return (/^[0-9]$/.test(sw) ? ~options.boolean.indexOf(key) ? "-" : "--" : sw.length > 1 ? "--" : "-") + sw;
              }
            }).sort((sw1, sw2) => isLongSwitch(sw1) === isLongSwitch(sw2) ? 0 : isLongSwitch(sw1) ? 1 : -1).join(", ");
            return acc;
          }, {});
          return { groupName, normalizedKeys, switches };
        });
        const shortSwitchesUsed = displayedGroups.filter(({ groupName }) => groupName !== self2.getPositionalGroupName()).some(({ normalizedKeys, switches }) => !normalizedKeys.every((key) => isLongSwitch(switches[key])));
        if (shortSwitchesUsed) {
          displayedGroups.filter(({ groupName }) => groupName !== self2.getPositionalGroupName()).forEach(({ normalizedKeys, switches }) => {
            normalizedKeys.forEach((key) => {
              if (isLongSwitch(switches[key])) {
                switches[key] = addIndentation(switches[key], "-x, ".length);
              }
            });
          });
        }
        displayedGroups.forEach(({ groupName, normalizedKeys, switches }) => {
          ui.div(groupName);
          normalizedKeys.forEach((key) => {
            const kswitch = switches[key];
            let desc = descriptions[key] || "";
            let type = null;
            if (~desc.lastIndexOf(deferY18nLookupPrefix))
              desc = __(desc.substring(deferY18nLookupPrefix.length));
            if (~options.boolean.indexOf(key))
              type = `[${__("boolean")}]`;
            if (~options.count.indexOf(key))
              type = `[${__("count")}]`;
            if (~options.string.indexOf(key))
              type = `[${__("string")}]`;
            if (~options.normalize.indexOf(key))
              type = `[${__("string")}]`;
            if (~options.array.indexOf(key))
              type = `[${__("array")}]`;
            if (~options.number.indexOf(key))
              type = `[${__("number")}]`;
            const deprecatedExtra = (deprecated) => typeof deprecated === "string" ? `[${__("deprecated: %s", deprecated)}]` : `[${__("deprecated")}]`;
            const extra = [
              key in deprecatedOptions ? deprecatedExtra(deprecatedOptions[key]) : null,
              type,
              key in demandedOptions ? `[${__("required")}]` : null,
              options.choices && options.choices[key] ? `[${__("choices:")} ${self2.stringifiedValues(options.choices[key])}]` : null,
              defaultString(options.default[key], options.defaultDescription[key])
            ].filter(Boolean).join(" ");
            ui.span({
              text: getText(kswitch),
              padding: [0, 2, 0, 2 + getIndentation(kswitch)],
              width: maxWidth(switches, theWrap) + 4
            }, desc);
            if (extra)
              ui.div({ text: extra, padding: [0, 0, 0, 2], align: "right" });
            else
              ui.div();
          });
          ui.div();
        });
        if (examples.length) {
          ui.div(__("Examples:"));
          examples.forEach((example) => {
            example[0] = example[0].replace(/\$0/g, base$0);
          });
          examples.forEach((example) => {
            if (example[1] === "") {
              ui.div({
                text: example[0],
                padding: [0, 2, 0, 2]
              });
            } else {
              ui.div({
                text: example[0],
                padding: [0, 2, 0, 2],
                width: maxWidth(examples, theWrap) + 4
              }, {
                text: example[1]
              });
            }
          });
          ui.div();
        }
        if (epilogs.length > 0) {
          const e = epilogs.map((epilog) => epilog.replace(/\$0/g, base$0)).join("\n");
          ui.div(`${e}
`);
        }
        return ui.toString().replace(/\s*$/, "");
      };
      function maxWidth(table, theWrap, modifier) {
        let width = 0;
        if (!Array.isArray(table)) {
          table = Object.values(table).map((v) => [v]);
        }
        table.forEach((v) => {
          width = Math.max(shim2.stringWidth(modifier ? `${modifier} ${getText(v[0])}` : getText(v[0])) + getIndentation(v[0]), width);
        });
        if (theWrap)
          width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
        return width;
      }
      function normalizeAliases() {
        const demandedOptions = yargs.getDemandedOptions();
        const options = yargs.getOptions();
        (Object.keys(options.alias) || []).forEach((key) => {
          options.alias[key].forEach((alias) => {
            if (descriptions[alias])
              self2.describe(key, descriptions[alias]);
            if (alias in demandedOptions)
              yargs.demandOption(key, demandedOptions[alias]);
            if (~options.boolean.indexOf(alias))
              yargs.boolean(key);
            if (~options.count.indexOf(alias))
              yargs.count(key);
            if (~options.string.indexOf(alias))
              yargs.string(key);
            if (~options.normalize.indexOf(alias))
              yargs.normalize(key);
            if (~options.array.indexOf(alias))
              yargs.array(key);
            if (~options.number.indexOf(alias))
              yargs.number(key);
          });
        });
      }
      let cachedHelpMessage;
      self2.cacheHelpMessage = function() {
        cachedHelpMessage = this.help();
      };
      self2.clearCachedHelpMessage = function() {
        cachedHelpMessage = void 0;
      };
      function addUngroupedKeys(keys, aliases, groups, defaultGroup) {
        let groupedKeys = [];
        let toCheck = null;
        Object.keys(groups).forEach((group) => {
          groupedKeys = groupedKeys.concat(groups[group]);
        });
        keys.forEach((key) => {
          toCheck = [key].concat(aliases[key]);
          if (!toCheck.some((k) => groupedKeys.indexOf(k) !== -1)) {
            groups[defaultGroup].push(key);
          }
        });
        return groupedKeys;
      }
      function filterHiddenOptions(key) {
        return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt];
      }
      self2.showHelp = (level) => {
        const logger = yargs._getLoggerInstance();
        if (!level)
          level = "error";
        const emit = typeof level === "function" ? level : logger[level];
        emit(self2.help());
      };
      self2.functionDescription = (fn) => {
        const description = fn.name ? shim2.Parser.decamelize(fn.name, "-") : __("generated-value");
        return ["(", description, ")"].join("");
      };
      self2.stringifiedValues = function stringifiedValues(values, separator) {
        let string = "";
        const sep = separator || ", ";
        const array = [].concat(values);
        if (!values || !array.length)
          return string;
        array.forEach((value) => {
          if (string.length)
            string += sep;
          string += JSON.stringify(value);
        });
        return string;
      };
      function defaultString(value, defaultDescription) {
        let string = `[${__("default:")} `;
        if (value === void 0 && !defaultDescription)
          return null;
        if (defaultDescription) {
          string += defaultDescription;
        } else {
          switch (typeof value) {
            case "string":
              string += `"${value}"`;
              break;
            case "object":
              string += JSON.stringify(value);
              break;
            default:
              string += value;
          }
        }
        return `${string}]`;
      }
      function windowWidth() {
        const maxWidth2 = 80;
        if (shim2.process.stdColumns) {
          return Math.min(maxWidth2, shim2.process.stdColumns);
        } else {
          return maxWidth2;
        }
      }
      let version2 = null;
      self2.version = (ver) => {
        version2 = ver;
      };
      self2.showVersion = () => {
        const logger = yargs._getLoggerInstance();
        logger.log(version2);
      };
      self2.reset = function reset(localLookup) {
        failMessage = null;
        failureOutput = false;
        usages = [];
        usageDisabled = false;
        epilogs = [];
        examples = [];
        commands = [];
        descriptions = objFilter(descriptions, (k) => !localLookup[k]);
        return self2;
      };
      const frozens = [];
      self2.freeze = function freeze() {
        frozens.push({
          failMessage,
          failureOutput,
          usages,
          usageDisabled,
          epilogs,
          examples,
          commands,
          descriptions
        });
      };
      self2.unfreeze = function unfreeze() {
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, void 0, shim2);
        ({
          failMessage,
          failureOutput,
          usages,
          usageDisabled,
          epilogs,
          examples,
          commands,
          descriptions
        } = frozen);
      };
      return self2;
    }
    function isIndentedText(text) {
      return typeof text === "object";
    }
    function addIndentation(text, indent) {
      return isIndentedText(text) ? { text: text.text, indentation: text.indentation + indent } : { text, indentation: indent };
    }
    function getIndentation(text) {
      return isIndentedText(text) ? text.indentation : 0;
    }
    function getText(text) {
      return isIndentedText(text) ? text.text : text;
    }
    var completionShTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc
#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.
#
_yargs_completions()
{
    local cur_word args type_list

    cur_word="\${COMP_WORDS[COMP_CWORD]}"
    args=("\${COMP_WORDS[@]}")

    # ask yargs to generate completions.
    type_list=$({{app_path}} --get-yargs-completions "\${args[@]}")

    COMPREPLY=( $(compgen -W "\${type_list}" -- \${cur_word}) )

    # if no match was found, fall back to filename completion
    if [ \${#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=()
    fi

    return 0
}
complete -o default -F _yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
    var completionZshTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zsh_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'
' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
    function completion(yargs, usage2, command2, shim2) {
      const self2 = {
        completionKey: "get-yargs-completions"
      };
      let aliases;
      self2.setParsed = function setParsed(parsed) {
        aliases = parsed.aliases;
      };
      const zshShell = shim2.getEnv("SHELL") && shim2.getEnv("SHELL").indexOf("zsh") !== -1 || shim2.getEnv("ZSH_NAME") && shim2.getEnv("ZSH_NAME").indexOf("zsh") !== -1;
      self2.getCompletion = function getCompletion(args, done) {
        const completions = [];
        const current = args.length ? args[args.length - 1] : "";
        const argv = yargs.parse(args, true);
        const parentCommands = yargs.getContext().commands;
        function runCompletionFunction(argv2) {
          assertNotStrictEqual(completionFunction, null, shim2);
          if (isSyncCompletionFunction(completionFunction)) {
            const result = completionFunction(current, argv2);
            if (isPromise(result)) {
              return result.then((list) => {
                shim2.process.nextTick(() => {
                  done(list);
                });
              }).catch((err) => {
                shim2.process.nextTick(() => {
                  throw err;
                });
              });
            }
            return done(result);
          } else {
            return completionFunction(current, argv2, (completions2) => {
              done(completions2);
            });
          }
        }
        if (completionFunction) {
          return isPromise(argv) ? argv.then(runCompletionFunction) : runCompletionFunction(argv);
        }
        const handlers = command2.getCommandHandlers();
        for (let i = 0, ii = args.length; i < ii; ++i) {
          if (handlers[args[i]] && handlers[args[i]].builder) {
            const builder = handlers[args[i]].builder;
            if (isCommandBuilderCallback(builder)) {
              const y = yargs.reset();
              builder(y);
              return y.argv;
            }
          }
        }
        if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current) {
          usage2.getCommands().forEach((usageCommand) => {
            const commandName = parseCommand(usageCommand[0]).cmd;
            if (args.indexOf(commandName) === -1) {
              if (!zshShell) {
                completions.push(commandName);
              } else {
                const desc = usageCommand[1] || "";
                completions.push(commandName.replace(/:/g, "\\:") + ":" + desc);
              }
            }
          });
        }
        if (current.match(/^-/) || current === "" && completions.length === 0) {
          const descs = usage2.getDescriptions();
          const options = yargs.getOptions();
          Object.keys(options.key).forEach((key) => {
            const negable = !!options.configuration["boolean-negation"] && options.boolean.includes(key);
            let keyAndAliases = [key].concat(aliases[key] || []);
            if (negable)
              keyAndAliases = keyAndAliases.concat(keyAndAliases.map((key2) => `no-${key2}`));
            function completeOptionKey(key2) {
              const notInArgs = keyAndAliases.every((val) => args.indexOf(`--${val}`) === -1);
              if (notInArgs) {
                const startsByTwoDashes = (s) => /^--/.test(s);
                const isShortOption = (s) => /^[^0-9]$/.test(s);
                const dashes = !startsByTwoDashes(current) && isShortOption(key2) ? "-" : "--";
                if (!zshShell) {
                  completions.push(dashes + key2);
                } else {
                  const desc = descs[key2] || "";
                  completions.push(dashes + `${key2.replace(/:/g, "\\:")}:${desc.replace("__yargsString__:", "")}`);
                }
              }
            }
            completeOptionKey(key);
            if (negable && !!options.default[key])
              completeOptionKey(`no-${key}`);
          });
        }
        done(completions);
      };
      self2.generateCompletionScript = function generateCompletionScript($0, cmd) {
        let script = zshShell ? completionZshTemplate : completionShTemplate;
        const name = shim2.path.basename($0);
        if ($0.match(/\.js$/))
          $0 = `./${$0}`;
        script = script.replace(/{{app_name}}/g, name);
        script = script.replace(/{{completion_command}}/g, cmd);
        return script.replace(/{{app_path}}/g, $0);
      };
      let completionFunction = null;
      self2.registerFunction = (fn) => {
        completionFunction = fn;
      };
      return self2;
    }
    function isSyncCompletionFunction(completionFunction) {
      return completionFunction.length < 3;
    }
    function levenshtein(a, b) {
      if (a.length === 0)
        return b.length;
      if (b.length === 0)
        return a.length;
      const matrix = [];
      let i;
      for (i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      }
      let j;
      for (j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      }
      for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) === a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
          }
        }
      }
      return matrix[b.length][a.length];
    }
    var specialKeys = ["$0", "--", "_"];
    function validation(yargs, usage2, y18n2, shim2) {
      const __ = y18n2.__;
      const __n = y18n2.__n;
      const self2 = {};
      self2.nonOptionCount = function nonOptionCount(argv) {
        const demandedCommands = yargs.getDemandedCommands();
        const positionalCount = argv._.length + (argv["--"] ? argv["--"].length : 0);
        const _s = positionalCount - yargs.getContext().commands.length;
        if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {
          if (_s < demandedCommands._.min) {
            if (demandedCommands._.minMsg !== void 0) {
              usage2.fail(demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.min.toString()) : null);
            } else {
              usage2.fail(__n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", _s, _s.toString(), demandedCommands._.min.toString()));
            }
          } else if (_s > demandedCommands._.max) {
            if (demandedCommands._.maxMsg !== void 0) {
              usage2.fail(demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.max.toString()) : null);
            } else {
              usage2.fail(__n("Too many non-option arguments: got %s, maximum of %s", "Too many non-option arguments: got %s, maximum of %s", _s, _s.toString(), demandedCommands._.max.toString()));
            }
          }
        }
      };
      self2.positionalCount = function positionalCount(required, observed) {
        if (observed < required) {
          usage2.fail(__n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", observed, observed + "", required + ""));
        }
      };
      self2.requiredArguments = function requiredArguments(argv) {
        const demandedOptions = yargs.getDemandedOptions();
        let missing = null;
        for (const key of Object.keys(demandedOptions)) {
          if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === "undefined") {
            missing = missing || {};
            missing[key] = demandedOptions[key];
          }
        }
        if (missing) {
          const customMsgs = [];
          for (const key of Object.keys(missing)) {
            const msg = missing[key];
            if (msg && customMsgs.indexOf(msg) < 0) {
              customMsgs.push(msg);
            }
          }
          const customMsg = customMsgs.length ? `
${customMsgs.join("\n")}` : "";
          usage2.fail(__n("Missing required argument: %s", "Missing required arguments: %s", Object.keys(missing).length, Object.keys(missing).join(", ") + customMsg));
        }
      };
      self2.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {
        const commandKeys = yargs.getCommandInstance().getCommands();
        const unknown = [];
        const currentContext = yargs.getContext();
        Object.keys(argv).forEach((key) => {
          if (specialKeys.indexOf(key) === -1 && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) && !self2.isValidAndSomeAliasIsNotNew(key, aliases)) {
            unknown.push(key);
          }
        });
        if (checkPositionals && (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand)) {
          argv._.slice(currentContext.commands.length).forEach((key) => {
            if (commandKeys.indexOf("" + key) === -1) {
              unknown.push("" + key);
            }
          });
        }
        if (unknown.length > 0) {
          usage2.fail(__n("Unknown argument: %s", "Unknown arguments: %s", unknown.length, unknown.join(", ")));
        }
      };
      self2.unknownCommands = function unknownCommands(argv) {
        const commandKeys = yargs.getCommandInstance().getCommands();
        const unknown = [];
        const currentContext = yargs.getContext();
        if (currentContext.commands.length > 0 || commandKeys.length > 0) {
          argv._.slice(currentContext.commands.length).forEach((key) => {
            if (commandKeys.indexOf("" + key) === -1) {
              unknown.push("" + key);
            }
          });
        }
        if (unknown.length > 0) {
          usage2.fail(__n("Unknown command: %s", "Unknown commands: %s", unknown.length, unknown.join(", ")));
          return true;
        } else {
          return false;
        }
      };
      self2.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {
        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {
          return false;
        }
        const newAliases = yargs.parsed.newAliases;
        for (const a of [key, ...aliases[key]]) {
          if (!Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]) {
            return true;
          }
        }
        return false;
      };
      self2.limitedChoices = function limitedChoices(argv) {
        const options = yargs.getOptions();
        const invalid = {};
        if (!Object.keys(options.choices).length)
          return;
        Object.keys(argv).forEach((key) => {
          if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {
            [].concat(argv[key]).forEach((value) => {
              if (options.choices[key].indexOf(value) === -1 && value !== void 0) {
                invalid[key] = (invalid[key] || []).concat(value);
              }
            });
          }
        });
        const invalidKeys = Object.keys(invalid);
        if (!invalidKeys.length)
          return;
        let msg = __("Invalid values:");
        invalidKeys.forEach((key) => {
          msg += `
  ${__("Argument: %s, Given: %s, Choices: %s", key, usage2.stringifiedValues(invalid[key]), usage2.stringifiedValues(options.choices[key]))}`;
        });
        usage2.fail(msg);
      };
      let checks = [];
      self2.check = function check(f, global2) {
        checks.push({
          func: f,
          global: global2
        });
      };
      self2.customChecks = function customChecks(argv, aliases) {
        for (let i = 0, f; (f = checks[i]) !== void 0; i++) {
          const func = f.func;
          let result = null;
          try {
            result = func(argv, aliases);
          } catch (err) {
            usage2.fail(err.message ? err.message : err, err);
            continue;
          }
          if (!result) {
            usage2.fail(__("Argument check failed: %s", func.toString()));
          } else if (typeof result === "string" || result instanceof Error) {
            usage2.fail(result.toString(), result);
          }
        }
      };
      let implied = {};
      self2.implies = function implies(key, value) {
        argsert("<string|object> [array|number|string]", [key, value], arguments.length);
        if (typeof key === "object") {
          Object.keys(key).forEach((k) => {
            self2.implies(k, key[k]);
          });
        } else {
          yargs.global(key);
          if (!implied[key]) {
            implied[key] = [];
          }
          if (Array.isArray(value)) {
            value.forEach((i) => self2.implies(key, i));
          } else {
            assertNotStrictEqual(value, void 0, shim2);
            implied[key].push(value);
          }
        }
      };
      self2.getImplied = function getImplied() {
        return implied;
      };
      function keyExists(argv, val) {
        const num = Number(val);
        val = isNaN(num) ? val : num;
        if (typeof val === "number") {
          val = argv._.length >= val;
        } else if (val.match(/^--no-.+/)) {
          val = val.match(/^--no-(.+)/)[1];
          val = !argv[val];
        } else {
          val = argv[val];
        }
        return val;
      }
      self2.implications = function implications(argv) {
        const implyFail = [];
        Object.keys(implied).forEach((key) => {
          const origKey = key;
          (implied[key] || []).forEach((value) => {
            let key2 = origKey;
            const origValue = value;
            key2 = keyExists(argv, key2);
            value = keyExists(argv, value);
            if (key2 && !value) {
              implyFail.push(` ${origKey} -> ${origValue}`);
            }
          });
        });
        if (implyFail.length) {
          let msg = `${__("Implications failed:")}
`;
          implyFail.forEach((value) => {
            msg += value;
          });
          usage2.fail(msg);
        }
      };
      let conflicting = {};
      self2.conflicts = function conflicts(key, value) {
        argsert("<string|object> [array|string]", [key, value], arguments.length);
        if (typeof key === "object") {
          Object.keys(key).forEach((k) => {
            self2.conflicts(k, key[k]);
          });
        } else {
          yargs.global(key);
          if (!conflicting[key]) {
            conflicting[key] = [];
          }
          if (Array.isArray(value)) {
            value.forEach((i) => self2.conflicts(key, i));
          } else {
            conflicting[key].push(value);
          }
        }
      };
      self2.getConflicting = () => conflicting;
      self2.conflicting = function conflictingFn(argv) {
        Object.keys(argv).forEach((key) => {
          if (conflicting[key]) {
            conflicting[key].forEach((value) => {
              if (value && argv[key] !== void 0 && argv[value] !== void 0) {
                usage2.fail(__("Arguments %s and %s are mutually exclusive", key, value));
              }
            });
          }
        });
      };
      self2.recommendCommands = function recommendCommands(cmd, potentialCommands) {
        const threshold = 3;
        potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);
        let recommended = null;
        let bestDistance = Infinity;
        for (let i = 0, candidate; (candidate = potentialCommands[i]) !== void 0; i++) {
          const d = levenshtein(cmd, candidate);
          if (d <= threshold && d < bestDistance) {
            bestDistance = d;
            recommended = candidate;
          }
        }
        if (recommended)
          usage2.fail(__("Did you mean %s?", recommended));
      };
      self2.reset = function reset(localLookup) {
        implied = objFilter(implied, (k) => !localLookup[k]);
        conflicting = objFilter(conflicting, (k) => !localLookup[k]);
        checks = checks.filter((c) => c.global);
        return self2;
      };
      const frozens = [];
      self2.freeze = function freeze() {
        frozens.push({
          implied,
          checks,
          conflicting
        });
      };
      self2.unfreeze = function unfreeze() {
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, void 0, shim2);
        ({ implied, checks, conflicting } = frozen);
      };
      return self2;
    }
    var shim$1;
    function YargsWithShim(_shim) {
      shim$1 = _shim;
      return Yargs;
    }
    function Yargs(processArgs = [], cwd = shim$1.process.cwd(), parentRequire) {
      const self2 = {};
      let command$1;
      let completion$1 = null;
      let groups = {};
      const globalMiddleware = [];
      let output = "";
      const preservedGroups = {};
      let usage$1;
      let validation$1;
      let handlerFinishCommand = null;
      const y18n2 = shim$1.y18n;
      self2.middleware = globalMiddlewareFactory(globalMiddleware, self2);
      self2.scriptName = function(scriptName) {
        self2.customScriptName = true;
        self2.$0 = scriptName;
        return self2;
      };
      let default$0;
      if (/\b(node|iojs|electron)(\.exe)?$/.test(shim$1.process.argv()[0])) {
        default$0 = shim$1.process.argv().slice(1, 2);
      } else {
        default$0 = shim$1.process.argv().slice(0, 1);
      }
      self2.$0 = default$0.map((x) => {
        const b = rebase(cwd, x);
        return x.match(/^(\/|([a-zA-Z]:)?\\)/) && b.length < x.length ? b : x;
      }).join(" ").trim();
      if (shim$1.getEnv("_") && shim$1.getProcessArgvBin() === shim$1.getEnv("_")) {
        self2.$0 = shim$1.getEnv("_").replace(`${shim$1.path.dirname(shim$1.process.execPath())}/`, "");
      }
      const context = { resets: -1, commands: [], fullCommands: [], files: [] };
      self2.getContext = () => context;
      let hasOutput = false;
      let exitError = null;
      self2.exit = (code, err) => {
        hasOutput = true;
        exitError = err;
        if (exitProcess)
          shim$1.process.exit(code);
      };
      let completionCommand = null;
      self2.completion = function(cmd, desc, fn) {
        argsert("[string] [string|boolean|function] [function]", [cmd, desc, fn], arguments.length);
        if (typeof desc === "function") {
          fn = desc;
          desc = void 0;
        }
        completionCommand = cmd || completionCommand || "completion";
        if (!desc && desc !== false) {
          desc = "generate completion script";
        }
        self2.command(completionCommand, desc);
        if (fn)
          completion$1.registerFunction(fn);
        return self2;
      };
      let options;
      self2.resetOptions = self2.reset = function resetOptions(aliases = {}) {
        context.resets++;
        options = options || {};
        const tmpOptions = {};
        tmpOptions.local = options.local ? options.local : [];
        tmpOptions.configObjects = options.configObjects ? options.configObjects : [];
        const localLookup = {};
        tmpOptions.local.forEach((l) => {
          localLookup[l] = true;
          (aliases[l] || []).forEach((a) => {
            localLookup[a] = true;
          });
        });
        Object.assign(preservedGroups, Object.keys(groups).reduce((acc, groupName) => {
          const keys = groups[groupName].filter((key) => !(key in localLookup));
          if (keys.length > 0) {
            acc[groupName] = keys;
          }
          return acc;
        }, {}));
        groups = {};
        const arrayOptions = [
          "array",
          "boolean",
          "string",
          "skipValidation",
          "count",
          "normalize",
          "number",
          "hiddenOptions"
        ];
        const objectOptions = [
          "narg",
          "key",
          "alias",
          "default",
          "defaultDescription",
          "config",
          "choices",
          "demandedOptions",
          "demandedCommands",
          "coerce",
          "deprecatedOptions"
        ];
        arrayOptions.forEach((k) => {
          tmpOptions[k] = (options[k] || []).filter((k2) => !localLookup[k2]);
        });
        objectOptions.forEach((k) => {
          tmpOptions[k] = objFilter(options[k], (k2) => !localLookup[k2]);
        });
        tmpOptions.envPrefix = options.envPrefix;
        options = tmpOptions;
        usage$1 = usage$1 ? usage$1.reset(localLookup) : usage(self2, y18n2, shim$1);
        validation$1 = validation$1 ? validation$1.reset(localLookup) : validation(self2, usage$1, y18n2, shim$1);
        command$1 = command$1 ? command$1.reset() : command(self2, usage$1, validation$1, globalMiddleware, shim$1);
        if (!completion$1)
          completion$1 = completion(self2, usage$1, command$1, shim$1);
        completionCommand = null;
        output = "";
        exitError = null;
        hasOutput = false;
        self2.parsed = false;
        return self2;
      };
      self2.resetOptions();
      const frozens = [];
      function freeze() {
        frozens.push({
          options,
          configObjects: options.configObjects.slice(0),
          exitProcess,
          groups,
          strict,
          strictCommands,
          strictOptions,
          completionCommand,
          output,
          exitError,
          hasOutput,
          parsed: self2.parsed,
          parseFn,
          parseContext,
          handlerFinishCommand
        });
        usage$1.freeze();
        validation$1.freeze();
        command$1.freeze();
      }
      function unfreeze() {
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, void 0, shim$1);
        let configObjects;
        ({
          options,
          configObjects,
          exitProcess,
          groups,
          output,
          exitError,
          hasOutput,
          parsed: self2.parsed,
          strict,
          strictCommands,
          strictOptions,
          completionCommand,
          parseFn,
          parseContext,
          handlerFinishCommand
        } = frozen);
        options.configObjects = configObjects;
        usage$1.unfreeze();
        validation$1.unfreeze();
        command$1.unfreeze();
      }
      self2.boolean = function(keys) {
        argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("boolean", keys);
        return self2;
      };
      self2.array = function(keys) {
        argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("array", keys);
        return self2;
      };
      self2.number = function(keys) {
        argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("number", keys);
        return self2;
      };
      self2.normalize = function(keys) {
        argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("normalize", keys);
        return self2;
      };
      self2.count = function(keys) {
        argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("count", keys);
        return self2;
      };
      self2.string = function(keys) {
        argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("string", keys);
        return self2;
      };
      self2.requiresArg = function(keys) {
        argsert("<array|string|object> [number]", [keys], arguments.length);
        if (typeof keys === "string" && options.narg[keys]) {
          return self2;
        } else {
          populateParserHintSingleValueDictionary(self2.requiresArg, "narg", keys, NaN);
        }
        return self2;
      };
      self2.skipValidation = function(keys) {
        argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("skipValidation", keys);
        return self2;
      };
      function populateParserHintArray(type, keys) {
        keys = [].concat(keys);
        keys.forEach((key) => {
          key = sanitizeKey(key);
          options[type].push(key);
        });
      }
      self2.nargs = function(key, value) {
        argsert("<string|object|array> [number]", [key, value], arguments.length);
        populateParserHintSingleValueDictionary(self2.nargs, "narg", key, value);
        return self2;
      };
      self2.choices = function(key, value) {
        argsert("<object|string|array> [string|array]", [key, value], arguments.length);
        populateParserHintArrayDictionary(self2.choices, "choices", key, value);
        return self2;
      };
      self2.alias = function(key, value) {
        argsert("<object|string|array> [string|array]", [key, value], arguments.length);
        populateParserHintArrayDictionary(self2.alias, "alias", key, value);
        return self2;
      };
      self2.default = self2.defaults = function(key, value, defaultDescription) {
        argsert("<object|string|array> [*] [string]", [key, value, defaultDescription], arguments.length);
        if (defaultDescription) {
          assertSingleKey(key, shim$1);
          options.defaultDescription[key] = defaultDescription;
        }
        if (typeof value === "function") {
          assertSingleKey(key, shim$1);
          if (!options.defaultDescription[key])
            options.defaultDescription[key] = usage$1.functionDescription(value);
          value = value.call();
        }
        populateParserHintSingleValueDictionary(self2.default, "default", key, value);
        return self2;
      };
      self2.describe = function(key, desc) {
        argsert("<object|string|array> [string]", [key, desc], arguments.length);
        setKey(key, true);
        usage$1.describe(key, desc);
        return self2;
      };
      function setKey(key, set) {
        populateParserHintSingleValueDictionary(setKey, "key", key, set);
        return self2;
      }
      function demandOption(keys, msg) {
        argsert("<object|string|array> [string]", [keys, msg], arguments.length);
        populateParserHintSingleValueDictionary(self2.demandOption, "demandedOptions", keys, msg);
        return self2;
      }
      self2.demandOption = demandOption;
      self2.coerce = function(keys, value) {
        argsert("<object|string|array> [function]", [keys, value], arguments.length);
        populateParserHintSingleValueDictionary(self2.coerce, "coerce", keys, value);
        return self2;
      };
      function populateParserHintSingleValueDictionary(builder, type, key, value) {
        populateParserHintDictionary(builder, type, key, value, (type2, key2, value2) => {
          options[type2][key2] = value2;
        });
      }
      function populateParserHintArrayDictionary(builder, type, key, value) {
        populateParserHintDictionary(builder, type, key, value, (type2, key2, value2) => {
          options[type2][key2] = (options[type2][key2] || []).concat(value2);
        });
      }
      function populateParserHintDictionary(builder, type, key, value, singleKeyHandler) {
        if (Array.isArray(key)) {
          key.forEach((k) => {
            builder(k, value);
          });
        } else if (/* @__PURE__ */ ((key2) => typeof key2 === "object")(key)) {
          for (const k of objectKeys(key)) {
            builder(k, key[k]);
          }
        } else {
          singleKeyHandler(type, sanitizeKey(key), value);
        }
      }
      function sanitizeKey(key) {
        if (key === "__proto__")
          return "___proto___";
        return key;
      }
      function deleteFromParserHintObject(optionKey) {
        objectKeys(options).forEach((hintKey) => {
          if (/* @__PURE__ */ ((key) => key === "configObjects")(hintKey))
            return;
          const hint = options[hintKey];
          if (Array.isArray(hint)) {
            if (~hint.indexOf(optionKey))
              hint.splice(hint.indexOf(optionKey), 1);
          } else if (typeof hint === "object") {
            delete hint[optionKey];
          }
        });
        delete usage$1.getDescriptions()[optionKey];
      }
      self2.config = function config(key = "config", msg, parseFn2) {
        argsert("[object|string] [string|function] [function]", [key, msg, parseFn2], arguments.length);
        if (typeof key === "object" && !Array.isArray(key)) {
          key = applyExtends(key, cwd, self2.getParserConfiguration()["deep-merge-config"] || false, shim$1);
          options.configObjects = (options.configObjects || []).concat(key);
          return self2;
        }
        if (typeof msg === "function") {
          parseFn2 = msg;
          msg = void 0;
        }
        self2.describe(key, msg || usage$1.deferY18nLookup("Path to JSON config file"));
        (Array.isArray(key) ? key : [key]).forEach((k) => {
          options.config[k] = parseFn2 || true;
        });
        return self2;
      };
      self2.example = function(cmd, description) {
        argsert("<string|array> [string]", [cmd, description], arguments.length);
        if (Array.isArray(cmd)) {
          cmd.forEach((exampleParams) => self2.example(...exampleParams));
        } else {
          usage$1.example(cmd, description);
        }
        return self2;
      };
      self2.command = function(cmd, description, builder, handler, middlewares, deprecated) {
        argsert("<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]", [cmd, description, builder, handler, middlewares, deprecated], arguments.length);
        command$1.addHandler(cmd, description, builder, handler, middlewares, deprecated);
        return self2;
      };
      self2.commandDir = function(dir, opts) {
        argsert("<string> [object]", [dir, opts], arguments.length);
        const req = parentRequire || shim$1.require;
        command$1.addDirectory(dir, self2.getContext(), req, shim$1.getCallerFile(), opts);
        return self2;
      };
      self2.demand = self2.required = self2.require = function demand(keys, max, msg) {
        if (Array.isArray(max)) {
          max.forEach((key) => {
            assertNotStrictEqual(msg, true, shim$1);
            demandOption(key, msg);
          });
          max = Infinity;
        } else if (typeof max !== "number") {
          msg = max;
          max = Infinity;
        }
        if (typeof keys === "number") {
          assertNotStrictEqual(msg, true, shim$1);
          self2.demandCommand(keys, max, msg, msg);
        } else if (Array.isArray(keys)) {
          keys.forEach((key) => {
            assertNotStrictEqual(msg, true, shim$1);
            demandOption(key, msg);
          });
        } else {
          if (typeof msg === "string") {
            demandOption(keys, msg);
          } else if (msg === true || typeof msg === "undefined") {
            demandOption(keys);
          }
        }
        return self2;
      };
      self2.demandCommand = function demandCommand(min = 1, max, minMsg, maxMsg) {
        argsert("[number] [number|string] [string|null|undefined] [string|null|undefined]", [min, max, minMsg, maxMsg], arguments.length);
        if (typeof max !== "number") {
          minMsg = max;
          max = Infinity;
        }
        self2.global("_", false);
        options.demandedCommands._ = {
          min,
          max,
          minMsg,
          maxMsg
        };
        return self2;
      };
      self2.getDemandedOptions = () => {
        argsert([], 0);
        return options.demandedOptions;
      };
      self2.getDemandedCommands = () => {
        argsert([], 0);
        return options.demandedCommands;
      };
      self2.deprecateOption = function deprecateOption(option, message) {
        argsert("<string> [string|boolean]", [option, message], arguments.length);
        options.deprecatedOptions[option] = message;
        return self2;
      };
      self2.getDeprecatedOptions = () => {
        argsert([], 0);
        return options.deprecatedOptions;
      };
      self2.implies = function(key, value) {
        argsert("<string|object> [number|string|array]", [key, value], arguments.length);
        validation$1.implies(key, value);
        return self2;
      };
      self2.conflicts = function(key1, key2) {
        argsert("<string|object> [string|array]", [key1, key2], arguments.length);
        validation$1.conflicts(key1, key2);
        return self2;
      };
      self2.usage = function(msg, description, builder, handler) {
        argsert("<string|null|undefined> [string|boolean] [function|object] [function]", [msg, description, builder, handler], arguments.length);
        if (description !== void 0) {
          assertNotStrictEqual(msg, null, shim$1);
          if ((msg || "").match(/^\$0( |$)/)) {
            return self2.command(msg, description, builder, handler);
          } else {
            throw new YError(".usage() description must start with $0 if being used as alias for .command()");
          }
        } else {
          usage$1.usage(msg);
          return self2;
        }
      };
      self2.epilogue = self2.epilog = function(msg) {
        argsert("<string>", [msg], arguments.length);
        usage$1.epilog(msg);
        return self2;
      };
      self2.fail = function(f) {
        argsert("<function>", [f], arguments.length);
        usage$1.failFn(f);
        return self2;
      };
      self2.onFinishCommand = function(f) {
        argsert("<function>", [f], arguments.length);
        handlerFinishCommand = f;
        return self2;
      };
      self2.getHandlerFinishCommand = () => handlerFinishCommand;
      self2.check = function(f, _global) {
        argsert("<function> [boolean]", [f, _global], arguments.length);
        validation$1.check(f, _global !== false);
        return self2;
      };
      self2.global = function global2(globals, global2) {
        argsert("<string|array> [boolean]", [globals, global2], arguments.length);
        globals = [].concat(globals);
        if (global2 !== false) {
          options.local = options.local.filter((l) => globals.indexOf(l) === -1);
        } else {
          globals.forEach((g) => {
            if (options.local.indexOf(g) === -1)
              options.local.push(g);
          });
        }
        return self2;
      };
      self2.pkgConf = function pkgConf(key, rootPath) {
        argsert("<string> [string]", [key, rootPath], arguments.length);
        let conf = null;
        const obj = pkgUp(rootPath || cwd);
        if (obj[key] && typeof obj[key] === "object") {
          conf = applyExtends(obj[key], rootPath || cwd, self2.getParserConfiguration()["deep-merge-config"] || false, shim$1);
          options.configObjects = (options.configObjects || []).concat(conf);
        }
        return self2;
      };
      const pkgs = {};
      function pkgUp(rootPath) {
        const npath = rootPath || "*";
        if (pkgs[npath])
          return pkgs[npath];
        let obj = {};
        try {
          let startDir = rootPath || shim$1.mainFilename;
          if (!rootPath && shim$1.path.extname(startDir)) {
            startDir = shim$1.path.dirname(startDir);
          }
          const pkgJsonPath = shim$1.findUp(startDir, (dir, names) => {
            if (names.includes("package.json")) {
              return "package.json";
            } else {
              return void 0;
            }
          });
          assertNotStrictEqual(pkgJsonPath, void 0, shim$1);
          obj = JSON.parse(shim$1.readFileSync(pkgJsonPath, "utf8"));
        } catch (_noop) {
        }
        pkgs[npath] = obj || {};
        return pkgs[npath];
      }
      let parseFn = null;
      let parseContext = null;
      self2.parse = function parse2(args, shortCircuit, _parseFn) {
        argsert("[string|array] [function|boolean|object] [function]", [args, shortCircuit, _parseFn], arguments.length);
        freeze();
        if (typeof args === "undefined") {
          const argv = self2._parseArgs(processArgs);
          const tmpParsed = self2.parsed;
          unfreeze();
          self2.parsed = tmpParsed;
          return argv;
        }
        if (typeof shortCircuit === "object") {
          parseContext = shortCircuit;
          shortCircuit = _parseFn;
        }
        if (typeof shortCircuit === "function") {
          parseFn = shortCircuit;
          shortCircuit = false;
        }
        if (!shortCircuit)
          processArgs = args;
        if (parseFn)
          exitProcess = false;
        const parsed = self2._parseArgs(args, !!shortCircuit);
        completion$1.setParsed(self2.parsed);
        if (parseFn)
          parseFn(exitError, parsed, output);
        unfreeze();
        return parsed;
      };
      self2._getParseContext = () => parseContext || {};
      self2._hasParseCallback = () => !!parseFn;
      self2.option = self2.options = function option(key, opt) {
        argsert("<string|object> [object]", [key, opt], arguments.length);
        if (typeof key === "object") {
          Object.keys(key).forEach((k) => {
            self2.options(k, key[k]);
          });
        } else {
          if (typeof opt !== "object") {
            opt = {};
          }
          options.key[key] = true;
          if (opt.alias)
            self2.alias(key, opt.alias);
          const deprecate = opt.deprecate || opt.deprecated;
          if (deprecate) {
            self2.deprecateOption(key, deprecate);
          }
          const demand = opt.demand || opt.required || opt.require;
          if (demand) {
            self2.demand(key, demand);
          }
          if (opt.demandOption) {
            self2.demandOption(key, typeof opt.demandOption === "string" ? opt.demandOption : void 0);
          }
          if (opt.conflicts) {
            self2.conflicts(key, opt.conflicts);
          }
          if ("default" in opt) {
            self2.default(key, opt.default);
          }
          if (opt.implies !== void 0) {
            self2.implies(key, opt.implies);
          }
          if (opt.nargs !== void 0) {
            self2.nargs(key, opt.nargs);
          }
          if (opt.config) {
            self2.config(key, opt.configParser);
          }
          if (opt.normalize) {
            self2.normalize(key);
          }
          if (opt.choices) {
            self2.choices(key, opt.choices);
          }
          if (opt.coerce) {
            self2.coerce(key, opt.coerce);
          }
          if (opt.group) {
            self2.group(key, opt.group);
          }
          if (opt.boolean || opt.type === "boolean") {
            self2.boolean(key);
            if (opt.alias)
              self2.boolean(opt.alias);
          }
          if (opt.array || opt.type === "array") {
            self2.array(key);
            if (opt.alias)
              self2.array(opt.alias);
          }
          if (opt.number || opt.type === "number") {
            self2.number(key);
            if (opt.alias)
              self2.number(opt.alias);
          }
          if (opt.string || opt.type === "string") {
            self2.string(key);
            if (opt.alias)
              self2.string(opt.alias);
          }
          if (opt.count || opt.type === "count") {
            self2.count(key);
          }
          if (typeof opt.global === "boolean") {
            self2.global(key, opt.global);
          }
          if (opt.defaultDescription) {
            options.defaultDescription[key] = opt.defaultDescription;
          }
          if (opt.skipValidation) {
            self2.skipValidation(key);
          }
          const desc = opt.describe || opt.description || opt.desc;
          self2.describe(key, desc);
          if (opt.hidden) {
            self2.hide(key);
          }
          if (opt.requiresArg) {
            self2.requiresArg(key);
          }
        }
        return self2;
      };
      self2.getOptions = () => options;
      self2.positional = function(key, opts) {
        argsert("<string> <object>", [key, opts], arguments.length);
        if (context.resets === 0) {
          throw new YError(".positional() can only be called in a command's builder function");
        }
        const supportedOpts = [
          "default",
          "defaultDescription",
          "implies",
          "normalize",
          "choices",
          "conflicts",
          "coerce",
          "type",
          "describe",
          "desc",
          "description",
          "alias"
        ];
        opts = objFilter(opts, (k, v) => {
          let accept = supportedOpts.indexOf(k) !== -1;
          if (k === "type" && ["string", "number", "boolean"].indexOf(v) === -1)
            accept = false;
          return accept;
        });
        const fullCommand = context.fullCommands[context.fullCommands.length - 1];
        const parseOptions = fullCommand ? command$1.cmdToParseOptions(fullCommand) : {
          array: [],
          alias: {},
          default: {},
          demand: {}
        };
        objectKeys(parseOptions).forEach((pk) => {
          const parseOption = parseOptions[pk];
          if (Array.isArray(parseOption)) {
            if (parseOption.indexOf(key) !== -1)
              opts[pk] = true;
          } else {
            if (parseOption[key] && !(pk in opts))
              opts[pk] = parseOption[key];
          }
        });
        self2.group(key, usage$1.getPositionalGroupName());
        return self2.option(key, opts);
      };
      self2.group = function group(opts, groupName) {
        argsert("<string|array> <string>", [opts, groupName], arguments.length);
        const existing = preservedGroups[groupName] || groups[groupName];
        if (preservedGroups[groupName]) {
          delete preservedGroups[groupName];
        }
        const seen = {};
        groups[groupName] = (existing || []).concat(opts).filter((key) => {
          if (seen[key])
            return false;
          return seen[key] = true;
        });
        return self2;
      };
      self2.getGroups = () => Object.assign({}, groups, preservedGroups);
      self2.env = function(prefix) {
        argsert("[string|boolean]", [prefix], arguments.length);
        if (prefix === false)
          delete options.envPrefix;
        else
          options.envPrefix = prefix || "";
        return self2;
      };
      self2.wrap = function(cols) {
        argsert("<number|null|undefined>", [cols], arguments.length);
        usage$1.wrap(cols);
        return self2;
      };
      let strict = false;
      self2.strict = function(enabled) {
        argsert("[boolean]", [enabled], arguments.length);
        strict = enabled !== false;
        return self2;
      };
      self2.getStrict = () => strict;
      let strictCommands = false;
      self2.strictCommands = function(enabled) {
        argsert("[boolean]", [enabled], arguments.length);
        strictCommands = enabled !== false;
        return self2;
      };
      self2.getStrictCommands = () => strictCommands;
      let strictOptions = false;
      self2.strictOptions = function(enabled) {
        argsert("[boolean]", [enabled], arguments.length);
        strictOptions = enabled !== false;
        return self2;
      };
      self2.getStrictOptions = () => strictOptions;
      let parserConfig = {};
      self2.parserConfiguration = function parserConfiguration(config) {
        argsert("<object>", [config], arguments.length);
        parserConfig = config;
        return self2;
      };
      self2.getParserConfiguration = () => parserConfig;
      self2.showHelp = function(level) {
        argsert("[string|function]", [level], arguments.length);
        if (!self2.parsed)
          self2._parseArgs(processArgs);
        if (command$1.hasDefaultCommand()) {
          context.resets++;
          command$1.runDefaultBuilderOn(self2);
        }
        usage$1.showHelp(level);
        return self2;
      };
      let versionOpt = null;
      self2.version = function version2(opt, msg, ver) {
        const defaultVersionOpt = "version";
        argsert("[boolean|string] [string] [string]", [opt, msg, ver], arguments.length);
        if (versionOpt) {
          deleteFromParserHintObject(versionOpt);
          usage$1.version(void 0);
          versionOpt = null;
        }
        if (arguments.length === 0) {
          ver = guessVersion();
          opt = defaultVersionOpt;
        } else if (arguments.length === 1) {
          if (opt === false) {
            return self2;
          }
          ver = opt;
          opt = defaultVersionOpt;
        } else if (arguments.length === 2) {
          ver = msg;
          msg = void 0;
        }
        versionOpt = typeof opt === "string" ? opt : defaultVersionOpt;
        msg = msg || usage$1.deferY18nLookup("Show version number");
        usage$1.version(ver || void 0);
        self2.boolean(versionOpt);
        self2.describe(versionOpt, msg);
        return self2;
      };
      function guessVersion() {
        const obj = pkgUp();
        return obj.version || "unknown";
      }
      let helpOpt = null;
      self2.addHelpOpt = self2.help = function addHelpOpt(opt, msg) {
        const defaultHelpOpt = "help";
        argsert("[string|boolean] [string]", [opt, msg], arguments.length);
        if (helpOpt) {
          deleteFromParserHintObject(helpOpt);
          helpOpt = null;
        }
        if (arguments.length === 1) {
          if (opt === false)
            return self2;
        }
        helpOpt = typeof opt === "string" ? opt : defaultHelpOpt;
        self2.boolean(helpOpt);
        self2.describe(helpOpt, msg || usage$1.deferY18nLookup("Show help"));
        return self2;
      };
      const defaultShowHiddenOpt = "show-hidden";
      options.showHiddenOpt = defaultShowHiddenOpt;
      self2.addShowHiddenOpt = self2.showHidden = function addShowHiddenOpt(opt, msg) {
        argsert("[string|boolean] [string]", [opt, msg], arguments.length);
        if (arguments.length === 1) {
          if (opt === false)
            return self2;
        }
        const showHiddenOpt = typeof opt === "string" ? opt : defaultShowHiddenOpt;
        self2.boolean(showHiddenOpt);
        self2.describe(showHiddenOpt, msg || usage$1.deferY18nLookup("Show hidden options"));
        options.showHiddenOpt = showHiddenOpt;
        return self2;
      };
      self2.hide = function hide(key) {
        argsert("<string>", [key], arguments.length);
        options.hiddenOptions.push(key);
        return self2;
      };
      self2.showHelpOnFail = function showHelpOnFail(enabled, message) {
        argsert("[boolean|string] [string]", [enabled, message], arguments.length);
        usage$1.showHelpOnFail(enabled, message);
        return self2;
      };
      let exitProcess = true;
      self2.exitProcess = function(enabled = true) {
        argsert("[boolean]", [enabled], arguments.length);
        exitProcess = enabled;
        return self2;
      };
      self2.getExitProcess = () => exitProcess;
      self2.showCompletionScript = function($0, cmd) {
        argsert("[string] [string]", [$0, cmd], arguments.length);
        $0 = $0 || self2.$0;
        _logger.log(completion$1.generateCompletionScript($0, cmd || completionCommand || "completion"));
        return self2;
      };
      self2.getCompletion = function(args, done) {
        argsert("<array> <function>", [args, done], arguments.length);
        completion$1.getCompletion(args, done);
      };
      self2.locale = function(locale) {
        argsert("[string]", [locale], arguments.length);
        if (!locale) {
          guessLocale();
          return y18n2.getLocale();
        }
        detectLocale = false;
        y18n2.setLocale(locale);
        return self2;
      };
      self2.updateStrings = self2.updateLocale = function(obj) {
        argsert("<object>", [obj], arguments.length);
        detectLocale = false;
        y18n2.updateLocale(obj);
        return self2;
      };
      let detectLocale = true;
      self2.detectLocale = function(detect) {
        argsert("<boolean>", [detect], arguments.length);
        detectLocale = detect;
        return self2;
      };
      self2.getDetectLocale = () => detectLocale;
      const _logger = {
        log(...args) {
          if (!self2._hasParseCallback())
            console.log(...args);
          hasOutput = true;
          if (output.length)
            output += "\n";
          output += args.join(" ");
        },
        error(...args) {
          if (!self2._hasParseCallback())
            console.error(...args);
          hasOutput = true;
          if (output.length)
            output += "\n";
          output += args.join(" ");
        }
      };
      self2._getLoggerInstance = () => _logger;
      self2._hasOutput = () => hasOutput;
      self2._setHasOutput = () => {
        hasOutput = true;
      };
      let recommendCommands;
      self2.recommendCommands = function(recommend = true) {
        argsert("[boolean]", [recommend], arguments.length);
        recommendCommands = recommend;
        return self2;
      };
      self2.getUsageInstance = () => usage$1;
      self2.getValidationInstance = () => validation$1;
      self2.getCommandInstance = () => command$1;
      self2.terminalWidth = () => {
        argsert([], 0);
        return shim$1.process.stdColumns;
      };
      Object.defineProperty(self2, "argv", {
        get: () => self2._parseArgs(processArgs),
        enumerable: true
      });
      self2._parseArgs = function parseArgs(args, shortCircuit, _calledFromCommand, commandIndex) {
        let skipValidation = !!_calledFromCommand;
        args = args || processArgs;
        options.__ = y18n2.__;
        options.configuration = self2.getParserConfiguration();
        const populateDoubleDash = !!options.configuration["populate--"];
        const config = Object.assign({}, options.configuration, {
          "populate--": true
        });
        const parsed = shim$1.Parser.detailed(args, Object.assign({}, options, {
          configuration: Object.assign({ "parse-positional-numbers": false }, config)
        }));
        let argv = parsed.argv;
        if (parseContext)
          argv = Object.assign({}, argv, parseContext);
        const aliases = parsed.aliases;
        argv.$0 = self2.$0;
        self2.parsed = parsed;
        try {
          guessLocale();
          if (shortCircuit) {
            return self2._postProcess(argv, populateDoubleDash, _calledFromCommand);
          }
          if (helpOpt) {
            const helpCmds = [helpOpt].concat(aliases[helpOpt] || []).filter((k) => k.length > 1);
            if (~helpCmds.indexOf("" + argv._[argv._.length - 1])) {
              argv._.pop();
              argv[helpOpt] = true;
            }
          }
          const handlerKeys = command$1.getCommands();
          const requestCompletions = completion$1.completionKey in argv;
          const skipRecommendation = argv[helpOpt] || requestCompletions;
          const skipDefaultCommand = skipRecommendation && (handlerKeys.length > 1 || handlerKeys[0] !== "$0");
          if (argv._.length) {
            if (handlerKeys.length) {
              let firstUnknownCommand;
              for (let i = commandIndex || 0, cmd; argv._[i] !== void 0; i++) {
                cmd = String(argv._[i]);
                if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {
                  const innerArgv = command$1.runCommand(cmd, self2, parsed, i + 1);
                  return self2._postProcess(innerArgv, populateDoubleDash);
                } else if (!firstUnknownCommand && cmd !== completionCommand) {
                  firstUnknownCommand = cmd;
                  break;
                }
              }
              if (command$1.hasDefaultCommand() && !skipDefaultCommand) {
                const innerArgv = command$1.runCommand(null, self2, parsed);
                return self2._postProcess(innerArgv, populateDoubleDash);
              }
              if (recommendCommands && firstUnknownCommand && !skipRecommendation) {
                validation$1.recommendCommands(firstUnknownCommand, handlerKeys);
              }
            }
            if (completionCommand && ~argv._.indexOf(completionCommand) && !requestCompletions) {
              if (exitProcess)
                setBlocking(true);
              self2.showCompletionScript();
              self2.exit(0);
            }
          } else if (command$1.hasDefaultCommand() && !skipDefaultCommand) {
            const innerArgv = command$1.runCommand(null, self2, parsed);
            return self2._postProcess(innerArgv, populateDoubleDash);
          }
          if (requestCompletions) {
            if (exitProcess)
              setBlocking(true);
            args = [].concat(args);
            const completionArgs = args.slice(args.indexOf(`--${completion$1.completionKey}`) + 1);
            completion$1.getCompletion(completionArgs, (completions) => {
              (completions || []).forEach((completion2) => {
                _logger.log(completion2);
              });
              self2.exit(0);
            });
            return self2._postProcess(argv, !populateDoubleDash, _calledFromCommand);
          }
          if (!hasOutput) {
            Object.keys(argv).forEach((key) => {
              if (key === helpOpt && argv[key]) {
                if (exitProcess)
                  setBlocking(true);
                skipValidation = true;
                self2.showHelp("log");
                self2.exit(0);
              } else if (key === versionOpt && argv[key]) {
                if (exitProcess)
                  setBlocking(true);
                skipValidation = true;
                usage$1.showVersion();
                self2.exit(0);
              }
            });
          }
          if (!skipValidation && options.skipValidation.length > 0) {
            skipValidation = Object.keys(argv).some((key) => options.skipValidation.indexOf(key) >= 0 && argv[key] === true);
          }
          if (!skipValidation) {
            if (parsed.error)
              throw new YError(parsed.error.message);
            if (!requestCompletions) {
              self2._runValidation(argv, aliases, {}, parsed.error);
            }
          }
        } catch (err) {
          if (err instanceof YError)
            usage$1.fail(err.message, err);
          else
            throw err;
        }
        return self2._postProcess(argv, populateDoubleDash, _calledFromCommand);
      };
      self2._postProcess = function(argv, populateDoubleDash, calledFromCommand = false) {
        if (isPromise(argv))
          return argv;
        if (calledFromCommand)
          return argv;
        if (!populateDoubleDash) {
          argv = self2._copyDoubleDash(argv);
        }
        const parsePositionalNumbers = self2.getParserConfiguration()["parse-positional-numbers"] || self2.getParserConfiguration()["parse-positional-numbers"] === void 0;
        if (parsePositionalNumbers) {
          argv = self2._parsePositionalNumbers(argv);
        }
        return argv;
      };
      self2._copyDoubleDash = function(argv) {
        if (!argv._ || !argv["--"])
          return argv;
        argv._.push.apply(argv._, argv["--"]);
        try {
          delete argv["--"];
        } catch (_err) {
        }
        return argv;
      };
      self2._parsePositionalNumbers = function(argv) {
        const args = argv["--"] ? argv["--"] : argv._;
        for (let i = 0, arg; (arg = args[i]) !== void 0; i++) {
          if (shim$1.Parser.looksLikeNumber(arg) && Number.isSafeInteger(Math.floor(parseFloat(`${arg}`)))) {
            args[i] = Number(arg);
          }
        }
        return argv;
      };
      self2._runValidation = function runValidation(argv, aliases, positionalMap, parseErrors, isDefaultCommand = false) {
        if (parseErrors)
          throw new YError(parseErrors.message);
        validation$1.nonOptionCount(argv);
        validation$1.requiredArguments(argv);
        let failedStrictCommands = false;
        if (strictCommands) {
          failedStrictCommands = validation$1.unknownCommands(argv);
        }
        if (strict && !failedStrictCommands) {
          validation$1.unknownArguments(argv, aliases, positionalMap, isDefaultCommand);
        } else if (strictOptions) {
          validation$1.unknownArguments(argv, aliases, {}, false, false);
        }
        validation$1.customChecks(argv, aliases);
        validation$1.limitedChoices(argv);
        validation$1.implications(argv);
        validation$1.conflicting(argv);
      };
      function guessLocale() {
        if (!detectLocale)
          return;
        const locale = shim$1.getEnv("LC_ALL") || shim$1.getEnv("LC_MESSAGES") || shim$1.getEnv("LANG") || shim$1.getEnv("LANGUAGE") || "en_US";
        self2.locale(locale.replace(/[.:].*/, ""));
      }
      self2.help();
      self2.version();
      return self2;
    }
    var rebase = (base, dir) => shim$1.path.relative(base, dir);
    function isYargsInstance(y) {
      return !!y && typeof y._parseArgs === "function";
    }
    var _a;
    var _b;
    var { readFileSync } = require("fs");
    var { inspect } = require("util");
    var { resolve } = require("path");
    var y18n = require_build2();
    var Parser = require_build3();
    var cjsPlatformShim = {
      assert: {
        notStrictEqual: assert.notStrictEqual,
        strictEqual: assert.strictEqual
      },
      cliui: require_build4(),
      findUp: require_sync(),
      getEnv: (key) => {
        return process.env[key];
      },
      getCallerFile: require_get_caller_file(),
      getProcessArgvBin,
      inspect,
      mainFilename: (_b = (_a = require === null || require === void 0 ? void 0 : require.main) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : process.cwd(),
      Parser,
      path: require("path"),
      process: {
        argv: () => process.argv,
        cwd: process.cwd,
        execPath: () => process.execPath,
        exit: (code) => {
          process.exit(code);
        },
        nextTick: process.nextTick,
        stdColumns: typeof process.stdout.columns !== "undefined" ? process.stdout.columns : null
      },
      readFileSync,
      require,
      requireDirectory: require_require_directory(),
      stringWidth: require_string_width(),
      y18n: y18n({
        directory: resolve(__dirname, "../locales"),
        updateFiles: false
      })
    };
    var minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 10;
    if (process && process.version) {
      const major = Number(process.version.match(/v([^.]+)/)[1]);
      if (major < minNodeVersion) {
        throw Error(`yargs supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs#supported-nodejs-versions`);
      }
    }
    var Parser$1 = require_build3();
    var Yargs$1 = YargsWithShim(cjsPlatformShim);
    var cjs = {
      applyExtends,
      cjsPlatformShim,
      Yargs: Yargs$1,
      argsert,
      globalMiddlewareFactory,
      isPromise,
      objFilter,
      parseCommand,
      Parser: Parser$1,
      processArgv,
      rebase,
      YError
    };
    module2.exports = cjs;
  }
});

// node_modules/yargs/index.cjs
var require_yargs = __commonJS({
  "node_modules/yargs/index.cjs"(exports2, module2) {
    "use strict";
    var { Yargs, processArgv } = require_build5();
    Argv(processArgv.hideBin(process.argv));
    module2.exports = Argv;
    function Argv(processArgs, cwd) {
      const argv = Yargs(processArgs, cwd, require);
      singletonify(argv);
      return argv;
    }
    function singletonify(inst) {
      Object.keys(inst).forEach((key) => {
        if (key === "argv") {
          Argv.__defineGetter__(key, inst.__lookupGetter__(key));
        } else if (typeof inst[key] === "function") {
          Argv[key] = inst[key].bind(inst);
        } else {
          Argv.__defineGetter__("$0", () => {
            return inst.$0;
          });
          Argv.__defineGetter__("parsed", () => {
            return inst.parsed;
          });
        }
      });
    }
  }
});

// node_modules/nconf/lib/nconf/stores/argv.js
var require_argv = __commonJS({
  "node_modules/nconf/lib/nconf/stores/argv.js"(exports2) {
    var util = require("util");
    var common = require_common3();
    var Memory = require_memory().Memory;
    var Argv = exports2.Argv = function(options, usage) {
      Memory.call(this, options);
      options = options || {};
      this.type = "argv";
      this.readOnly = true;
      this.options = options;
      this.usage = usage;
      if (typeof options.parseValues === "boolean") {
        this.parseValues = options.parseValues;
        delete options.parseValues;
      } else {
        this.parseValues = false;
      }
      if (typeof options.transform === "function") {
        this.transform = options.transform;
        delete options.transform;
      } else {
        this.transform = false;
      }
      if (typeof options.separator === "string" || options.separator instanceof RegExp) {
        this.separator = options.separator;
        delete options.separator;
      } else {
        this.separator = "";
      }
    };
    util.inherits(Argv, Memory);
    Argv.prototype.loadSync = function() {
      this.loadArgv();
      return this.store;
    };
    Argv.prototype.loadArgv = function() {
      var self2 = this, yargs, argv;
      yargs = isYargs(this.options) ? this.options : typeof this.options === "object" ? require_yargs()(process.argv.slice(2)).options(this.options) : require_yargs()(process.argv.slice(2));
      if (typeof this.usage === "string") {
        yargs.usage(this.usage);
      }
      argv = yargs.argv;
      if (!argv) {
        return;
      }
      if (this.transform) {
        argv = common.transform(argv, this.transform);
      }
      this.readOnly = false;
      Object.keys(argv).forEach(function(key) {
        var val = argv[key];
        if (typeof val !== "undefined") {
          if (self2.parseValues) {
            val = common.parseValues(val);
          }
          if (self2.separator) {
            self2.set(common.key.apply(common, key.split(self2.separator)), val);
          } else {
            self2.set(key, val);
          }
        }
      });
      this.showHelp = yargs.showHelp;
      this.help = yargs.help;
      this.readOnly = true;
      return this.store;
    };
    function isYargs(obj) {
      return (typeof obj === "function" || typeof obj === "object") && "argv" in obj;
    }
  }
});

// node_modules/nconf/lib/nconf/stores/env.js
var require_env = __commonJS({
  "node_modules/nconf/lib/nconf/stores/env.js"(exports2) {
    var util = require("util");
    var common = require_common3();
    var Memory = require_memory().Memory;
    var Env = exports2.Env = function(options) {
      Memory.call(this, options);
      options = options || {};
      this.type = "env";
      this.readOnly = true;
      this.whitelist = options.whitelist || [];
      this.separator = options.separator || "";
      this.lowerCase = options.lowerCase || false;
      this.parseValues = options.parseValues || false;
      this.transform = options.transform || false;
      if ({}.toString.call(options.match) === "[object RegExp]" && typeof options !== "string") {
        this.match = options.match;
      }
      if (options instanceof Array) {
        this.whitelist = options;
      }
      if (typeof options === "string" || options instanceof RegExp) {
        this.separator = options;
      }
    };
    util.inherits(Env, Memory);
    Env.prototype.loadSync = function() {
      this.loadEnv();
      return this.store;
    };
    Env.prototype.loadEnv = function() {
      var self2 = this;
      var env = process.env;
      if (this.lowerCase) {
        env = {};
        Object.keys(process.env).forEach(function(key) {
          env[key.toLowerCase()] = process.env[key];
        });
      }
      if (this.transform) {
        env = common.transform(env, this.transform);
      }
      this.readOnly = false;
      Object.keys(env).filter(function(key) {
        if (self2.match && self2.whitelist.length) {
          return key.match(self2.match) || self2.whitelist.indexOf(key) !== -1;
        } else if (self2.match) {
          return key.match(self2.match);
        } else {
          return !self2.whitelist.length || self2.whitelist.indexOf(key) !== -1;
        }
      }).forEach(function(key) {
        var val = env[key];
        if (self2.parseValues) {
          val = common.parseValues(val);
        }
        if (self2.separator) {
          self2.set(common.key.apply(common, key.split(self2.separator)), val);
        } else {
          self2.set(key, val);
        }
      });
      this.readOnly = true;
      return this.store;
    };
  }
});

// node_modules/secure-keys/index.js
var require_secure_keys = __commonJS({
  "node_modules/secure-keys/index.js"(exports2, module2) {
    "use strict";
    var crypto4 = require("crypto");
    var json = {
      stringify: function(obj, replacer, spacing) {
        return JSON.stringify(obj, replacer || null, spacing || 2);
      },
      parse: JSON.parse
    };
    module2.exports = Secure;
    function Secure(opts) {
      opts = opts || {};
      this.secret = typeof opts !== "string" ? opts.secret : opts;
      this.format = opts.format || json;
      this.alg = opts.alg || "aes-256-ctr";
      if (!this.secret) throw new Error("Secret is a required option");
    }
    Secure.prototype.encrypt = function encrypt(data, callback) {
      var self2 = this;
      return Object.keys(data).reduce(function(acc, key) {
        var value = self2.format.stringify(data[key]);
        acc[key] = {
          alg: self2.alg,
          value: cipherConvert(value, {
            alg: self2.alg,
            secret: self2.secret,
            encs: { input: "utf8", output: "hex" }
          })
        };
        return acc;
      }, {});
    };
    Secure.prototype.decrypt = function decrypt(data, callback) {
      var self2 = this;
      return Object.keys(data).reduce(function(acc, key) {
        var decrypted = cipherConvert(data[key].value, {
          alg: data[key].alg || self2.alg,
          secret: self2.secret,
          encs: { input: "hex", output: "utf8" }
        });
        acc[key] = self2.format.parse(decrypted);
        return acc;
      }, {});
    };
    function cipherConvert(contents, opts) {
      var encs = opts.encs;
      var cipher = crypto4.createCipher(opts.alg, opts.secret);
      return cipher.update(contents, encs.input, encs.output) + cipher.final(encs.output);
    }
  }
});

// node_modules/nconf/lib/nconf/stores/file.js
var require_file2 = __commonJS({
  "node_modules/nconf/lib/nconf/stores/file.js"(exports2) {
    var fs = require("fs");
    var path = require("path");
    var util = require("util");
    var Secure = require_secure_keys();
    var formats = require_formats();
    var Memory = require_memory().Memory;
    var exists = fs.exists || path.exists;
    var existsSync = fs.existsSync || path.existsSync;
    var File = exports2.File = function(options) {
      if (!options || !options.file) {
        throw new Error("Missing required option `file`");
      }
      Memory.call(this, options);
      this.type = "file";
      this.file = options.file;
      this.dir = options.dir || process.cwd();
      this.format = options.format || formats.json;
      this.secure = options.secure;
      this.spacing = options.json_spacing || options.spacing || 2;
      if (this.secure) {
        this.secure = Buffer.isBuffer(this.secure) || typeof this.secure === "string" ? { secret: this.secure.toString() } : this.secure;
        this.secure.alg = this.secure.alg || "aes-256-ctr";
        if (this.secure.secretPath) {
          this.secure.secret = fs.readFileSync(this.secure.secretPath, "utf8");
        }
        if (!this.secure.secret) {
          throw new Error("secure.secret option is required");
        }
        this.keys = new Secure({
          secret: this.secure.secret,
          alg: this.secure.alg,
          format: this.format
        });
      }
      if (options.search) {
        this.search(this.dir);
      }
    };
    util.inherits(File, Memory);
    File.prototype.save = function(value, callback) {
      this.saveToFile(this.file, value, callback);
    };
    File.prototype.saveToFile = function(path2, format, callback) {
      if (!callback) {
        callback = format;
        format = this.format;
      }
      fs.writeFile(path2, this.stringify(format), callback);
    };
    File.prototype.saveSync = function() {
      fs.writeFileSync(this.file, this.stringify());
      return this.store;
    };
    File.prototype.load = function(callback) {
      var self2 = this;
      exists(self2.file, function(exists2) {
        if (!exists2) {
          return callback(null, {});
        }
        fs.readFile(self2.file, function(err, data) {
          if (err) {
            return callback(err);
          }
          try {
            var stringData = data.toString();
            if (stringData.charAt(0) === "\uFEFF") {
              stringData = stringData.substr(1);
            }
            self2.store = self2.parse(stringData);
          } catch (ex) {
            return callback(new Error("Error parsing your configuration file: [" + self2.file + "]: " + ex.message));
          }
          callback(null, self2.store);
        });
      });
    };
    File.prototype.loadSync = function() {
      if (!existsSync(this.file)) {
        this.store = {};
        return this.store;
      }
      try {
        var fileData = fs.readFileSync(this.file, "utf8");
        if (fileData.charAt(0) === "\uFEFF") {
          fileData = fileData.substr(1);
        }
        this.store = this.parse(fileData);
      } catch (ex) {
        throw new Error("Error parsing your configuration file: [" + this.file + "]: " + ex.message);
      }
      return this.store;
    };
    File.prototype.stringify = function(format) {
      var data = this.store;
      if (!format) {
        format = this.format;
      }
      if (this.secure) {
        data = this.keys.encrypt(data);
      }
      return format.stringify(data, null, this.spacing);
    };
    File.prototype.parse = function(contents) {
      var parsed = this.format.parse(contents);
      if (!this.secure) {
        return parsed;
      }
      return this.keys.decrypt(parsed);
    };
    File.prototype.search = function(base) {
      var looking = true, fullpath, previous, stats;
      base = base || process.cwd();
      if (this.file[0] === "/") {
        try {
          stats = fs.statSync(fs.realpathSync(this.file));
          if (stats.isFile()) {
            fullpath = this.file;
            looking = false;
          }
        } catch (ex) {
        }
      }
      if (looking && base) {
        try {
          var stat = fs.statSync(fs.realpathSync(base));
          looking = stat.isDirectory();
        } catch (ex) {
          return false;
        }
      }
      while (looking) {
        try {
          stats = fs.statSync(fs.realpathSync(fullpath = path.join(base, this.file)));
          looking = stats.isDirectory();
        } catch (ex) {
          previous = base;
          base = path.dirname(base);
          if (previous === base) {
            try {
              stats = fs.statSync(fs.realpathSync(fullpath = path.join(this.dir, this.file)));
              if (stats.isDirectory()) {
                fullpath = void 0;
              }
            } catch (ex2) {
            }
            looking = false;
          }
        }
      }
      this.file = fullpath || this.file;
      return fullpath;
    };
  }
});

// node_modules/nconf/lib/nconf/stores/literal.js
var require_literal = __commonJS({
  "node_modules/nconf/lib/nconf/stores/literal.js"(exports2) {
    var util = require("util");
    var Memory = require_memory().Memory;
    var Literal = exports2.Literal = function Literal2(options) {
      Memory.call(this, options);
      options = options || {};
      this.type = "literal";
      this.readOnly = true;
      this.store = options.store || options;
    };
    util.inherits(Literal, Memory);
    Literal.prototype.loadSync = function() {
      return this.store;
    };
  }
});

// require("./nconf/stores/**/*") in node_modules/nconf/lib/nconf.js
var globRequire_nconf_stores;
var init_ = __esm({
  'require("./nconf/stores/**/*") in node_modules/nconf/lib/nconf.js'() {
    globRequire_nconf_stores = __glob({
      "./nconf/stores/argv.js": () => require_argv(),
      "./nconf/stores/env.js": () => require_env(),
      "./nconf/stores/file.js": () => require_file2(),
      "./nconf/stores/literal.js": () => require_literal(),
      "./nconf/stores/memory.js": () => require_memory()
    });
  }
});

// node_modules/nconf/lib/nconf/provider.js
var require_provider = __commonJS({
  "node_modules/nconf/lib/nconf/provider.js"(exports2) {
    var async = require_async();
    var common = require_common3();
    var Provider = exports2.Provider = function(options) {
      options = options || {};
      this.stores = {};
      this.sources = [];
      this.init(options);
    };
    ["argv", "env"].forEach(function(type) {
      Provider.prototype[type] = function() {
        var args = [type].concat(Array.prototype.slice.call(arguments));
        return this.add.apply(this, args);
      };
    });
    Provider.prototype.file = function(key, options) {
      if (arguments.length == 1) {
        options = typeof key === "string" ? { file: key } : key;
        key = "file";
      } else {
        options = typeof options === "string" ? { file: options } : options;
      }
      options.type = "file";
      return this.add(key, options);
    };
    ["defaults", "overrides"].forEach(function(type) {
      Provider.prototype[type] = function(options) {
        options = options || {};
        if (!options.type) {
          options.type = "literal";
        }
        return this.add(type, options);
      };
    });
    Provider.prototype.use = function(name, options) {
      options = options || {};
      function sameOptions(store2) {
        return Object.keys(options).every(function(key) {
          return options[key] === store2[key];
        });
      }
      var store = this.stores[name], update = store && !sameOptions(store);
      if (!store || update) {
        if (update) {
          this.remove(name);
        }
        this.add(name, options);
      }
      return this;
    };
    Provider.prototype.add = function(name, options, usage) {
      options = options || {};
      var type = options.type || name;
      if (!require_nconf()[common.capitalize(type)]) {
        throw new Error("Cannot add store with unknown type: " + type);
      }
      this.stores[name] = this.create(type, options, usage);
      if (this.stores[name].loadSync) {
        this.stores[name].loadSync();
      }
      return this;
    };
    Provider.prototype.remove = function(name) {
      delete this.stores[name];
      return this;
    };
    Provider.prototype.create = function(type, options, usage) {
      return new (require_nconf())[common.capitalize(type.toLowerCase())](options, usage);
    };
    Provider.prototype.init = function(options) {
      var self2 = this;
      if (options.type) {
        this.add(options.type, options);
      } else if (options.store) {
        this.add(options.store.name || options.store.type, options.store);
      } else if (options.stores) {
        Object.keys(options.stores).forEach(function(name) {
          var store = options.stores[name];
          self2.add(store.name || name || store.type, store);
        });
      }
      if (options.source) {
        this.sources.push(this.create(options.source.type || options.source.name, options.source));
      } else if (options.sources) {
        Object.keys(options.sources).forEach(function(name) {
          var source = options.sources[name];
          self2.sources.push(self2.create(source.type || source.name || name, source));
        });
      }
    };
    Provider.prototype.get = function(key, callback) {
      if (typeof key === "function") {
        callback = key;
        key = null;
      }
      if (!callback) {
        return this._execute("get", 1, key, callback);
      }
      var current = 0, names = Object.keys(this.stores), self2 = this, response, mergeObjs = [];
      async.whilst(function(cb) {
        cb(null, typeof response === "undefined" && current < names.length);
      }, function(next) {
        var store = self2.stores[names[current]];
        current++;
        if (store.get.length >= 2) {
          return store.get(key, function(err, value) {
            if (err) {
              return next(err);
            }
            response = value;
            if (response && typeof response === "object" && !Array.isArray(response)) {
              mergeObjs.push(response);
              response = void 0;
            }
            next();
          });
        }
        response = store.get(key);
        if (response && typeof response === "object" && !Array.isArray(response)) {
          mergeObjs.push(response);
          response = void 0;
        }
        next();
      }, function(err) {
        if (!err && mergeObjs.length) {
          response = common.merge(mergeObjs.reverse());
        }
        return err ? callback(err) : callback(null, response);
      });
    };
    Provider.prototype.any = function(keys, callback) {
      if (!Array.isArray(keys)) {
        keys = Array.prototype.slice.call(arguments);
        if (keys.length > 0 && typeof keys[keys.length - 1] === "function") {
          callback = keys.pop();
        } else {
          callback = null;
        }
      }
      if (!callback) {
        var val;
        for (var i = 0; i < keys.length; ++i) {
          val = this._execute("get", 1, keys[i], callback);
          if (val) {
            return val;
          }
        }
        return null;
      }
      var keyIndex = 0, result, self2 = this;
      async.whilst(function(cb) {
        cb(null, !result && keyIndex < keys.length);
      }, function(next) {
        var key = keys[keyIndex];
        keyIndex++;
        self2.get(key, function(err, v) {
          if (err) {
            next(err);
          } else {
            result = v;
            next();
          }
        });
      }, function(err) {
        return err ? callback(err) : callback(null, result);
      });
    };
    Provider.prototype.set = function(key, value, callback) {
      return this._execute("set", 2, key, value, callback);
    };
    Provider.prototype.required = function(keys) {
      if (!Array.isArray(keys)) {
        throw new Error("Incorrect parameter, array expected");
      }
      var missing = [];
      keys.forEach(function(key) {
        if (typeof this.get(key) === "undefined") {
          missing.push(key);
        }
      }, this);
      if (missing.length) {
        throw new Error("Missing required keys: " + missing.join(", "));
      } else {
        return true;
      }
    };
    Provider.prototype.reset = function(callback) {
      return this._execute("reset", 0, callback);
    };
    Provider.prototype.clear = function(key, callback) {
      return this._execute("clear", 1, key, callback);
    };
    Provider.prototype.merge = function() {
      var self2 = this, args = Array.prototype.slice.call(arguments), callback = typeof args[args.length - 1] === "function" && args.pop(), value = args.pop(), key = args.pop();
      function mergeProperty(prop, next) {
        return self2._execute("merge", 2, prop, value[prop], next);
      }
      if (!key) {
        if (Array.isArray(value) || typeof value !== "object") {
          return onError(new Error("Cannot merge non-Object into top-level."), callback);
        }
        return async.forEach(Object.keys(value), mergeProperty, callback || function() {
        });
      }
      return this._execute("merge", 2, key, value, callback);
    };
    Provider.prototype.load = function(callback) {
      var self2 = this;
      function getStores() {
        var stores = Object.keys(self2.stores);
        stores.reverse();
        return stores.map(function(name) {
          return self2.stores[name];
        });
      }
      function loadStoreSync(store) {
        if (!store.loadSync) {
          throw new Error("nconf store " + store.type + " has no loadSync() method");
        }
        return store.loadSync();
      }
      function loadStore(store, next) {
        if (!store.load && !store.loadSync) {
          return next(new Error("nconf store " + store.type + " has no load() method"));
        }
        return store.loadSync ? next(null, store.loadSync()) : store.load(next);
      }
      function loadBatch(targets, done) {
        if (!done) {
          return common.merge(targets.map(loadStoreSync));
        }
        async.map(targets, loadStore, function(err, objs) {
          return err ? done(err) : done(null, common.merge(objs));
        });
      }
      function mergeSources(data) {
        if (data && typeof data === "object") {
          self2.use("sources", {
            type: "literal",
            store: data
          });
        }
      }
      function loadSources() {
        var sourceHierarchy = self2.sources.splice(0);
        sourceHierarchy.reverse();
        if (!callback) {
          mergeSources(loadBatch(sourceHierarchy));
          return loadBatch(getStores());
        }
        loadBatch(sourceHierarchy, function(err, data) {
          if (err) {
            return callback(err);
          }
          mergeSources(data);
          return loadBatch(getStores(), callback);
        });
      }
      return self2.sources.length ? loadSources() : loadBatch(getStores(), callback);
    };
    Provider.prototype.save = function(value, callback) {
      if (!callback && typeof value === "function") {
        callback = value;
        value = null;
      }
      var self2 = this, names = Object.keys(this.stores);
      function saveStoreSync(memo, name) {
        var store = self2.stores[name];
        if (store.saveSync) {
          var ret = store.saveSync();
          if (typeof ret == "object" && ret !== null) {
            memo.push(ret);
          }
        }
        return memo;
      }
      function saveStore(memo, name, next) {
        var store = self2.stores[name];
        if (store.save) {
          return store.save(value, function(err, data) {
            if (err) {
              return next(err);
            }
            if (typeof data == "object" && data !== null) {
              memo.push(data);
            }
            next(null, memo);
          });
        } else if (store.saveSync) {
          memo.push(store.saveSync());
        }
        next(null, memo);
      }
      if (!callback) {
        return common.merge(names.reduce(saveStoreSync, []));
      }
      async.reduce(names, [], saveStore, function(err, objs) {
        return err ? callback(err) : callback(null, common.merge(objs));
      });
    };
    Provider.prototype._execute = function(action, syncLength) {
      var args = Array.prototype.slice.call(arguments, 2), callback = typeof args[args.length - 1] === "function" && args.pop(), destructive = ["set", "clear", "merge", "reset"].indexOf(action) !== -1, self2 = this, response, mergeObjs = [], keys = Object.keys(this.stores);
      function runAction(name, next) {
        var store = self2.stores[name];
        if (destructive && store.readOnly) {
          return next();
        }
        return store[action].length > syncLength ? store[action].apply(store, args.concat(next)) : next(null, store[action].apply(store, args));
      }
      if (callback) {
        return async.forEach(keys, runAction, function(err) {
          return err ? callback(err) : callback();
        });
      }
      keys.forEach(function(name) {
        if (typeof response === "undefined") {
          var store = self2.stores[name];
          if (destructive && store.readOnly) {
            return;
          }
          response = store[action].apply(store, args);
          if (response && action === "get" && typeof response === "object" && !Array.isArray(response)) {
            mergeObjs.push(response);
            response = void 0;
          }
        }
      });
      if (mergeObjs.length) {
        response = common.merge(mergeObjs.reverse());
      }
      return response;
    };
    function onError(err, callback) {
      if (callback) {
        return callback(err);
      }
      throw err;
    }
  }
});

// node_modules/nconf/package.json
var require_package3 = __commonJS({
  "node_modules/nconf/package.json"(exports2, module2) {
    module2.exports = {
      name: "nconf",
      description: "Hierarchical node.js configuration with files, environment variables, command-line arguments, and atomic object merging.",
      version: "0.12.0",
      author: "Charlie Robbins <charlie.robbins@gmail.com>",
      contributors: [
        "Matt Hamann <matthew.hamann@gmail.com>",
        "Maciej Ma\u0142ecki <me@mmalecki.com>",
        "Jarrett Cruger <jcrugzz@gmail.com>",
        "Adrien Becchis"
      ],
      repository: {
        type: "git",
        url: "http://github.com/flatiron/nconf.git"
      },
      keywords: [
        "configuration",
        "key value store",
        "plugabble"
      ],
      dependencies: {
        async: "^3.0.0",
        ini: "^2.0.0",
        "secure-keys": "^1.0.0",
        yargs: "^16.1.1"
      },
      devDependencies: {
        coveralls: "^3.1.0",
        eslint: "^7.0.0",
        "nconf-yaml": "^1.0.2",
        nyc: "^15.1.0",
        vows: "^0.8.3"
      },
      main: "./lib/nconf",
      scripts: {
        test: "vows test/*-test.js test/**/*-test.js --spec",
        cover: "nyc --reporter=lcov npm test",
        coveralls: "cat coverage/lcov.info | coveralls",
        lint: "eslint ."
      },
      engines: {
        node: ">= 0.4.0"
      },
      license: "MIT"
    };
  }
});

// node_modules/nconf/lib/nconf.js
var require_nconf = __commonJS({
  "node_modules/nconf/lib/nconf.js"(exports2, module2) {
    init_();
    var common = require_common3();
    var Provider = require_provider().Provider;
    var nconf = module2.exports = new Provider();
    nconf.version = require_package3().version;
    ["argv", "env", "file", "literal", "memory"].forEach(function(store) {
      var name = common.capitalize(store);
      nconf.__defineGetter__(name, function() {
        return globRequire_nconf_stores("./nconf/stores/" + store)[name];
      });
    });
    nconf.key = common.key;
    nconf.path = common.path;
    nconf.loadFiles = common.loadFiles;
    nconf.loadFilesSync = common.loadFilesSync;
    nconf.formats = require_formats();
    nconf.Provider = Provider;
  }
});

// node_modules/app-root-path/lib/resolve.js
var require_resolve = __commonJS({
  "node_modules/app-root-path/lib/resolve.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var globalPaths = require("module").globalPaths;
    var npmGlobalPrefix;
    if ("win32" === process.platform) {
      npmGlobalPrefix = path.dirname(process.execPath);
    } else {
      npmGlobalPrefix = path.dirname(path.dirname(process.execPath));
    }
    var npmGlobalModuleDir = path.resolve(npmGlobalPrefix, "lib", "node_modules");
    var sep = path.sep;
    var requireFunction = "function" === typeof __webpack_require__ || "function" === typeof __non_webpack_require__ ? __non_webpack_require__ : require;
    var isInstalledWithPNPM = function(resolved) {
      const pnpmDir = sep + ".pnpm";
      for (const globalPath of globalPaths) {
        if (-1 !== globalPath.indexOf(pnpmDir) && -1 !== resolved.indexOf(pnpmDir)) {
          return true;
        }
      }
      return false;
    };
    var getFirstPartFromNodeModules = function(resolved) {
      const nodeModulesDir = sep + "node_modules";
      if (-1 !== resolved.indexOf(nodeModulesDir)) {
        const parts = resolved.split(nodeModulesDir);
        if (parts.length) {
          return parts[0];
        }
      }
      return null;
    };
    module2.exports = function resolve(dirname) {
      if (process.env.APP_ROOT_PATH) {
        return path.resolve(process.env.APP_ROOT_PATH);
      }
      if (process.versions.pnp) {
        try {
          var pnp = requireFunction("pnpapi");
          return pnp.getPackageInformation(pnp.topLevel).packageLocation;
        } catch (e) {
        }
      }
      if ("undefined" !== typeof window && window.process && "renderer" === window.process.type) {
        try {
          var remote = requireFunction("electron").remote;
          return remote.require("app-root-path").path;
        } catch (e) {
        }
      }
      if (process.env.LAMBDA_TASK_ROOT && process.env.AWS_EXECUTION_ENV) {
        return process.env.LAMBDA_TASK_ROOT;
      }
      var resolved = path.resolve(dirname);
      var alternateMethod = false;
      var appRootPath = null;
      if (isInstalledWithPNPM(resolved)) {
        appRootPath = getFirstPartFromNodeModules(resolved);
        if (appRootPath) {
          return appRootPath;
        }
      }
      globalPaths.forEach(function(globalPath) {
        if (!alternateMethod && 0 === resolved.indexOf(globalPath)) {
          alternateMethod = true;
        }
      });
      if (!alternateMethod) {
        appRootPath = getFirstPartFromNodeModules(resolved);
      }
      if (alternateMethod || null == appRootPath) {
        appRootPath = path.dirname(requireFunction.main.filename);
      }
      if (alternateMethod && -1 !== appRootPath.indexOf(npmGlobalModuleDir) && appRootPath.length - 4 === appRootPath.indexOf(sep + "bin")) {
        appRootPath = appRootPath.slice(0, -4);
      }
      return appRootPath;
    };
  }
});

// node_modules/app-root-path/lib/app-root-path.js
var require_app_root_path = __commonJS({
  "node_modules/app-root-path/lib/app-root-path.js"(exports2, module2) {
    "use strict";
    module2.exports = function(dirname) {
      var path = require("path");
      var resolve = require_resolve();
      var appRootPath = resolve(dirname);
      var publicInterface = {
        resolve: function(pathToModule) {
          return path.join(appRootPath, pathToModule);
        },
        require: function(pathToModule) {
          return require(publicInterface.resolve(pathToModule));
        },
        toString: function() {
          return appRootPath;
        },
        setPath: function(explicitlySetPath) {
          appRootPath = path.resolve(explicitlySetPath);
          publicInterface.path = appRootPath;
        },
        path: appRootPath
      };
      return publicInterface;
    };
  }
});

// node_modules/app-root-path/index.js
var require_app_root_path2 = __commonJS({
  "node_modules/app-root-path/index.js"(exports2, module2) {
    "use strict";
    var lib = require_app_root_path();
    module2.exports = lib(__dirname);
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/defaults.js
var require_defaults = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/defaults.js"(exports2) {
    var os = require("os");
    var path = require("path");
    exports2.getDefaultTempDirectory = () => {
      return path.join(os.tmpdir(), "jsreport");
    };
    exports2.getDefaultRootDirectory = () => {
      return path.join(__dirname, "../../../../../");
    };
    exports2.getDefaultLoadConfig = () => {
      return false;
    };
  }
});

// node_modules/deepmerge/dist/umd.js
var require_umd = __commonJS({
  "node_modules/deepmerge/dist/umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.deepmerge = factory();
    })(exports2, function() {
      "use strict";
      var isMergeableObject = function isMergeableObject2(value) {
        return isNonNullObject(value) && !isSpecial(value);
      };
      function isNonNullObject(value) {
        return !!value && typeof value === "object";
      }
      function isSpecial(value) {
        var stringValue = Object.prototype.toString.call(value);
        return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
      }
      var canUseSymbol = typeof Symbol === "function" && Symbol.for;
      var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
      function isReactElement(value) {
        return value.$$typeof === REACT_ELEMENT_TYPE;
      }
      function emptyTarget(val) {
        return Array.isArray(val) ? [] : {};
      }
      function cloneUnlessOtherwiseSpecified(value, options) {
        return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
      }
      function defaultArrayMerge(target, source, options) {
        return target.concat(source).map(function(element) {
          return cloneUnlessOtherwiseSpecified(element, options);
        });
      }
      function mergeObject(target, source, options) {
        var destination = {};
        if (options.isMergeableObject(target)) {
          Object.keys(target).forEach(function(key) {
            destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
          });
        }
        Object.keys(source).forEach(function(key) {
          if (!options.isMergeableObject(source[key]) || !target[key]) {
            destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
          } else {
            destination[key] = deepmerge(target[key], source[key], options);
          }
        });
        return destination;
      }
      function deepmerge(target, source, options) {
        options = options || {};
        options.arrayMerge = options.arrayMerge || defaultArrayMerge;
        options.isMergeableObject = options.isMergeableObject || isMergeableObject;
        var sourceIsArray = Array.isArray(source);
        var targetIsArray = Array.isArray(target);
        var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
        if (!sourceAndTargetTypesMatch) {
          return cloneUnlessOtherwiseSpecified(source, options);
        } else if (sourceIsArray) {
          return options.arrayMerge(target, source, options);
        } else {
          return mergeObject(target, source, options);
        }
      }
      deepmerge.all = function deepmergeAll(array, options) {
        if (!Array.isArray(array)) {
          throw new Error("first argument should be an array");
        }
        return array.reduce(function(prev, next) {
          return deepmerge(prev, next, options);
        }, {});
      };
      var deepmerge_1 = deepmerge;
      return deepmerge_1;
    });
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/optionsSchema.js
var require_optionsSchema = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/optionsSchema.js"(exports2, module2) {
    var { getDefaultTempDirectory, getDefaultLoadConfig } = require_defaults();
    var deepMerge = require_umd();
    module2.exports.getRootSchemaOptions = () => ({
      type: "object",
      properties: {
        rootDirectory: {
          type: "string",
          description: "specifies where is the application root and where jsreport searches for extensions"
        },
        appDirectory: {
          type: "string",
          description: "specifies directory of the script that was used to start node.js, this value is mostly metadata that is useful for your own code inside jsreport scripts"
        },
        tempDirectory: {
          type: "string",
          default: getDefaultTempDirectory(),
          description: "specifies where jsreport stores temporary files used by the conversion pipeline"
        },
        loadConfig: {
          type: "boolean",
          default: getDefaultLoadConfig(),
          description: "specifies if jsreport should load configuration values from external sources (cli args, env vars, configuration files) or not"
        },
        autoTempCleanup: {
          type: "boolean",
          default: true,
          description: "specifies if after some interval jsreport should automatically clean up temporary files generated while rendering reports"
        },
        discover: {
          type: "boolean",
          defaultNotInitialized: true,
          description: "specifies if jsreport should discover/search installed extensions in project and use them automatically"
        },
        useExtensionsLocationCache: {
          type: "boolean",
          default: true,
          description: "whether if jsreport should read list of extensions from a previous generated cache or if it should crawl and try to search extensions again, set it to false when you want to always force crawling node_modules when searching for extensions while starting jsreport"
        },
        logger: {
          type: "object",
          properties: {
            silent: { type: "boolean" }
          }
        },
        reportTimeout: {
          type: ["string", "number"],
          "$jsreport-acceptsDuration": true,
          description: "global single timeout that controls how much a report generation should wait before it times out",
          default: 6e4
        },
        reportTimeoutMargin: {
          type: ["string", "number"],
          description: "the time to wait before the worker thread is forcibly  killed after timeout",
          "$jsreport-acceptsDuration": true,
          default: "2s"
        },
        enableRequestReportTimeout: { type: "boolean", default: false, description: "option that enables passing a custom report timeout per request using req.options.timeout. this enables that the caller of the report generation control the report timeout so enable it only when you trust the caller" },
        trustUserCode: { type: "boolean", default: false, description: "option that control whether code sandboxing is enabled or not, code sandboxing has an impact on performance when rendering large reports. when true code sandboxing will be disabled meaning that users can potentially penetrate the local system if you allow code from external users to be part of your reports" },
        allowLocalFilesAccess: { type: "boolean", default: false },
        encryption: {
          type: "object",
          default: {},
          properties: {
            secretKey: {
              type: "string",
              minLength: 16,
              maxLength: 16
            },
            enabled: {
              type: "boolean",
              default: true
            }
          }
        },
        sandbox: {
          type: "object",
          default: {},
          properties: {
            isolateModules: { type: "boolean", default: true, description: "option that control whether require/import of modules during rendering are isolated from other renders or not. when this is false the require/import of modules will behave like normal require, which means that module is evaluated only once and next require/import are resolved from a cache" },
            allowedModules: {
              anyOf: [{
                type: "string",
                "$jsreport-constantOrArray": ["*"]
              }, {
                type: "array",
                items: { type: "string" }
              }]
            },
            cache: {
              type: "object",
              default: {},
              properties: {
                max: { type: "number", default: 100 },
                enabled: { type: "boolean", default: true }
              }
            }
          }
        },
        workers: {
          type: "object",
          default: {},
          properties: {
            numberOfWorkers: {
              type: "number",
              default: 2,
              description: "Number of workers allocated. Every worker can process a single request in parallel. This means increasing numberOfWorkers will increase the parallelization."
            },
            initTimeout: {
              type: ["string", "number"],
              "$jsreport-acceptsDuration": true,
              description: "Timeout for initializing a worker thread. This should be increased only when running at very slow HW environment.",
              default: "30s"
            },
            resourceLimits: {
              type: "object",
              description: "Limits for the individual workers. See https://nodejs.org/api/worker_threads.html#worker_threads_worker_resourcelimits",
              properties: {
                maxOldGenerationSizeMb: { type: "number" },
                maxYoungGenerationSizeMb: { type: "number" },
                codeRangeSizeMb: { type: "number" },
                stackSizeMb: { type: "number" }
              }
            }
          }
        },
        store: {
          type: "object",
          properties: {
            provider: { type: "string", enum: ["memory"] },
            transactions: {
              type: "object",
              properties: {
                enabled: { type: "boolean", default: true }
              }
            }
          }
        },
        blobStorage: {
          type: "object",
          properties: {
            provider: { type: "string", enum: ["memory"] }
          }
        },
        extensions: {
          type: "object",
          properties: {}
        },
        extensionsList: {
          anyOf: [
            {
              type: "string",
              "$jsreport-constantOrArray": []
            },
            {
              type: "array",
              items: { type: "string" }
            }
          ]
        },
        profiler: {
          type: "object",
          default: {},
          properties: {
            defaultMode: {
              type: "string",
              default: "standard"
            },
            fullModeDurationCheckInterval: {
              type: ["string", "number"],
              "$jsreport-acceptsDuration": true,
              default: "10m"
            },
            fullModeDuration: {
              type: ["string", "number"],
              "$jsreport-acceptsDuration": true,
              default: "4h"
            },
            maxProfilesHistory: {
              type: "number",
              default: 1e3
            },
            cleanupInterval: {
              type: ["string", "number"],
              "$jsreport-acceptsDuration": true,
              default: "1m"
            },
            maxUnallocatedProfileAge: {
              type: ["string", "number"],
              "$jsreport-acceptsDuration": true,
              default: "24h"
            },
            maxDiffSize: {
              type: ["string", "number"],
              "$jsreport-acceptsSize": true,
              default: "50mb"
            }
          }
        }
      }
    });
    module2.exports.extendRootSchemaOptions = (rootSchema, schema2) => {
      const schemasToApply = Array.isArray(schema2) ? schema2 : [schema2];
      rootSchema.properties = rootSchema.properties || {};
      rootSchema.properties.extensions = rootSchema.properties.extensions || {
        type: "object",
        properties: {}
      };
      schemasToApply.forEach((sch) => {
        if (sch == null) {
          return;
        }
        if (sch.schema == null && sch.name != null) {
          rootSchema.properties.extensions.properties[sch.name] = {
            type: "object",
            properties: {
              enabled: { type: "boolean" }
            }
          };
          return;
        } else if (sch.schema == null) {
          return;
        }
        Object.keys(sch.schema).forEach((key) => {
          const current = sch.schema[key];
          if (key === "extensions") {
            if (current == null) {
              return;
            }
            Object.keys(current).forEach((s) => {
              rootSchema.properties.extensions.properties[s] = deepMerge(rootSchema.properties.extensions.properties[s] || {}, current[s]);
              if (rootSchema.properties.extensions.properties[s].properties && rootSchema.properties.extensions.properties[s].properties.enabled == null) {
                rootSchema.properties.extensions.properties[s].properties.enabled = { type: "boolean" };
              }
            });
          } else if (current != null) {
            rootSchema.properties[key] = deepMerge(rootSchema.properties[key] || {}, current);
          }
        });
      });
      return rootSchema;
    };
    module2.exports.ignoreInitialSchemaProperties = [
      "properties.store.properties.provider",
      "properties.blobStorage.properties.provider"
    ];
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/optionsLoad.js
var require_optionsLoad = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/optionsLoad.js"(exports2, module2) {
    var path = require("path");
    var fs = require("fs");
    var extend = require_node_extend_without();
    var decamelize = require_decamelize();
    var nconf = require_nconf();
    var appRoot = require_app_root_path2();
    var { ignoreInitialSchemaProperties } = require_optionsSchema();
    var {
      getDefaultLoadConfig,
      getDefaultTempDirectory,
      getDefaultRootDirectory
    } = require_defaults();
    async function optionsLoad({
      defaults,
      options,
      validator,
      onConfigLoaded
    }) {
      let shouldLoadExternalConfig = defaults.loadConfig;
      if (options.loadConfig != null) {
        shouldLoadExternalConfig = options.loadConfig;
      }
      if (shouldLoadExternalConfig == null) {
        shouldLoadExternalConfig = getDefaultLoadConfig();
      }
      let loadConfigResult;
      if (shouldLoadExternalConfig) {
        loadConfigResult = await loadConfig(defaults, options);
      } else {
        loadConfigResult = await loadConfig(defaults, options, false);
      }
      const explicitOptions = loadConfigResult[0];
      const appliedConfigFile = loadConfigResult[1];
      options.loadConfig = shouldLoadExternalConfig;
      const rootOptionsValidation = validator.validateRoot(options, {
        rootPrefix: "rootOptions",
        ignore: ignoreInitialSchemaProperties
      });
      if (!rootOptionsValidation.valid) {
        throw new Error(`options contain values that does not match the defined base root schema. ${rootOptionsValidation.fullErrorMessage}`);
      }
      options.appDirectory = options.appDirectory || appRoot.toString();
      if (!options.parentModuleDirectory) {
        options.parentModuleDirectory = options.rootDirectory;
      }
      options.extensions = options.extensions || {};
      options.logger = options.logger || {};
      if (onConfigLoaded != null) {
        await onConfigLoaded();
      }
      if (options.tempDirectory && !path.isAbsolute(options.tempDirectory)) {
        options.tempDirectory = path.join(options.rootDirectory, options.tempDirectory);
      }
      options.tempDirectory = options.tempDirectory || getDefaultTempDirectory();
      options.tempAutoCleanupDirectory = path.join(options.tempDirectory, "autocleanup");
      options.tempCoreDirectory = path.join(options.tempDirectory, "core");
      options.store = options.store || { provider: "memory" };
      options.sandbox = options.sandbox || {};
      if (explicitOptions.allowLocalFilesAccess === true && explicitOptions.trustUserCode == null) {
        options.trustUserCode = true;
      }
      if (options.trustUserCode === true) {
        options.sandbox.allowedModules = "*";
      }
      options.sandbox.nativeModules = options.sandbox.nativeModules || [];
      options.sandbox.modules = options.sandbox.modules || [];
      options.sandbox.allowedModules = options.sandbox.allowedModules || [];
      if (!fs.existsSync(options.tempDirectory)) {
        fs.mkdirSync(options.tempDirectory, { recursive: true });
      }
      if (!fs.existsSync(options.tempAutoCleanupDirectory)) {
        fs.mkdirSync(options.tempAutoCleanupDirectory, { recursive: true });
      }
      if (!fs.existsSync(options.tempCoreDirectory)) {
        fs.mkdirSync(options.tempCoreDirectory, { recursive: true });
      }
      return [explicitOptions, appliedConfigFile];
    }
    async function loadConfig(defaults, options, loadExternal = true) {
      let loadedOptions = {};
      const nconfInstance = new nconf.Provider();
      let rootDirectory = options.rootDirectory || defaults.rootDirectory || getDefaultRootDirectory();
      if (options.rootDirectory) {
        loadedOptions.rootDirectory = options.rootDirectory;
      }
      let nfn = nconfInstance.overrides({ store: options });
      let appliedConfigFile = null;
      const makeTransform = ({ normalize, separator }) => (obj) => {
        let separators = !Array.isArray(separator) ? [separator] : separator;
        separators = separators.join("");
        if (normalize === true && obj.key === "extensions" && typeof obj.value === "object") {
          Object.keys(obj.value).forEach((extensionKey) => {
            const realExtensionName = decamelize(extensionKey, "-");
            const currentValue = obj.value[extensionKey];
            delete obj.value[extensionKey];
            obj.value[realExtensionName] = currentValue;
          });
        } else if (!normalize && obj.key.startsWith("extensions")) {
          const match = new RegExp(`extensions[${separators}](.[^${separators}]*)[${separators}]*.*`).exec(obj.key);
          if (!match) {
            return obj;
          }
          if (match.length < 2) {
            throw new Error(`Wrong configuration value ${obj.key}`);
          }
          const realExtensionName = decamelize(match[1], "-");
          obj.key = obj.key.replace(match[1], realExtensionName);
        }
        return obj;
      };
      if (loadExternal) {
        const separators = ["_", ":"];
        nfn = nfn.argv({
          // we make a transform that just normalize keys,
          // because the transform for args receives single key "extensions" with
          // already parsed values of nested args
          // "--extensions.something.value = true", "--extensions.something2.value = true".
          // unlike the transform for env store which receives raw keys
          transform: makeTransform({ normalize: true })
        }).env({
          separator: ":",
          transform: makeTransform({ separator: separators })
        }).env({
          separator: "_",
          transform: makeTransform({ separator: separators })
        });
      }
      if (nfn.get("rootDirectory") != null) {
        rootDirectory = nfn.get("rootDirectory");
      }
      const configFileParam = nfn.get("configFile");
      if (configFileParam) {
        const configFilePath = path.isAbsolute(configFileParam) ? configFileParam : path.join(rootDirectory, configFileParam);
        if (!fs.existsSync(configFilePath)) {
          throw new Error("Config file " + configFileParam + " was not found.");
        }
        appliedConfigFile = configFileParam;
        nfn.file({ file: configFilePath });
        if (nfn.get("rootDirectory") != null) {
          rootDirectory = nfn.get("rootDirectory");
        }
      }
      if (loadExternal) {
        if (!appliedConfigFile) {
          if (fs.existsSync(path.join(rootDirectory, "jsreport.config.json"))) {
            appliedConfigFile = "jsreport.config.json";
            nfn.file({ file: path.join(rootDirectory, "jsreport.config.json") });
            if (nfn.get("rootDirectory") != null) {
              rootDirectory = nfn.get("rootDirectory");
            }
          }
        }
      }
      nfn.defaults({ store: extend(true, {}, defaults) });
      Object.assign(options, nconfInstance.get());
      loadedOptions = extend(true, {}, options, loadedOptions);
      options.rootDirectory = rootDirectory;
      return [loadedOptions, appliedConfigFile];
    }
    module2.exports = optionsLoad;
  }
});

// node_modules/lodash.omit/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.omit/index.js"(exports2, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayIncludes(array, value) {
      var length = array ? array.length : 0;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeMax = Math.max;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function basePick(object, props) {
      object = Object(object);
      return basePickBy(object, props, function(value, key) {
        return key in object;
      });
    }
    function basePickBy(object, props, predicate) {
      var index = -1, length = props.length, result = {};
      while (++index < length) {
        var key = props[index], value = object[key];
        if (predicate(value, key)) {
          result[key] = value;
        }
      }
      return result;
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var omit = baseRest(function(object, props) {
      if (object == null) {
        return {};
      }
      props = arrayMap(baseFlatten(props, 1), toKey);
      return basePick(object, baseDifference(getAllKeysIn(object), props));
    });
    function stubArray() {
      return [];
    }
    module2.exports = omit;
  }
});

// node_modules/@colors/colors/lib/styles.js
var require_styles2 = __commonJS({
  "node_modules/@colors/colors/lib/styles.js"(exports2, module2) {
    var styles = {};
    module2["exports"] = styles;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      brightRed: [91, 39],
      brightGreen: [92, 39],
      brightYellow: [93, 39],
      brightBlue: [94, 39],
      brightMagenta: [95, 39],
      brightCyan: [96, 39],
      brightWhite: [97, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgBrightRed: [101, 49],
      bgBrightGreen: [102, 49],
      bgBrightYellow: [103, 49],
      bgBrightBlue: [104, 49],
      bgBrightMagenta: [105, 49],
      bgBrightCyan: [106, 49],
      bgBrightWhite: [107, 49],
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  }
});

// node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag3 = __commonJS({
  "node_modules/@colors/colors/lib/system/has-flag.js"(exports2, module2) {
    "use strict";
    module2.exports = function(flag, argv) {
      argv = argv || process.argv;
      var terminatorPos = argv.indexOf("--");
      var prefix = /^-{1,2}/.test(flag) ? "" : "--";
      var pos = argv.indexOf(prefix + flag);
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors2 = __commonJS({
  "node_modules/@colors/colors/lib/system/supports-colors.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag3();
    var env = process.env;
    var forceColor = void 0;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      var min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        var osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
          return sign in env;
        }) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if ("TERM_PROGRAM" in env) {
        var version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Hyper":
            return 3;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      var level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/@colors/colors/lib/custom/trap.js
var require_trap2 = __commonJS({
  "node_modules/@colors/colors/lib/custom/trap.js"(exports2, module2) {
    module2["exports"] = function runTheTrap(text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: [
          "\xCB",
          "\u0115",
          "\u018E",
          "\u0258",
          "\u03A3",
          "\u03BE",
          "\u04BC",
          "\u0A6C"
        ],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: [
          "\xD8",
          "\xF5",
          "\xF8",
          "\u01FE",
          "\u0298",
          "\u047A",
          "\u05DD",
          "\u06DD",
          "\u0E4F"
        ],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
  }
});

// node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo2 = __commonJS({
  "node_modules/@colors/colors/lib/custom/zalgo.js"(exports2, module2) {
    module2["exports"] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      };
      var all = [].concat(soul.up, soul.down, soul.mid);
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      function isChar(character) {
        var bool = false;
        all.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      function heComes(text2, options2) {
        var result = "";
        var counts;
        var l;
        options2 = options2 || {};
        options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
        options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
        options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
        options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (isChar(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options2.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.mid = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.mid = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0; i <= counts[index]; i++) {
              if (options2[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text, options);
    };
  }
});

// node_modules/@colors/colors/lib/maps/america.js
var require_america2 = __commonJS({
  "node_modules/@colors/colors/lib/maps/america.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        if (letter === " ") return letter;
        switch (i % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra2 = __commonJS({
  "node_modules/@colors/colors/lib/maps/zebra.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        return i % 2 === 0 ? letter : colors.inverse(letter);
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow2 = __commonJS({
  "node_modules/@colors/colors/lib/maps/rainbow.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/random.js
var require_random2 = __commonJS({
  "node_modules/@colors/colors/lib/maps/random.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var available = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta",
        "brightYellow",
        "brightRed",
        "brightGreen",
        "brightBlue",
        "brightWhite",
        "brightCyan",
        "brightMagenta"
      ];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
      };
    };
  }
});

// node_modules/@colors/colors/lib/colors.js
var require_colors2 = __commonJS({
  "node_modules/@colors/colors/lib/colors.js"(exports2, module2) {
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var util = require("util");
    var ansiStyles = colors.styles = require_styles2();
    var defineProps = Object.defineProperties;
    var newLineRegex = new RegExp(/[\r\n]+/g);
    colors.supportsColor = require_supports_colors2().supportsColor;
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor() !== false;
    }
    colors.enable = function() {
      colors.enabled = true;
    };
    colors.disable = function() {
      colors.enabled = false;
    };
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style) {
      if (!colors.enabled) {
        return str + "";
      }
      var styleMap = ansiStyles[style];
      if (!styleMap && style in colors) {
        return colors[style](str);
      }
      return styleMap.open + str + styleMap.close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles);
    function applyStyle() {
      var args = Array.prototype.slice.call(arguments);
      var str = args.map(function(arg) {
        if (arg != null && arg.constructor === String) {
          return arg;
        } else {
          return util.inspect(arg);
        }
      }).join(" ");
      if (!colors.enabled || !str) {
        return str;
      }
      var newLinesPresent = str.indexOf("\n") != -1;
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
          str = str.replace(newLineRegex, function(match) {
            return code.close + match + code.open;
          });
        }
      }
      return str;
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
        return;
      }
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            if (typeof theme[style2] === "object") {
              var out = str;
              for (var i in theme[style2]) {
                out = colors[theme[style2][i]](out);
              }
              return out;
            }
            return colors[theme[style2]](str);
          };
        })(style);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles).forEach(function(name) {
        ret[name] = {
          get: function() {
            return build([name]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map2, str) {
      var exploded = str.split("");
      exploded = exploded.map(map2);
      return exploded.join("");
    };
    colors.trap = require_trap2();
    colors.zalgo = require_zalgo2();
    colors.maps = {};
    colors.maps.america = require_america2()(colors);
    colors.maps.zebra = require_zebra2()(colors);
    colors.maps.rainbow = require_rainbow2()(colors);
    colors.maps.random = require_random2()(colors);
    for (map in colors.maps) {
      (function(map2) {
        colors[map2] = function(str) {
          return sequencer(colors.maps[map2], str);
        };
      })(map);
    }
    var map;
    defineProps(colors, init());
  }
});

// node_modules/@colors/colors/safe.js
var require_safe2 = __commonJS({
  "node_modules/@colors/colors/safe.js"(exports2, module2) {
    var colors = require_colors2();
    module2["exports"] = colors;
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/createDefaultLoggerFormat.js
var require_createDefaultLoggerFormat = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/createDefaultLoggerFormat.js"(exports2, module2) {
    var { MESSAGE } = require_triple_beam();
    var colors = require_safe2();
    var winston = require_winston();
    module2.exports = (options = {}) => {
      return winston.format((info) => {
        const { level, message, timestamp, ...meta } = info;
        let logDate;
        if (timestamp == null) {
          logDate = /* @__PURE__ */ new Date();
          info.timestamp = logDate.getTime();
        } else {
          logDate = new Date(timestamp);
        }
        info[MESSAGE] = `${options.timestamp === true ? `${logDate.toISOString()} - ` : ""}${level}: ${info.userLevel === true ? colors.cyan(message) : message}`;
        const metaKeys = Object.keys(meta);
        if (metaKeys.length > 0) {
          info[MESSAGE] += ` ${metaKeys.map((k) => `${k}=${meta[k]}`).join(", ")}`;
        }
        if (info.userLevel === true) {
          info.level = colors.cyan(info.level);
        }
        return info;
      });
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/shared/normalizeMetaFromLogs.js
var require_normalizeMetaFromLogs = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/shared/normalizeMetaFromLogs.js"(exports2, module2) {
    var omit = require_lodash();
    module2.exports = (level, msg, timestamp, meta) => {
      let result = meta;
      if (meta != null && meta.context) {
        meta.context.logs = meta.context.logs || [];
        meta.context.logs.push({
          level,
          message: msg,
          timestamp
        });
        const newMeta = Object.assign({}, omit(meta, ["logged", "rawContent", "template", "options", "data", "context", "timestamp", "cancel"]));
        if (newMeta.rootId == null && meta.context.rootId != null) {
          newMeta.rootId = meta.context.rootId;
        }
        if (newMeta.id == null && meta.context.id != null) {
          newMeta.id = meta.context.id;
        }
        result = newMeta;
      }
      return result != null && Object.keys(result).length > 0 ? result : null;
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/createNormalizeMetaLoggerFormat.js
var require_createNormalizeMetaLoggerFormat = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/createNormalizeMetaLoggerFormat.js"(exports2, module2) {
    var omit = require_lodash();
    var winston = require_winston();
    var { LEVEL, MESSAGE, SPLAT } = require_triple_beam();
    var normalizeMetaFromLogs = require_normalizeMetaFromLogs();
    module2.exports = () => {
      return winston.format((info) => {
        const { level, message, timestamp: _timestamp, ...meta } = info;
        const symbolProps = [LEVEL, MESSAGE, SPLAT];
        const originalSymbolProps = {};
        for (const symbolProp of symbolProps) {
          if (info[symbolProp] != null) {
            originalSymbolProps[symbolProp] = info[symbolProp];
          }
        }
        const timestamp = _timestamp ?? (/* @__PURE__ */ new Date()).getTime();
        const targetMeta = omit(meta, symbolProps);
        const newMeta = normalizeMetaFromLogs(level, message, timestamp, targetMeta);
        if (newMeta != null) {
          return {
            level,
            message,
            timestamp,
            ...originalSymbolProps,
            ...newMeta
          };
        }
        return info;
      });
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/shared/normalizeError.js
var require_normalizeError = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/shared/normalizeError.js"(exports2, module2) {
    module2.exports = function normalizeError(errValue, normalizedErrorPrefix = "User code threw with non-Error: ") {
      let newError;
      const isErrorObj = typeof errValue === "object" && typeof errValue.hasOwnProperty === "function" && Object.prototype.hasOwnProperty.call(errValue, "message");
      const isValidError = isErrorObj || typeof errValue === "string";
      if (!isValidError) {
        if (Object.prototype.toString.call(errValue) === "[object Object]") {
          newError = new Error(`${normalizedErrorPrefix}${JSON.stringify(errValue)}`);
        } else {
          newError = new Error(`${normalizedErrorPrefix}${errValue}`);
        }
      } else {
        if (typeof errValue === "string") {
          newError = new Error(errValue);
        } else {
          newError = errValue;
        }
      }
      return newError;
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/shared/createError.js
var require_createError = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/shared/createError.js"(exports2, module2) {
    var normalizeError = require_normalizeError();
    module2.exports = function(message, options = {}) {
      const { original } = options;
      let error;
      if (message == null && original != null) {
        error = original;
      } else {
        error = new Error(message);
        if (original != null) {
          const originalNormalized = normalizeError(original);
          error.entity = originalNormalized.entity;
          error.lineNumber = originalNormalized.lineNumber;
          error.property = originalNormalized.property;
          if (originalNormalized.statusCode != null) {
            error.statusCode = originalNormalized.statusCode;
          }
          if (originalNormalized.weak != null) {
            error.weak = originalNormalized.weak;
          }
          if (error.message == null || error.message === "") {
            error.message = `${originalNormalized.message}`;
          } else {
            error.message += `
(because) ${lowerCaseFirstLetter(originalNormalized.message)}`;
          }
          if (error.stack != null && originalNormalized.stack != null) {
            error.stack = `${originalNormalized.stack}
wrapped by:
${error.stack}`;
          }
        }
      }
      const { original: originalInOptions, ...restOfOptions } = options;
      Object.assign(error, restOfOptions);
      if ((error.statusCode === 400 || error.statusCode === 404) && error.weak == null) {
        error.weak = true;
      }
      return error;
    };
    function lowerCaseFirstLetter(str) {
      if (str === "" || typeof str !== "string") {
        return str;
      }
      return str.charAt(0).toLowerCase() + str.slice(1);
    }
  }
});

// node_modules/@jsreport/jsreport-core/lib/shared/request.js
var require_request = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/shared/request.js"(exports2, module2) {
    var extend = require_node_extend_without();
    var omit = require_lodash();
    var createError = require_createError();
    module2.exports = (obj, parent) => {
      if (parent && !parent.__isJsreportRequest__) {
        throw new Error("Invalid parent request passed");
      }
      const request = Object.create({}, {
        __isJsreportRequest__: {
          value: true,
          writable: false,
          configurable: false,
          enumerable: false
        }
      });
      request.template = extend(true, {}, obj.template);
      if (parent) {
        request.context = Object.assign({}, request.context, omit(parent.context, ["id", "logs"]));
        request.context.isChildRequest = true;
        request.options = Object.assign({}, request.options, parent.options);
        if (parent.data) {
          const dataInput = normalizeJSONData(parent.data);
          request.data = Object.assign(Array.isArray(dataInput) ? [] : {}, dataInput);
        }
      }
      request.options = extend(true, {}, request.options, obj.options);
      request.context = extend(true, {}, request.context, obj.context);
      request.context.shared = extend(true, {}, request.context.shared);
      if (obj.data) {
        const dataInput = normalizeJSONData(obj.data);
        request.data = Object.assign(Array.isArray(dataInput) ? [] : {}, request.data, dataInput);
        if (obj.context == null || obj.context.originalInputDataIsEmpty == null) {
          request.context.originalInputDataIsEmpty = false;
        }
      } else if (!parent) {
        if (obj.context == null || obj.context.originalInputDataIsEmpty == null) {
          request.context.originalInputDataIsEmpty = true;
        }
      }
      if (!request.data) {
        request.data = {};
      }
      return request;
    };
    function normalizeJSONData(data) {
      if (typeof data === "string") {
        try {
          return JSON.parse(data);
        } catch (parseError) {
          throw createError("Unable to parse request data", {
            weak: true,
            original: parseError
          });
        }
      }
      return data;
    }
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/request.js
var require_request2 = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/request.js"(exports2, module2) {
    var Request = require_request();
    module2.exports = (obj) => {
      const targetObj = { ...obj };
      const originalData = targetObj.data;
      delete targetObj.data;
      const customOriginalInputDataIsEmptyResult = {
        defined: false,
        value: null
      };
      if (targetObj?.context != null && Object.hasOwn(targetObj.context, "originalInputDataIsEmpty")) {
        customOriginalInputDataIsEmptyResult.defined = true;
        customOriginalInputDataIsEmptyResult.value = targetObj.context.originalInputDataIsEmpty;
      }
      const request = Request(targetObj);
      request.data = originalData;
      if (customOriginalInputDataIsEmptyResult.defined) {
        request.context.originalInputDataIsEmpty = customOriginalInputDataIsEmptyResult.value;
      } else {
        delete request.context.originalInputDataIsEmpty;
      }
      return request;
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/logger.js
var require_logger2 = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/logger.js"(exports2, module2) {
    var path = require("path");
    var omit = require_lodash();
    var { MESSAGE } = require_triple_beam();
    var winston = require_winston();
    var Transport = require_winston_transport();
    var debug = require_src()("jsreport");
    var createDefaultLoggerFormat = require_createDefaultLoggerFormat();
    var createNormalizeMetaLoggerFormat = require_createNormalizeMetaLoggerFormat();
    var Request = require_request2();
    var defaultLoggerFormat = createDefaultLoggerFormat();
    var defaultLoggerFormatWithTimestamp = createDefaultLoggerFormat({ timestamp: true });
    var normalizeMetaLoggerFormat = createNormalizeMetaLoggerFormat();
    function createLogger() {
      const logger = winston.createLogger(getConfigurationOptions());
      logger.on("error", (err) => {
        let dir;
        let msg;
        if (err.code === "ENOENT") {
          dir = path.dirname(err.path);
          if (dir === ".") {
            msg = "Error from logger (winston) while trying to use a file to store logs:";
          } else {
            msg = 'Error from logger (winston) while trying to use a file to store logs. If the directory "' + dir + '" does not exist, please create it:';
          }
          console.error("------------------------");
          console.error(msg, err);
          console.error("------------------------");
        }
      });
      return logger;
    }
    function configureLogger(logger, _transports) {
      const transports = _transports || {};
      const transportFormatMap = /* @__PURE__ */ new WeakMap();
      for (const [, transpOptions] of Object.entries(transports)) {
        if (transpOptions.format != null) {
          transportFormatMap.set(transpOptions, transpOptions.format);
          delete transpOptions.format;
        }
      }
      const configuredPreviously = logger.__configured__ === true;
      if (configuredPreviously) {
        return;
      }
      const knownTransports = {
        debug: DebugTransport,
        console: winston.transports.Console,
        file: winston.transports.File,
        http: winston.transports.Http
      };
      const knownOptions = ["transport", "module", "enabled"];
      const transportsToAdd = [];
      for (const [transpName, transpOptions] of Object.entries(transports)) {
        let transportModule;
        if (!transpOptions || typeof transpOptions !== "object" || Array.isArray(transpOptions)) {
          continue;
        }
        if (typeof transpOptions.transport !== "string" || transpOptions.transport === "") {
          throw new Error(`Invalid option for transport object "${transpName}", option "transport" is not specified or has an incorrect value, must be a string with a valid value. check your "logger" config`);
        }
        if (typeof transpOptions.level !== "string" || transpOptions.level === "") {
          throw new Error(`Invalid option for transport object "${transpName}", option "level" is not specified or has an incorrect value, must be a string with a valid value. check your "logger" config`);
        }
        if (transpName !== "debug" && transpOptions.enabled === false) {
          continue;
        }
        let originalFormat;
        if (transportFormatMap.has(transpOptions)) {
          originalFormat = transportFormatMap.get(transpOptions);
        }
        if (originalFormat != null && typeof originalFormat.constructor !== "function") {
          throw new Error(`Invalid option for transport object "${transpName}", option "format" has an incorrect value, must be an instance of loggerFormat. check your "logger" config`);
        }
        const options = Object.assign(omit(transpOptions, knownOptions), {
          name: transpName
        });
        if (originalFormat != null) {
          options.format = originalFormat;
        }
        if (knownTransports[transpOptions.transport]) {
          if (transpName === "debug") {
            options.enabled = transpOptions.enabled !== false;
          }
          transportsToAdd.push({
            TransportClass: knownTransports[transpOptions.transport],
            options
          });
        } else {
          if (transpOptions.module == null) {
            throw new Error(`Invalid option for transport object "${transpName}", option "transport" has an unknown transport type: "${transpOptions.transport}". check your "logger" config`);
          }
          if (typeof transpOptions.module !== "string") {
            throw new Error(`Invalid option for transport object "${transpName}", option "module" has an incorrect value, must be a string with a module name. check your "logger" config`);
          }
          try {
            transportModule = require(transpOptions.module);
            if (typeof winston.transports[transpOptions.transport] === "function") {
              transportModule = winston.transports[transpOptions.transport];
            } else if (transportModule && typeof transportModule[transpOptions.transport] === "function") {
              transportModule = transportModule[transpOptions.transport];
            }
            if (typeof transportModule !== "function") {
              throw new Error(`Invalid option for transport object "${transpName}", module "${transpOptions.module}" does not export a valid transport. check your "logger" config`);
            }
          } catch (e) {
            if (e.code === "MODULE_NOT_FOUND") {
              throw new Error(`Invalid option for transport object "${transpName}", module "${transpOptions.module}" in "module" option could not be found. are you sure that you have installed it?. check your "logger" config'`);
            }
            throw e;
          }
          transportsToAdd.push({
            TransportClass: transportModule,
            options
          });
        }
      }
      for (const { TransportClass, options } of transportsToAdd) {
        if (options.silent) {
          continue;
        }
        const transportInstance = new TransportClass(options);
        const existingTransport = logger.transports.find((t) => t.name === transportInstance.name);
        if (existingTransport) {
          logger.remove(existingTransport);
        }
        logger.add(transportInstance);
      }
      const originalLog = logger.log;
      logger.log = function(level, msg, ...splat) {
        const [meta] = splat;
        if (typeof meta === "object" && meta !== null && meta.context != null && meta.socket != null) {
          splat[0] = Request(meta);
        }
        return originalLog.call(this, level, msg, ...splat);
      };
      logger.__configured__ = true;
    }
    function getConfigurationOptions() {
      return {
        levels: {
          error: 0,
          warn: 1,
          info: 2,
          debug: 3
        },
        format: winston.format.combine(
          normalizeMetaLoggerFormat(),
          defaultLoggerFormatWithTimestamp()
        ),
        transports: [new DebugTransport()]
      };
    }
    function silentLogs(logger) {
      if (logger.transports.length > 0) {
        for (const transport of logger.transports) {
          transport.silent = true;
        }
      }
    }
    var DebugTransport = class extends Transport {
      constructor(options = {}) {
        super(options);
        this.name = "debug";
        this.level = options.level || "debug";
        this.format = options.format || winston.format.combine(
          winston.format.colorize(),
          defaultLoggerFormat()
        );
        this.enabled = options.enabled !== false;
      }
      log(info, callback) {
        if (this.enabled) {
          setImmediate(() => {
            this.emit("logged", info);
          });
          debug(info[MESSAGE]);
        }
        if (callback) {
          callback();
        }
      }
    };
    module2.exports.createLogger = createLogger;
    module2.exports.configureLogger = configureLogger;
    module2.exports.silentLogs = silentLogs;
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/validateEntityName.js
var require_validateEntityName = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/validateEntityName.js"(exports2, module2) {
    var createError = require_createError();
    var invalidFileNameCharacters = [
      "<",
      ">",
      ":",
      '"',
      { character: "/", escaped: "\\/" },
      { character: "\\", escaped: "\\\\" },
      "|",
      "?",
      "*"
    ];
    function getInvalidFileNameCharactersRegExp() {
      return new RegExp(`[${invalidFileNameCharacters.map((c) => typeof c === "string" ? c : c.escaped).join("")}\\x00-\\x1F]`, "g");
    }
    module2.exports = (name) => {
      if (name == null || typeof name === "string" && name.trim() === "") {
        throw createError("Entity name can not be empty", {
          statusCode: 400
        });
      }
      if (typeof name !== "string") {
        throw createError("Entity name must be a string", {
          statusCode: 400
        });
      }
      if (name.trim() === ".") {
        throw createError('Entity name can not be "."', {
          statusCode: 400
        });
      }
      if (name.trim() === "..") {
        throw createError('Entity name can not be ".."', {
          statusCode: 400
        });
      }
      const containsInvalid = getInvalidFileNameCharactersRegExp().test(name);
      if (containsInvalid) {
        const msg = `Entity name can not contain characters ${invalidFileNameCharacters.map((c) => typeof c === "string" ? c : c.character).join(", ")} and non-printable characters. name used: ${name}`;
        throw createError(msg, {
          statusCode: 400
        });
      }
      if (name === "config.json") {
        throw createError(`Entity name "config.json" is reserved and can't be used`, {
          statusCode: 400
        });
      }
      return true;
    };
  }
});

// node_modules/nanoid/url-alphabet/index.cjs
var require_url_alphabet = __commonJS({
  "node_modules/nanoid/url-alphabet/index.cjs"(exports2, module2) {
    var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    module2.exports = { urlAlphabet };
  }
});

// node_modules/nanoid/index.cjs
var require_nanoid = __commonJS({
  "node_modules/nanoid/index.cjs"(exports2, module2) {
    var crypto4 = require("crypto");
    var { urlAlphabet } = require_url_alphabet();
    var POOL_SIZE_MULTIPLIER = 128;
    var pool;
    var poolOffset;
    var fillPool = (bytes) => {
      if (!pool || pool.length < bytes) {
        pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
        crypto4.randomFillSync(pool);
        poolOffset = 0;
      } else if (poolOffset + bytes > pool.length) {
        crypto4.randomFillSync(pool);
        poolOffset = 0;
      }
      poolOffset += bytes;
    };
    var random = (bytes) => {
      fillPool(bytes -= 0);
      return pool.subarray(poolOffset - bytes, poolOffset);
    };
    var customRandom = (alphabet, size, getRandom) => {
      let mask = (2 << 31 - Math.clz32(alphabet.length - 1 | 1)) - 1;
      let step = Math.ceil(1.6 * mask * size / alphabet.length);
      return () => {
        let id = "";
        while (true) {
          let bytes = getRandom(step);
          let i = step;
          while (i--) {
            id += alphabet[bytes[i] & mask] || "";
            if (id.length === size) return id;
          }
        }
      };
    };
    var customAlphabet = (alphabet, size) => customRandom(alphabet, size, random);
    var nanoid = (size = 21) => {
      fillPool(size -= 0);
      let id = "";
      for (let i = poolOffset - size; i < poolOffset; i++) {
        id += urlAlphabet[pool[i] & 63];
      }
      return id;
    };
    module2.exports = { nanoid, customAlphabet, customRandom, urlAlphabet, random };
  }
});

// node_modules/uuid/dist/esm-node/rng.js
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_crypto.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var import_crypto, rnds8Pool, poolPtr;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-node/rng.js"() {
    import_crypto = __toESM(require("crypto"));
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
});

// node_modules/uuid/dist/esm-node/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/uuid/dist/esm-node/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/uuid/dist/esm-node/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/uuid/dist/esm-node/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// node_modules/uuid/dist/esm-node/stringify.js
function stringify(arr, offset = 0) {
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, stringify_default;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-node/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/uuid/dist/esm-node/v1.js
function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || stringify_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-node/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-node/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "node_modules/uuid/dist/esm-node/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// node_modules/uuid/dist/esm-node/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
function v35_default(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
var DNS, URL;
var init_v35 = __esm({
  "node_modules/uuid/dist/esm-node/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/uuid/dist/esm-node/md5.js
function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_crypto2.default.createHash("md5").update(bytes).digest();
}
var import_crypto2, md5_default;
var init_md5 = __esm({
  "node_modules/uuid/dist/esm-node/md5.js"() {
    import_crypto2 = __toESM(require("crypto"));
    md5_default = md5;
  }
});

// node_modules/uuid/dist/esm-node/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/uuid/dist/esm-node/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-node/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-node/sha1.js
function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_crypto3.default.createHash("sha1").update(bytes).digest();
}
var import_crypto3, sha1_default;
var init_sha1 = __esm({
  "node_modules/uuid/dist/esm-node/sha1.js"() {
    import_crypto3 = __toESM(require("crypto"));
    sha1_default = sha1;
  }
});

// node_modules/uuid/dist/esm-node/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/uuid/dist/esm-node/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/uuid/dist/esm-node/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/uuid/dist/esm-node/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/uuid/dist/esm-node/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/uuid/dist/esm-node/version.js"() {
    init_validate();
    version_default = version;
  }
});

// node_modules/uuid/dist/esm-node/index.js
var esm_node_exports = {};
__export(esm_node_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_node = __esm({
  "node_modules/uuid/dist/esm-node/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// node_modules/@jsreport/jsreport-core/lib/shared/listenerCollection.js
var require_listenerCollection = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/shared/listenerCollection.js"(exports2, module2) {
    module2.exports = function createListenerCollection(_name) {
      const name = _name != null ? `${_name}` : "Anonymous";
      return new ListenerCollection(name);
    };
    var ListenerCollection = class {
      constructor(name) {
        this._name = name;
        this._listeners = [];
        this._pre = [];
        this._post = [];
        this._postFail = [];
      }
      /**
       * Add listener cb at the end of the current chain.
       * @param {String} key
       * @param {Object|Function} context
       * @param {Function} listener
       */
      add(key, context, listener) {
        const fn = listener || context;
        const _context = listener === null ? this : context;
        this._listeners.push({
          key,
          fn,
          context: _context
        });
      }
      /**
       * Add the listener callback to the particular position in the chain.
       * The position is specified by the index in the array or a condition
       * Example
       * listeners.insert({ pre: "another", post: "another2" }, "foo", this, function() {... });
       *
       * @param {Number|Object} indexOrCondition
       * @param {String} key
       * @param {Object} context
       * @param {Function} listener
       */
      insert(indexOrCondition, key, context, listener) {
        const listenerOpts = {
          key,
          fn: listener || context,
          context: listener === null ? this : context
        };
        if (!isNaN(indexOrCondition)) {
          return this._listeners.splice(indexOrCondition, 0, listenerOpts);
        }
        let afterInsertIndex = null;
        let beforeInsertIndex = null;
        for (let i = 0; i < this._listeners.length; i++) {
          if (this._listeners[i].key === indexOrCondition.after) {
            afterInsertIndex = i + 1;
          }
          if (this._listeners[i].key === indexOrCondition.before) {
            beforeInsertIndex = i;
          }
        }
        const index = afterInsertIndex !== null ? afterInsertIndex : beforeInsertIndex !== null ? beforeInsertIndex : this._listeners.length;
        this._listeners.splice(index, 0, listenerOpts);
      }
      /**
       * Remove the listener specified by its key from the collection
       * @param {String} key
       */
      remove(key) {
        this._listeners = this._listeners.filter((l) => {
          return l.key !== key;
        });
      }
      /* Add hook that will be executed before actual listener */
      pre(fn) {
        this._pre.push(fn);
      }
      /* Add hook that will be executed after actual listener */
      post(fn) {
        this._post.push(fn);
      }
      /* Add hook that will be executed after actual listener when execution will fail */
      postFail(fn) {
        this._postFail.push(fn);
      }
      /**
       * Fires listeners and returns value composed from all boolean results into the single bool
       * @returns {Promise<Boolean>}
       */
      async fireAndJoinResults(...args) {
        const results = await this.fire(...args);
        const successes = results.filter((r) => {
          return r === true;
        });
        const failures = results.filter((r) => {
          return r === false;
        });
        const dontCares = results.filter((r) => {
          return r === null || r === void 0;
        });
        if (successes.length && successes.length + dontCares.length === results.length) {
          return true;
        }
        if (failures.length && failures.length + dontCares.length === results.length) {
          return false;
        }
        if (dontCares.length === results.length) {
          return null;
        }
        return true;
      }
      /**
       * Fire registered listeners in sequence and returns a promise containing wrapping an array of all
       * individual results.
       * The parameters passed to the fire are forwarded in the same order to the listeners.
       * @returns {Promise<U>}
       */
      async fire(...args) {
        const self2 = this;
        const applyHook = function applyHook2(l, hookArrayName, outerArgs) {
          self2[hookArrayName].forEach((p) => {
            p.apply(l, outerArgs);
          });
        };
        const results = [];
        for (const l of this._listeners) {
          const currentArgs = [...args];
          applyHook(l, "_pre", currentArgs);
          try {
            const val = await l.fn.apply(l.context, currentArgs);
            applyHook(l, "_post", currentArgs);
            results.push(val);
          } catch (e) {
            currentArgs.unshift(e);
            applyHook(l, "_postFail", currentArgs);
            throw e;
          }
        }
        return results;
      }
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/store/typeUtils.js
var require_typeUtils = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/store/typeUtils.js"(exports2, module2) {
    function getType(model, container, typeName, returnNormalizedTypeName) {
      const normalizedTypeName = typeName.replace(model.namespace + ".", "");
      const typeInfo = container[normalizedTypeName];
      if (!typeInfo) {
        return;
      }
      if (returnNormalizedTypeName === true) {
        return normalizedTypeName;
      }
      return typeInfo;
    }
    function resolvePropDefinition(model, def) {
      const result = {};
      const collectionTypeRegExp = /^Collection\((\S+)\)$/;
      const collectionMatchResult = collectionTypeRegExp.exec(def.type);
      if (def.type.startsWith("Edm")) {
        result.def = def;
      } else if (collectionMatchResult != null && collectionMatchResult[1] != null) {
        const childType = collectionMatchResult[1];
        if (childType.startsWith("Edm")) {
          result.def = def;
          result.subDef = { type: childType };
        } else {
          const subType = getType(model, model.complexTypes, childType);
          if (subType != null) {
            result.def = def;
            result.subType = subType;
          }
        }
      } else {
        const subType = getType(model, model.complexTypes, def.type);
        if (subType) {
          result.def = def;
          result.subType = subType;
        }
      }
      if (Object.keys(result).length === 0) {
        return;
      }
      return result;
    }
    var edmTypeToJSONSchema = {
      "Edm.String": "string",
      "Edm.DateTimeOffset": { anyOf: [{ "$jsreport-stringToDate": true }, { "$jsreport-acceptsDate": true }] },
      "Edm.Boolean": "boolean",
      "Edm.Int16": { type: "integer", minimum: -32768, maximum: 32767 },
      "Edm.Int32": { type: "integer", minimum: -2147483648, maximum: 2147483647 },
      "Edm.Double": "number",
      "Edm.Decimal": "number",
      "Edm.Binary": { anyOf: [{ type: "null" }, { type: "string" }, { "$jsreport-acceptsBuffer": true }] }
    };
    function typeDefToJSONSchema(model, def) {
      const jsonSchema = { type: "object", properties: {} };
      if (def == null) {
        return;
      }
      if (typeof def !== "object" || Array.isArray(def)) {
        return;
      }
      Object.keys(def).forEach((key) => {
        const propDef = def[key];
        if (propDef == null || propDef.type == null) {
          return;
        }
        const extraSchema = propDef.schema;
        const resolveResult = resolvePropDefinition(model, propDef);
        if (!resolveResult) {
          return;
        }
        const isCollection = resolveResult.def.type.startsWith("Collection(");
        if (resolveResult.subType) {
          jsonSchema.properties[key] = typeDefToJSONSchema(model, resolveResult.subType);
        } else if (isCollection && resolveResult.subType == null || resolveResult.def.type.startsWith("Edm") && edmTypeToJSONSchema[resolveResult.def.type] != null) {
          let targetType = resolveResult.def.type;
          if (isCollection && resolveResult.subType == null) {
            targetType = resolveResult.subDef.type;
          }
          const value = edmTypeToJSONSchema[targetType];
          if (typeof value === "string") {
            jsonSchema.properties[key] = { type: value };
          } else {
            jsonSchema.properties[key] = value;
          }
        }
        if (isCollection) {
          jsonSchema.properties[key] = {
            type: "array",
            items: jsonSchema.properties[key]
          };
        }
        if (extraSchema) {
          let originalType = jsonSchema.properties[key].type;
          let newType = extraSchema.type;
          if (originalType != null && newType != null) {
            if (!Array.isArray(originalType)) {
              originalType = [jsonSchema.properties[key].type];
            }
            if (!Array.isArray(newType)) {
              newType = [newType];
            }
            jsonSchema.properties[key] = {
              ...jsonSchema.properties[key],
              ...extraSchema,
              type: [...originalType, ...newType]
            };
          } else if (newType != null && originalType == null) {
            let newProperties = {};
            if (Array.isArray(jsonSchema.properties[key].anyOf)) {
              newProperties = {
                anyOf: [...jsonSchema.properties[key].anyOf, { type: newType }]
              };
            } else if (Array.isArray(jsonSchema.properties[key].allOf)) {
              newProperties = {
                allOf: [...jsonSchema.properties[key].allOf, { type: newType }]
              };
            } else if (Array.isArray(jsonSchema.properties[key].oneOf)) {
              newProperties = {
                oneOf: [...jsonSchema.properties[key].oneOf, { type: newType }]
              };
            }
            const copyExtraSchema = { ...extraSchema };
            delete copyExtraSchema.type;
            jsonSchema.properties[key] = {
              ...jsonSchema.properties[key],
              ...copyExtraSchema,
              ...newProperties
            };
          } else {
            jsonSchema.properties[key] = Object.assign({}, jsonSchema.properties[key], extraSchema);
          }
        }
      });
      if (Object.keys(jsonSchema.properties).length === 0) {
        return;
      }
      return jsonSchema;
    }
    module2.exports.getType = getType;
    module2.exports.resolvePropDefinition = resolvePropDefinition;
    module2.exports.typeDefToJSONSchema = typeDefToJSONSchema;
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/store/referenceUtils.js
var require_referenceUtils = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/store/referenceUtils.js"(exports2, module2) {
    var { resolvePropDefinition } = require_typeUtils();
    function findReferencePropertiesInType(model, type, parentProps = []) {
      const properties = [];
      for (const [propName, propDef] of Object.entries(type)) {
        const currentFullProps = [...parentProps, propName];
        const result = resolvePropDefinition(model, propDef);
        if (!result) {
          continue;
        }
        if (result.subType) {
          const subProperties = findReferencePropertiesInType(model, result.subType, currentFullProps);
          properties.push(...subProperties);
          continue;
        }
        if (result.def.referenceTo != null) {
          properties.push({
            name: currentFullProps.join("."),
            referenceTo: result.def.referenceTo
          });
        }
      }
      return properties;
    }
    function findPropertiesForCollectionReference(store, collectionReferenceOriginName, collectionReferenceTargetName) {
      const properties = [];
      for (const prop of store.model.entitySets[collectionReferenceOriginName].referenceProperties) {
        if (prop.referenceTo === collectionReferenceTargetName) {
          properties.push(prop.name);
        }
      }
      return properties;
    }
    function findLinkedEntitiesForReferenceValue(store, entitiesByCollection, collectionReferenceTargetName, referenceValue) {
      const linkedEntities = [];
      const targetCollections = [];
      for (const property of store.model.entitySets[collectionReferenceTargetName].linkedReferenceProperties) {
        if (!targetCollections.includes(property.entitySet)) {
          targetCollections.push(property.entitySet);
        }
      }
      for (const colName of targetCollections) {
        const entitiesInCollection = entitiesByCollection[colName] || [];
        for (const entity of entitiesInCollection) {
          const properties = existsReferenceValue(store, colName, entity, collectionReferenceTargetName, referenceValue);
          if (properties) {
            linkedEntities.push({
              properties,
              entity
            });
          }
        }
      }
      return linkedEntities;
    }
    function existsReferenceValue(store, collectionReferenceOriginName, entity, collectionReferenceTargetName, referenceValue) {
      let exists = false;
      const propertiesToCheck = findPropertiesForCollectionReference(store, collectionReferenceOriginName, collectionReferenceTargetName);
      const properties = [];
      for (const propName of propertiesToCheck) {
        const entityType = store.model.entitySets[collectionReferenceOriginName].entityTypeDef;
        const propParts = propName.split(".");
        exists = existsReferenceInProperty(store, entityType, entity, referenceValue, propParts);
        if (exists) {
          properties.push(propName);
        }
      }
      if (properties.length === 0) {
        return;
      }
      return properties;
    }
    function existsReferenceInProperty(store, type, obj, referenceValue, propsToEvaluate) {
      if (obj == null || propsToEvaluate.length === 0) {
        return false;
      }
      const currentPropName = propsToEvaluate[0];
      const restProps = propsToEvaluate.slice(1);
      const currentPropDef = type[currentPropName];
      const currentPropValue = obj[currentPropName];
      if (currentPropValue == null || currentPropDef == null) {
        return false;
      }
      const resolveResult = store.resolvePropertyDefinition(currentPropDef);
      if (resolveResult.subType && resolveResult.def.type.startsWith("Collection(")) {
        if (!Array.isArray(currentPropValue)) {
          return false;
        }
        return currentPropValue.some((val) => {
          return existsReferenceInProperty(store, resolveResult.subType, val, referenceValue, restProps);
        });
      } else if (resolveResult.def.type.startsWith("Collection(") && resolveResult.subType == null) {
        if (restProps.length > 0) {
          return false;
        }
        if (!Array.isArray(currentPropValue)) {
          return false;
        }
        return currentPropValue.some((val) => val === referenceValue);
      } else if (resolveResult.subType) {
        return existsReferenceInProperty(store, resolveResult.subType, currentPropValue, referenceValue, restProps);
      }
      if (restProps.length > 0) {
        return false;
      }
      return currentPropValue === referenceValue;
    }
    function updateReferenceValue(store, collectionReferenceOriginName, entity, collectionReferenceTargetName, referenceOpts, newReferenceValue) {
      if (!referenceOpts) {
        throw new Error("reference options is required");
      }
      const { referenceProp, referenceValue } = referenceOpts;
      if (!referenceProp && !referenceValue) {
        throw new Error("reference options needs either .referenceProp or .referenceValue value to be present");
      }
      const propertiesToCheck = findPropertiesForCollectionReference(store, collectionReferenceOriginName, collectionReferenceTargetName);
      for (const propName of propertiesToCheck) {
        if (referenceProp != null && referenceProp !== propName) {
          continue;
        }
        const entityType = store.model.entitySets[collectionReferenceOriginName].entityTypeDef;
        const propParts = propName.split(".");
        updateReferenceInProperty(store, entityType, entity, referenceValue, newReferenceValue, propParts);
      }
    }
    function updateReferenceInProperty(store, type, obj, referenceValue, newReferenceValue, propsToEvaluate) {
      const currentPropName = propsToEvaluate[0];
      const restProps = propsToEvaluate.slice(1);
      const currentPropDef = type[currentPropName];
      const currentPropValue = obj[currentPropName];
      if (currentPropDef == null) {
        return;
      }
      const resolveResult = store.resolvePropertyDefinition(currentPropDef);
      if (resolveResult.subType && resolveResult.def.type.startsWith("Collection(")) {
        if (restProps.length === 0) {
          return;
        }
        if (!Array.isArray(currentPropValue)) {
          obj[currentPropName] = [];
        }
        if (obj[currentPropName].length === 0) {
          const newItem = {};
          obj[currentPropName].push(newItem);
          updateReferenceInProperty(store, resolveResult.subType, newItem, void 0, newReferenceValue, restProps);
        } else {
          const exists = obj[currentPropName].some((val) => {
            return existsReferenceInProperty(store, resolveResult.subType, val, referenceValue, restProps);
          });
          if (exists) {
            obj[currentPropName].forEach((val, idx) => {
              obj[currentPropName][idx] = val || {};
              return updateReferenceInProperty(store, resolveResult.subType, obj[currentPropName][idx], referenceValue, newReferenceValue, restProps);
            });
          } else {
            const newItem = {};
            obj[currentPropName].push(newItem);
            updateReferenceInProperty(store, resolveResult.subType, newItem, void 0, newReferenceValue, restProps);
          }
        }
      } else if (resolveResult.def.type.startsWith("Collection(") && resolveResult.subType == null) {
        if (restProps.length > 0) {
          return;
        }
        if (!Array.isArray(currentPropValue)) {
          obj[currentPropName] = [];
        }
        if (referenceValue != null && obj[currentPropName].includes(referenceValue)) {
          obj[currentPropName].forEach((val, idx) => {
            if (val === referenceValue) {
              obj[currentPropName][idx] = newReferenceValue;
            }
          });
        } else {
          obj[currentPropName].push(newReferenceValue);
        }
      } else if (resolveResult.subType) {
        obj[currentPropName] = obj[currentPropName] || {};
        return updateReferenceInProperty(store, resolveResult.subType, obj[currentPropName], referenceValue, newReferenceValue, restProps);
      }
      if (restProps.length > 0) {
        return;
      }
      if (referenceValue != null) {
        if (obj[currentPropName] === referenceValue) {
          obj[currentPropName] = newReferenceValue;
        }
      } else {
        obj[currentPropName] = newReferenceValue;
      }
    }
    module2.exports.findReferencePropertiesInType = findReferencePropertiesInType;
    module2.exports.findLinkedEntitiesForReferenceValue = findLinkedEntitiesForReferenceValue;
    module2.exports.existsReferenceValue = existsReferenceValue;
    module2.exports.updateReferenceValue = updateReferenceValue;
  }
});

// node_modules/@jsreport/jsreport-core/lib/shared/adminRequest.js
var require_adminRequest = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/shared/adminRequest.js"(exports2, module2) {
    var omit = require_lodash();
    module2.exports = function adminRequest(req, Request) {
      if (req == null) {
        return req;
      }
      let targetReq = req;
      if (Request != null) {
        targetReq = Request(targetReq);
      }
      targetReq.context = targetReq.context ? omit(targetReq.context, "user") : targetReq.context;
      return targetReq;
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/store/collection.js
var require_collection = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/store/collection.js"(exports2, module2) {
    var { resolvePropDefinition } = require_typeUtils();
    var adminRequest = require_adminRequest();
    var createListenerCollection = require_listenerCollection();
    var createError = require_createError();
    var Request = require_request();
    var validateEntityName = require_validateEntityName();
    module2.exports = (entitySet, provider, model, validator, encryption, transactions) => ({
      name: entitySet,
      beforeFindListeners: createListenerCollection(`DocumentStoreCollection(${entitySet})@beforeFind`),
      beforeUpdateListeners: createListenerCollection(`DocumentStoreCollection(${entitySet})@beforeUpdate`),
      beforeInsertListeners: createListenerCollection(`DocumentStoreCollection(${entitySet})@beforeInsert`),
      beforeRemoveListeners: createListenerCollection(`DocumentStoreCollection(${entitySet})@beforeRemove`),
      beforeUpdateValidationListeners: createListenerCollection(`DocumentStoreCollection(${entitySet})@beforeUpdateValidation`),
      beforeInsertValidationListeners: createListenerCollection(`DocumentStoreCollection(${entitySet})@beforeInsertValidation`),
      entitySet,
      load: (...args) => {
        provider.load(entitySet, ...args);
      },
      find(q, p, req) {
        if (p && p.__isJsreportRequest__ === true) {
          req = p;
          p = {};
        }
        p = p || {};
        const listenerPromise = this.beforeFindListeners.fire(q, p, req);
        const cursorCalls = [];
        const functions = ["skip", "limit", "sort", "toArray", "count"];
        const fakeCursor = {};
        functions.forEach((f) => {
          fakeCursor[f] = (...args) => {
            cursorCalls.push({ f, args });
            return fakeCursor;
          };
        });
        const replay = (cursor) => {
          cursorCalls.filter((c) => c.f !== "toArray" && c.f !== "count").forEach((c) => cursor[c.f].apply(cursor, c.args));
          if (cursorCalls.find((c) => c.f === "count")) {
            return cursor.count();
          }
          return cursor.toArray();
        };
        return Object.assign(fakeCursor, {
          then: (onFulfilled, onRejected) => {
            let promise = listenerPromise.then(() => {
              return replay(provider.find(entitySet, q, p, {
                transaction: transactions.getActiveTransaction(req)
              }));
            });
            if (typeof onFulfilled === "function") {
              promise = promise.then(onFulfilled);
            }
            if (typeof onRejected === "function") {
              promise = promise.catch(onRejected);
            }
            return promise;
          }
        });
      },
      findAdmin(q, p, req) {
        if (p && p.__isJsreportRequest__ === true) {
          req = p;
          p = {};
        }
        p = p || {};
        req = adminRequest(req, Request);
        return this.find(q, p, req);
      },
      async findOne(...args) {
        const res = await this.find(...args);
        if (res.length > 0) {
          return res[0];
        }
        return null;
      },
      findOneAdmin(q, p, req) {
        if (p && p.__isJsreportRequest__ === true) {
          req = p;
          p = {};
        }
        p = p || {};
        req = adminRequest(req, Request);
        return this.findOne(q, p, req);
      },
      count(...args) {
        return this.find(...args).count();
      },
      async insert(data, req) {
        await this.beforeInsertValidationListeners.fire(data, req);
        if (model.entitySets[entitySet] && model.entitySets[entitySet].entityTypeDef.name) {
          validateEntityName(data.name);
        }
        if (req == null || req.context.skipValidationFor !== data) {
          const entityType = model.entitySets[entitySet] ? model.entitySets[entitySet].normalizedEntityTypeName : null;
          if (entityType != null && validator.getSchema(entityType) != null) {
            const validationResult = validator.validate(entityType, data);
            if (!validationResult.valid) {
              throw createError(`Error when trying to insert into "${entitySet}" collection. input contain values that does not match the schema. ${validationResult.fullErrorMessage}`, {
                weak: true,
                statusCode: 400
              });
            }
          }
        }
        await this.beforeInsertListeners.fire(data, req);
        return provider.insert(entitySet, data, {
          transaction: transactions.getActiveTransaction(req)
        });
      },
      async update(q, u, o, req) {
        if (o && o.__isJsreportRequest__) {
          req = o;
          o = {};
        }
        await this.beforeUpdateValidationListeners.fire(q, u, o, req);
        if (model.entitySets[entitySet] && model.entitySets[entitySet].entityTypeDef.name && u.$set.name !== void 0) {
          validateEntityName(u.$set.name);
        }
        const entityType = model.entitySets[entitySet] ? model.entitySets[entitySet].normalizedEntityTypeName : null;
        if (entityType != null && validator.getSchema(entityType) != null) {
          const validationResult = validator.validate(entityType, u.$set);
          if (!validationResult.valid) {
            throw createError(`Error when trying to update "${entitySet}" collection. input contain values that does not match the schema. ${validationResult.fullErrorMessage}`, {
              weak: true,
              statusCode: 400
            });
          }
        }
        await this.beforeUpdateListeners.fire(q, u, o, req);
        const updateOpts = Object.assign({}, o);
        const activeTran = transactions.getActiveTransaction(req);
        if (activeTran) {
          updateOpts.transaction = activeTran;
        }
        return provider.update(entitySet, q, u, updateOpts);
      },
      async remove(q, req) {
        await this.beforeRemoveListeners.fire(q, req);
        return provider.remove(entitySet, q, {
          transaction: transactions.getActiveTransaction(req)
        });
      },
      async serializeProperties(docs, customTypeDef) {
        let typeDef;
        if (customTypeDef == null) {
          const entitySetInfo = model.entitySets[entitySet];
          const entityType = entitySetInfo.entityTypeDef;
          typeDef = entityType;
        } else {
          typeDef = customTypeDef;
        }
        if (!typeDef) {
          return;
        }
        return Promise.all(docs.map(async (doc) => {
          if (doc == null) {
            return doc;
          }
          const newDoc = Object.assign({}, doc);
          for (const prop in newDoc) {
            if (!prop) {
              continue;
            }
            const propDef = typeDef[prop];
            if (!propDef || propDef.type == null) {
              continue;
            }
            const resolveResult = resolvePropDefinition(model, propDef);
            if (!resolveResult) {
              continue;
            }
            const isCollection = resolveResult.def.type.startsWith("Collection(");
            if (propDef.encrypted === true) {
              if (isCollection && resolveResult.subType == null) {
                if (Array.isArray(newDoc[prop])) {
                  for (const [idx, value] of Object.entries(newDoc[prop])) {
                    newDoc[prop][idx] = await encryption.decrypt(value);
                  }
                }
              } else if (resolveResult.def.type.startsWith("Edm")) {
                newDoc[prop] = await encryption.decrypt(newDoc[prop]);
              }
            }
            if (isCollection || resolveResult.subType) {
              if (isCollection) {
                if (!Array.isArray(newDoc[prop])) {
                  continue;
                }
                if (resolveResult.subType) {
                  const result = await this.serializeProperties(newDoc[prop], resolveResult.subType);
                  newDoc[prop] = result;
                }
              } else {
                const result = await this.serializeProperties([newDoc[prop]], resolveResult.subType);
                newDoc[prop] = result[0];
              }
            } else if (propDef.type === "Edm.Binary") {
              newDoc[prop] = Buffer.from(newDoc[prop]).toString("base64");
            }
          }
          return newDoc;
        }));
      },
      async deserializeProperties(docs, customTypeDef) {
        let typeDef;
        if (customTypeDef == null) {
          const entitySetInfo = model.entitySets[entitySet];
          if (!entitySetInfo) {
            return [];
          }
          const entityType = entitySetInfo.entityTypeDef;
          if (!entityType) {
            return [];
          }
          typeDef = entityType;
        } else {
          typeDef = customTypeDef;
        }
        return Promise.all(docs.map(async (doc) => {
          if (doc == null) {
            return doc;
          }
          const newDoc = Object.assign({}, doc);
          for (const prop in newDoc) {
            if (!prop) {
              continue;
            }
            const propDef = typeDef[prop];
            if (!propDef || propDef.type == null) {
              continue;
            }
            const resolveResult = resolvePropDefinition(model, propDef);
            if (!resolveResult) {
              continue;
            }
            const isCollection = resolveResult.def.type.startsWith("Collection(");
            if (isCollection || resolveResult.subType) {
              if (isCollection) {
                if (!Array.isArray(newDoc[prop])) {
                  continue;
                }
                if (resolveResult.subType) {
                  const result = await this.deserializeProperties(newDoc[prop], resolveResult.subType);
                  newDoc[prop] = result;
                }
              } else {
                const result = await this.deserializeProperties([newDoc[prop]], resolveResult.subType);
                newDoc[prop] = result[0];
              }
            } else if (propDef.type === "Edm.Binary") {
              newDoc[prop] = Buffer.from(newDoc[prop], "base64");
            } else if (propDef.type === "Edm.DateTimeOffset") {
              newDoc[prop] = new Date(newDoc[prop]);
            }
            if (propDef.encrypted === true) {
              if (isCollection && resolveResult.subType == null) {
                if (Array.isArray(newDoc[prop])) {
                  for (const [idx, value] of Object.entries(newDoc[prop])) {
                    newDoc[prop][idx] = await encryption.encrypt(value);
                  }
                }
              } else if (resolveResult.def.type.startsWith("Edm")) {
                newDoc[prop] = await encryption.encrypt(newDoc[prop]);
              }
            }
          }
          return newDoc;
        }));
      }
    });
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/store/checkDuplicatedId.js
var require_checkDuplicatedId = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/store/checkDuplicatedId.js"(exports2, module2) {
    module2.exports = async function checkDuplicatedId(store, collectionName, idValue, req) {
      if (idValue == null) {
        return;
      }
      const existingEntity = await findEntity(store, collectionName, idValue, req);
      return existingEntity;
    };
    async function findEntity(store, collectionName, idValue, req) {
      const existingEntity = await store.collection(collectionName).findOneAdmin({
        _id: idValue
      }, req);
      return existingEntity;
    }
  }
});

// node_modules/@jsreport/mingo/dist/mingo.js
var require_mingo = __commonJS({
  "node_modules/@jsreport/mingo/dist/mingo.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.mingo = factory());
    })(exports2, function() {
      "use strict";
      var T_NULL = "null";
      var T_UNDEFINED = "undefined";
      var T_BOOL = "bool";
      var T_BOOLEAN = "boolean";
      var T_NUMBER = "number";
      var T_STRING = "string";
      var T_DATE = "date";
      var T_REGEX = "regex";
      var T_REGEXP = "regexp";
      var T_ARRAY = "array";
      var T_OBJECT = "object";
      var T_FUNCTION = "function";
      var JS_SIMPLE_TYPES = [T_NULL, T_UNDEFINED, T_BOOLEAN, T_NUMBER, T_STRING, T_DATE, T_REGEXP];
      var OP_EXPRESSION = "expression";
      var OP_GROUP = "group";
      var OP_PIPELINE = "pipeline";
      var OP_PROJECTION = "projection";
      var OP_QUERY = "query";
      var MISSING = function MISSING2() {
      };
      if (!Array.prototype.includes) {
        Object.defineProperty(Array.prototype, "includes", {
          value: function value(valueToFind, fromIndex) {
            if (this == null) {
              throw new TypeError('"this" is null or not defined');
            }
            var o = Object(this);
            var len = o.length >>> 0;
            if (len === 0) {
              return false;
            }
            var n = fromIndex | 0;
            var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
            function sameValueZero(x, y) {
              return x === y || typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
            }
            while (k < len) {
              if (sameValueZero(o[k], valueToFind)) {
                return true;
              }
              k++;
            }
            return false;
          }
        });
      }
      var arrayPush = Array.prototype.push;
      function assert(condition, message) {
        if (!condition) err(message);
      }
      function cloneDeep(obj) {
        switch (jsType(obj)) {
          case T_ARRAY:
            return obj.map(cloneDeep);
          case T_OBJECT:
            return objectMap(obj, cloneDeep);
          default:
            return obj;
        }
      }
      function clone(obj) {
        switch (jsType(obj)) {
          case T_ARRAY:
            return into([], obj);
          case T_OBJECT:
            return Object.assign({}, obj);
          default:
            return obj;
        }
      }
      function getType(v) {
        if (v === null) return "Null";
        if (v === void 0) return "Undefined";
        return v.constructor.name;
      }
      function jsType(v) {
        return getType(v).toLowerCase();
      }
      function isBoolean(v) {
        return jsType(v) === T_BOOLEAN;
      }
      function isString(v) {
        return jsType(v) === T_STRING;
      }
      function isNumber(v) {
        return jsType(v) === T_NUMBER;
      }
      var isArray = Array.isArray || function(v) {
        return !!v && v.constructor === Array;
      };
      function isObject(v) {
        return !!v && v.constructor === Object;
      }
      function isObjectLike(v) {
        return v === Object(v);
      }
      function isDate(v) {
        return jsType(v) === T_DATE;
      }
      function isRegExp(v) {
        return jsType(v) === T_REGEXP;
      }
      function isFunction(v) {
        return jsType(v) === T_FUNCTION;
      }
      function isNil(v) {
        return isNull(v) || isUndefined(v);
      }
      function isNull(v) {
        return v === null;
      }
      function isUndefined(v) {
        return v === void 0;
      }
      function inArray(arr, item) {
        return arr.includes(item);
      }
      function notInArray(arr, item) {
        return !inArray(arr, item);
      }
      function truthy(arg) {
        return !!arg;
      }
      function isEmpty(x) {
        return isNil(x) || isArray(x) && x.length === 0 || isObject(x) && keys(x).length === 0 || !x;
      }
      function ensureArray(x) {
        return isArray(x) ? x : [x];
      }
      function has(obj, prop) {
        return obj.hasOwnProperty(prop);
      }
      function err(s) {
        throw new Error(s);
      }
      var keys = Object.keys;
      function each(obj, fn, ctx) {
        fn = fn.bind(ctx);
        if (isArray(obj)) {
          for (var i = 0, len = obj.length; i < len; i++) {
            if (fn(obj[i], i, obj) === false) break;
          }
        } else {
          for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
              if (fn(obj[k], k, obj) === false) break;
            }
          }
        }
      }
      function objectMap(obj, fn, ctx) {
        fn = fn.bind(ctx);
        var o = {};
        var objKeys = keys(obj);
        for (var i = 0; i < objKeys.length; i++) {
          var k = objKeys[i];
          o[k] = fn(obj[k], k);
        }
        return o;
      }
      function merge(target, obj) {
        var opt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (target === MISSING) return obj;
        if (obj === MISSING) return target;
        var inputs = [target, obj];
        if (!(inputs.every(isObject) || inputs.every(isArray))) {
          throw Error("mismatched types. must both be array or object");
        }
        opt.flatten = opt.flatten || false;
        if (isArray(target)) {
          if (opt.flatten) {
            var i = 0;
            var j = 0;
            while (i < target.length && j < obj.length) {
              target[i] = merge(target[i++], obj[j++], opt);
            }
            while (j < obj.length) {
              target.push(obj[j++]);
            }
          } else {
            arrayPush.apply(target, obj);
          }
        } else {
          Object.keys(obj).forEach(function(k) {
            if (target.hasOwnProperty(k)) {
              target[k] = merge(target[k], obj[k], opt);
            } else {
              target[k] = obj[k];
            }
          });
        }
        return target;
      }
      function reduce(collection, fn, accumulator) {
        if (isArray(collection)) return collection.reduce(fn, accumulator);
        each(collection, function(v, k) {
          return accumulator = fn(accumulator, v, k, collection);
        });
        return accumulator;
      }
      function intersection(xs, ys) {
        var hashes = ys.map(hashCode);
        return xs.filter(function(v) {
          return inArray(hashes, hashCode(v));
        });
      }
      function union(xs, ys) {
        return into(into([], xs), ys.filter(notInArray.bind(null, xs)));
      }
      function flatten(xs) {
        var depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
        var arr = [];
        function flatten2(ys, iter) {
          for (var i = 0, len = ys.length; i < len; i++) {
            if (isArray(ys[i]) && (iter > 0 || iter < 0)) {
              flatten2(ys[i], Math.max(-1, iter - 1));
            } else {
              arr.push(ys[i]);
            }
          }
        }
        flatten2(xs, depth);
        return arr;
      }
      function unwrap(arr, depth) {
        if (depth < 1) return arr;
        while (depth-- && isArray(arr) && arr.length === 1) {
          arr = arr[0];
        }
        return arr;
      }
      function isEqual(a, b) {
        var lhs = [a];
        var rhs = [b];
        while (lhs.length > 0) {
          a = lhs.pop();
          b = rhs.pop();
          if (a === b) continue;
          var type = jsType(a);
          if (type !== jsType(b) || type === T_FUNCTION) return false;
          switch (type) {
            case T_ARRAY:
              if (a.length !== b.length) return false;
              into(lhs, a);
              into(rhs, b);
              break;
            case T_OBJECT:
              var ka = keys(a);
              var kb = keys(b);
              if (ka.length !== kb.length) return false;
              ka.sort();
              kb.sort();
              for (var i = 0, len = ka.length; i < len; i++) {
                var temp = ka[i];
                if (temp !== kb[i]) {
                  return false;
                } else {
                  lhs.push(a[temp]);
                  rhs.push(b[temp]);
                }
              }
              break;
            default:
              if (encode(a) !== encode(b)) return false;
          }
        }
        return lhs.length === 0;
      }
      function unique(xs) {
        var h = {};
        var arr = [];
        each(xs, function(item) {
          var k = hashCode(item);
          if (!has(h, k)) {
            arr.push(item);
            h[k] = 0;
          }
        });
        return arr;
      }
      function encode(value) {
        var type = jsType(value);
        switch (type) {
          case T_BOOLEAN:
          case T_NUMBER:
          case T_REGEXP:
            return value.toString();
          case T_STRING:
            return JSON.stringify(value);
          case T_DATE:
            return value.toISOString();
          case T_NULL:
          case T_UNDEFINED:
            return type;
          case T_ARRAY:
            return "[" + value.map(encode) + "]";
          default:
            var prefix = type === T_OBJECT ? "" : "".concat(getType(value));
            var objKeys = keys(value);
            objKeys.sort();
            return "".concat(prefix, "{") + objKeys.map(function(k) {
              return "".concat(encode(k), ":").concat(encode(value[k]));
            }) + "}";
        }
      }
      function hashCode(value) {
        if (isNil(value)) return null;
        var hash = 0;
        var s = encode(value);
        var i = s.length;
        while (i) {
          hash = (hash << 5) - hash ^ s.charCodeAt(--i);
        }
        return hash >>> 0;
      }
      function compare(a, b) {
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
      }
      function sortBy(collection, fn, cmp) {
        var sorted = [];
        var result = [];
        var hash = /* @__PURE__ */ new Map();
        cmp = cmp || compare;
        if (isEmpty(collection)) return collection;
        for (var i = 0; i < collection.length; i++) {
          var obj = collection[i];
          var key = fn(obj, i);
          if (isNil(key)) {
            result.push(obj);
          } else {
            if (hash.has(key)) {
              hash.get(key).push(obj);
            } else {
              hash.set(key, [obj]);
            }
            sorted.push(key);
          }
        }
        sorted.sort(cmp);
        for (var _i = 0; _i < sorted.length; _i++) {
          into(result, hash.get(sorted[_i]));
        }
        hash.clear();
        return result;
      }
      function groupBy(collection, fn) {
        var result = {
          "keys": [],
          "groups": []
        };
        var lookup = {};
        each(collection, function(obj) {
          var key = fn(obj);
          var hash = hashCode(key);
          var index2 = -1;
          if (lookup[hash] === void 0) {
            index2 = result.keys.length;
            lookup[hash] = index2;
            result.keys.push(key);
            result.groups.push([]);
          }
          index2 = lookup[hash];
          result.groups[index2].push(obj);
        });
        return result;
      }
      function into(target, xs) {
        arrayPush.apply(target, xs);
        return target;
      }
      function findInsertIndex(array, item) {
        var lo = 0;
        var hi = array.length - 1;
        while (lo <= hi) {
          var mid = Math.round(lo + (hi - lo) / 2);
          if (item < array[mid]) {
            hi = mid - 1;
          } else if (item > array[mid]) {
            lo = mid + 1;
          } else {
            return mid;
          }
        }
        return lo;
      }
      function memoize(fn) {
        var _this = this;
        return /* @__PURE__ */ function(cache) {
          return function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            var key = hashCode(args);
            if (!has(cache, key)) {
              cache[key] = fn.apply(_this, args);
            }
            return cache[key];
          };
        }({
          /* storage */
        });
      }
      var arithmeticOperators = {
        /**
         * Returns the absolute value of a number.
         * https://docs.mongodb.com/manual/reference/operator/aggregation/abs/#exp._S_abs
         *
         * @param obj
         * @param expr
         * @return {Number|null|NaN}
         */
        $abs: function $abs(obj, expr) {
          var val = computeValue(obj, expr);
          return val === null || val === void 0 ? null : Math.abs(val);
        },
        /**
         * Computes the sum of an array of numbers.
         *
         * @param obj
         * @param expr
         * @returns {Object}
         */
        $add: function $add(obj, expr) {
          var args = computeValue(obj, expr);
          var foundDate = false;
          var result = reduce(args, function(acc, val) {
            if (isDate(val)) {
              assert(!foundDate, "'$add' can only have one date value");
              foundDate = true;
              val = val.getTime();
            }
            acc += val;
            return acc;
          }, 0);
          return foundDate ? new Date(result) : result;
        },
        /**
         * Returns the smallest integer greater than or equal to the specified number.
         *
         * @param obj
         * @param expr
         * @returns {number}
         */
        $ceil: function $ceil(obj, expr) {
          var arg = computeValue(obj, expr);
          if (isNil(arg)) return null;
          assert(isNumber(arg) || isNaN(arg), "$ceil expression must resolve to a number.");
          return Math.ceil(arg);
        },
        /**
         * Takes two numbers and divides the first number by the second.
         *
         * @param obj
         * @param expr
         * @returns {number}
         */
        $divide: function $divide(obj, expr) {
          var args = computeValue(obj, expr);
          return args[0] / args[1];
        },
        /**
         * Raises Eulers number (i.e. e ) to the specified exponent and returns the result.
         *
         * @param obj
         * @param expr
         * @returns {number}
         */
        $exp: function $exp(obj, expr) {
          var arg = computeValue(obj, expr);
          if (isNil(arg)) return null;
          assert(isNumber(arg) || isNaN(arg), "$exp expression must resolve to a number.");
          return Math.exp(arg);
        },
        /**
         * Returns the largest integer less than or equal to the specified number.
         *
         * @param obj
         * @param expr
         * @returns {number}
         */
        $floor: function $floor(obj, expr) {
          var arg = computeValue(obj, expr);
          if (isNil(arg)) return null;
          assert(isNumber(arg) || isNaN(arg), "$floor expression must resolve to a number.");
          return Math.floor(arg);
        },
        /**
         * Calculates the natural logarithm ln (i.e loge) of a number and returns the result as a double.
         *
         * @param obj
         * @param expr
         * @returns {number}
         */
        $ln: function $ln(obj, expr) {
          var arg = computeValue(obj, expr);
          if (isNil(arg)) return null;
          assert(isNumber(arg) || isNaN(arg), "$ln expression must resolve to a number.");
          return Math.log(arg);
        },
        /**
         * Calculates the log of a number in the specified base and returns the result as a double.
         *
         * @param obj
         * @param expr
         * @returns {number}
         */
        $log: function $log(obj, expr) {
          var args = computeValue(obj, expr);
          var msg = "$log expression must resolve to array(2) of numbers";
          assert(isArray(args) && args.length === 2, msg);
          if (args.some(isNil)) return null;
          assert(args.some(isNaN) || args.every(isNumber), msg);
          return Math.log10(args[0]) / Math.log10(args[1]);
        },
        /**
         * Calculates the log base 10 of a number and returns the result as a double.
         *
         * @param obj
         * @param expr
         * @returns {number}
         */
        $log10: function $log10(obj, expr) {
          var arg = computeValue(obj, expr);
          if (isNil(arg)) return null;
          assert(isNumber(arg) || isNaN(arg), "$log10 expression must resolve to a number.");
          return Math.log10(arg);
        },
        /**
         * Takes two numbers and calculates the modulo of the first number divided by the second.
         *
         * @param obj
         * @param expr
         * @returns {number}
         */
        $mod: function $mod(obj, expr) {
          var args = computeValue(obj, expr);
          return args[0] % args[1];
        },
        /**
         * Computes the product of an array of numbers.
         *
         * @param obj
         * @param expr
         * @returns {Object}
         */
        $multiply: function $multiply(obj, expr) {
          var args = computeValue(obj, expr);
          return reduce(args, function(acc, num) {
            return acc * num;
          }, 1);
        },
        /**
         * Raises a number to the specified exponent and returns the result.
         *
         * @param obj
         * @param expr
         * @returns {Object}
         */
        $pow: function $pow(obj, expr) {
          var args = computeValue(obj, expr);
          assert(isArray(args) && args.length === 2 && args.every(isNumber), "$pow expression must resolve to array(2) of numbers");
          assert(!(args[0] === 0 && args[1] < 0), "$pow cannot raise 0 to a negative exponent");
          return Math.pow(args[0], args[1]);
        },
        /**
         * Calculates the square root of a positive number and returns the result as a double.
         *
         * @param obj
         * @param expr
         * @returns {number}
         */
        $sqrt: function $sqrt(obj, expr) {
          var n = computeValue(obj, expr);
          if (isNil(n)) return null;
          assert(isNumber(n) && n > 0 || isNaN(n), "$sqrt expression must resolve to non-negative number.");
          return Math.sqrt(n);
        },
        /**
         * Takes an array that contains two numbers or two dates and subtracts the second value from the first.
         *
         * @param obj
         * @param expr
         * @returns {number}
         */
        $subtract: function $subtract(obj, expr) {
          var args = computeValue(obj, expr);
          return args[0] - args[1];
        },
        /**
         * Truncates a number to its integer.
         *
         * @param obj
         * @param expr
         * @returns {number}
         */
        $trunc: function $trunc(obj, expr) {
          var n = computeValue(obj, expr);
          if (isNil(n)) return null;
          assert(isNumber(n) || isNaN(n), "$trunc expression must resolve to a number.");
          return Math.trunc(n);
        }
      };
      var arrayOperators = {
        /**
         * Returns the element at the specified array index.
         *
         * @param  {Object} obj
         * @param  {*} expr
         * @return {*}
         */
        $arrayElemAt: function $arrayElemAt(obj, expr) {
          var arr = computeValue(obj, expr);
          assert(isArray(arr) && arr.length === 2, "$arrayElemAt expression must resolve to array(2)");
          assert(isArray(arr[0]), "First operand to $arrayElemAt must resolve to an array");
          assert(isNumber(arr[1]), "Second operand to $arrayElemAt must resolve to an integer");
          var idx = arr[1];
          arr = arr[0];
          if (idx < 0 && Math.abs(idx) <= arr.length) {
            return arr[idx + arr.length];
          } else if (idx >= 0 && idx < arr.length) {
            return arr[idx];
          }
          return void 0;
        },
        /**
         * Converts an array of key value pairs to a document.
         */
        $arrayToObject: function $arrayToObject(obj, expr) {
          var arr = computeValue(obj, expr);
          assert(isArray(arr), "$arrayToObject expression must resolve to an array");
          return reduce(arr, function(newObj, val) {
            if (isArray(val) && val.length == 2) {
              newObj[val[0]] = val[1];
            } else {
              assert(isObject(val) && has(val, "k") && has(val, "v"), "$arrayToObject expression is invalid.");
              newObj[val.k] = val.v;
            }
            return newObj;
          }, {});
        },
        /**
         * Concatenates arrays to return the concatenated array.
         *
         * @param  {Object} obj
         * @param  {*} expr
         * @return {*}
         */
        $concatArrays: function $concatArrays(obj, expr) {
          var arr = computeValue(obj, expr, null);
          assert(isArray(arr), "$concatArrays must resolve to an array");
          if (arr.some(isNil)) return null;
          return arr.reduce(function(acc, item) {
            return into(acc, item);
          }, []);
        },
        /**
         * Selects a subset of the array to return an array with only the elements that match the filter condition.
         *
         * @param  {Object} obj  [description]
         * @param  {*} expr [description]
         * @return {*}      [description]
         */
        $filter: function $filter(obj, expr) {
          var input = computeValue(obj, expr.input);
          var asVar = expr["as"];
          var condExpr = expr["cond"];
          assert(isArray(input), "$filter 'input' expression must resolve to an array");
          return input.filter(function(o) {
            var tempObj = {};
            tempObj["$" + asVar] = o;
            return computeValue(tempObj, condExpr) === true;
          });
        },
        /**
         * Returns a boolean indicating whether a specified value is in an array.
         *
         * @param {Object} obj
         * @param {Array} expr
         */
        $in: function $in(obj, expr) {
          var val = computeValue(obj, expr[0]);
          var arr = computeValue(obj, expr[1]);
          assert(isArray(arr), "$in second argument must be an array");
          return arr.some(isEqual.bind(null, val));
        },
        /**
         * Searches an array for an occurrence of a specified value and returns the array index of the first occurrence.
         * If the substring is not found, returns -1.
         *
         * @param  {Object} obj
         * @param  {*} expr
         * @return {*}
         */
        $indexOfArray: function $indexOfArray(obj, expr) {
          var args = computeValue(obj, expr);
          if (isNil(args)) return null;
          var arr = args[0];
          var searchValue = args[1];
          if (isNil(arr)) return null;
          assert(isArray(arr), "$indexOfArray expression must resolve to an array.");
          var start = args[2] || 0;
          var end = args[3];
          if (isNil(end)) end = arr.length;
          if (start > end) return -1;
          assert(start >= 0 && end >= 0, "$indexOfArray expression is invalid");
          if (start > 0 || end < arr.length) {
            arr = arr.slice(start, end);
          }
          return arr.findIndex(isEqual.bind(null, searchValue)) + start;
        },
        /**
         * Determines if the operand is an array. Returns a boolean.
         *
         * @param  {Object}  obj
         * @param  {*}  expr
         * @return {Boolean}
         */
        $isArray: function $isArray(obj, expr) {
          return isArray(computeValue(obj, expr[0]));
        },
        /**
         * Applies a sub-expression to each element of an array and returns the array of resulting values in order.
         *
         * @param obj
         * @param expr
         * @returns {Array|*}
         */
        $map: function $map(obj, expr) {
          var inputExpr = computeValue(obj, expr.input);
          assert(isArray(inputExpr), "$map 'input' expression must resolve to an array");
          var asExpr = expr["as"];
          var inExpr = expr["in"];
          var tempKey = "$" + asExpr;
          return inputExpr.map(function(item) {
            obj[tempKey] = item;
            return computeValue(obj, inExpr);
          });
        },
        /**
         * Converts a document to an array of documents representing key-value pairs.
         */
        $objectToArray: function $objectToArray(obj, expr) {
          var val = computeValue(obj, expr);
          assert(isObject(val), "$objectToArray expression must resolve to an object");
          var arr = [];
          each(val, function(v, k) {
            return arr.push({
              k,
              v
            });
          });
          return arr;
        },
        /**
         * Returns an array whose elements are a generated sequence of numbers.
         *
         * @param  {Object} obj
         * @param  {*} expr
         * @return {*}
         */
        $range: function $range(obj, expr) {
          var arr = computeValue(obj, expr);
          var start = arr[0];
          var end = arr[1];
          var step = arr[2] || 1;
          var result = [];
          while (start < end && step > 0 || start > end && step < 0) {
            result.push(start);
            start += step;
          }
          return result;
        },
        /**
         * Applies an expression to each element in an array and combines them into a single value.
         *
         * @param {Object} obj
         * @param {*} expr
         */
        $reduce: function $reduce(obj, expr) {
          var input = computeValue(obj, expr.input);
          var initialValue = computeValue(obj, expr.initialValue);
          var inExpr = expr["in"];
          if (isNil(input)) return null;
          assert(isArray(input), "$reduce 'input' expression must resolve to an array");
          return reduce(input, function(acc, n) {
            return computeValue({
              "$value": acc,
              "$this": n
            }, inExpr);
          }, initialValue);
        },
        /**
         * Returns an array with the elements in reverse order.
         *
         * @param  {Object} obj
         * @param  {*} expr
         * @return {*}
         */
        $reverseArray: function $reverseArray(obj, expr) {
          var arr = computeValue(obj, expr);
          if (isNil(arr)) return null;
          assert(isArray(arr), "$reverseArray expression must resolve to an array");
          var result = [];
          into(result, arr);
          result.reverse();
          return result;
        },
        /**
         * Counts and returns the total the number of items in an array.
         *
         * @param obj
         * @param expr
         */
        $size: function $size(obj, expr) {
          var value = computeValue(obj, expr);
          return isArray(value) ? value.length : void 0;
        },
        /**
         * Returns a subset of an array.
         *
         * @param  {Object} obj
         * @param  {*} expr
         * @return {*}
         */
        $slice: function $slice(obj, expr) {
          var arr = computeValue(obj, expr);
          return slice(arr[0], arr[1], arr[2]);
        },
        /**
         * Merge two lists together.
         *
         * Transposes an array of input arrays so that the first element of the output array would be an array containing,
         * the first element of the first input array, the first element of the second input array, etc.
         *
         * @param  {Obj} obj
         * @param  {*} expr
         * @return {*}
         */
        $zip: function $zip(obj, expr) {
          var inputs = computeValue(obj, expr.inputs);
          var useLongestLength = expr.useLongestLength || false;
          assert(isArray(inputs), "'inputs' expression must resolve to an array");
          assert(isBoolean(useLongestLength), "'useLongestLength' must be a boolean");
          if (isArray(expr.defaults)) {
            assert(truthy(useLongestLength), "'useLongestLength' must be set to true to use 'defaults'");
          }
          var zipCount = 0;
          for (var i = 0, len = inputs.length; i < len; i++) {
            var arr = inputs[i];
            if (isNil(arr)) return null;
            assert(isArray(arr), "'inputs' expression values must resolve to an array or null");
            zipCount = useLongestLength ? Math.max(zipCount, arr.length) : Math.min(zipCount || arr.length, arr.length);
          }
          var result = [];
          var defaults = expr.defaults || [];
          var _loop = function _loop2(_i2) {
            var temp = inputs.map(function(val, index2) {
              return isNil(val[_i2]) ? defaults[index2] || null : val[_i2];
            });
            result.push(temp);
          };
          for (var _i = 0; _i < zipCount; _i++) {
            _loop(_i);
          }
          return result;
        },
        /**
         * Combines multiple documents into a single document.
         * @param {*} obj
         * @param {*} expr
         */
        $mergeObjects: function $mergeObjects2(obj, expr) {
          var docs = computeValue(obj, expr);
          if (isArray(docs)) {
            return reduce(docs, function(memo, o) {
              return Object.assign(memo, o);
            }, {});
          }
          return {};
        }
      };
      var booleanOperators = {
        /**
         * Returns true only when all its expressions evaluate to true. Accepts any number of argument expressions.
         *
         * @param obj
         * @param expr
         * @returns {boolean}
         */
        $and: function $and(obj, expr) {
          var value = computeValue(obj, expr);
          return truthy(value) && value.every(truthy);
        },
        /**
         * Returns true when any of its expressions evaluates to true. Accepts any number of argument expressions.
         *
         * @param obj
         * @param expr
         * @returns {boolean}
         */
        $or: function $or(obj, expr) {
          var value = computeValue(obj, expr);
          return truthy(value) && value.some(truthy);
        },
        /**
         * Returns the boolean value that is the opposite of its argument expression. Accepts a single argument expression.
         *
         * @param obj
         * @param expr
         * @returns {boolean}
         */
        $not: function $not(obj, expr) {
          return !computeValue(obj, expr[0]);
        }
      };
      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function $addFields(collection, expr, opt) {
        var newFields = keys(expr);
        if (newFields.length === 0) return collection;
        return collection.map(function(obj) {
          var newObj = cloneDeep(obj);
          each(newFields, function(field) {
            var newValue = computeValue(obj, expr[field]);
            setValue(newObj, field, newValue);
          });
          return newObj;
        });
      }
      function $set() {
        return $addFields.apply(void 0, arguments);
      }
      function Lazy(source) {
        return source instanceof Iterator ? source : new Iterator(source);
      }
      Lazy.isIterator = isIterator;
      function isIterator(o) {
        return !!o && _typeof(o) === "object" && isFn(o.next);
      }
      function isFn(f) {
        return !!f && typeof f === "function";
      }
      function dropItem(array, i) {
        var rest = array.slice(i + 1);
        array.splice(i);
        Array.prototype.push.apply(array, rest);
      }
      var DONE = new Error();
      var LAZY_MAP = 1;
      var LAZY_FILTER = 2;
      var LAZY_TAKE = 3;
      var LAZY_DROP = 4;
      function baseIterator(nextFn, iteratees, buffer) {
        var done = false;
        var index2 = -1;
        var bIndex = 0;
        return function(b) {
          b = b === buffer;
          try {
            outer: while (!done) {
              var o = nextFn();
              index2++;
              var mIndex = -1;
              var mSize = iteratees.length;
              var innerDone = false;
              while (++mIndex < mSize) {
                var member = iteratees[mIndex], func = member.func, type = member.type;
                switch (type) {
                  case LAZY_MAP:
                    o = func(o, index2);
                    break;
                  case LAZY_FILTER:
                    if (!func(o, index2)) continue outer;
                    break;
                  case LAZY_TAKE:
                    --member.func;
                    if (!member.func) innerDone = true;
                    break;
                  case LAZY_DROP:
                    --member.func;
                    if (!member.func) dropItem(iteratees, mIndex);
                    continue outer;
                  default:
                    break outer;
                }
              }
              done = innerDone;
              if (b) {
                buffer[bIndex++] = o;
              } else {
                return {
                  value: o,
                  done: false
                };
              }
            }
          } catch (e) {
            if (e !== DONE) throw e;
          }
          done = true;
          return {
            done: true
          };
        };
      }
      var Iterator = /* @__PURE__ */ function() {
        function Iterator2(source) {
          _classCallCheck(this, Iterator2);
          this.__iteratees = [];
          this.__first = false;
          this.__done = false;
          this.__buf = [];
          if (isFn(source)) {
            source = {
              next: source
            };
          }
          if (isIterator(source)) {
            var src = source;
            source = function source2() {
              var o = src.next();
              if (o.done) throw DONE;
              return o.value;
            };
          } else if (Array.isArray(source)) {
            var data = source;
            var size = data.length;
            var index2 = 0;
            source = function source2() {
              if (index2 < size) return data[index2++];
              throw DONE;
            };
          } else if (!isFn(source)) {
            throw new Error("Source is not iterable. Must be Array, Function or Object{next:Function}");
          }
          this.next = baseIterator(source, this.__iteratees, this.__buf);
        }
        _createClass(Iterator2, [{
          key: Symbol.iterator,
          value: function value() {
            return this;
          }
        }, {
          key: "_validate",
          value: function _validate() {
            if (this.__first) throw new Error("Cannot add iteratee/transform after `first()`");
          }
          /**
           * Add an iteratee to this lazy sequence
           * @param {Object} iteratee
           */
        }, {
          key: "_push",
          value: function _push(iteratee) {
            this._validate();
            this.__iteratees.push(iteratee);
            return this;
          }
          // Iteratees methods
          /**
           * Transform each item in the sequence to a new value
           * @param {Function} f
           */
        }, {
          key: "map",
          value: function map(f) {
            return this._push({
              type: LAZY_MAP,
              func: f
            });
          }
          /**
           * Select only items matching the given predicate
           * @param {Function} pred
           */
        }, {
          key: "filter",
          value: function filter(pred) {
            return this._push({
              type: LAZY_FILTER,
              func: pred
            });
          }
          /**
           * Take given numbe for values from sequence
           * @param {Number} n A number greater than 0
           */
        }, {
          key: "take",
          value: function take(n) {
            return n > 0 ? this._push({
              type: LAZY_TAKE,
              func: n
            }) : this;
          }
          /**
           * Drop a number of values from the sequence
           * @param {Number} n Number of items to drop greater than 0
           */
        }, {
          key: "drop",
          value: function drop(n) {
            return n > 0 ? this._push({
              type: LAZY_DROP,
              func: n
            }) : this;
          }
          // Transformations
          /**
           * Returns a new lazy object with results of the transformation
           * The entire sequence is realized.
           *
           * @param {Function} fn Tranform function of type (Array) => (Any)
           */
        }, {
          key: "transform",
          value: function transform(fn) {
            this._validate();
            var self2 = this;
            var iter;
            return Lazy(function() {
              if (!iter) {
                iter = Lazy(fn(self2.value()));
              }
              return iter.next();
            });
          }
          /**
           * Mark this lazy object to return only the first result on `lazy.value()`.
           * No more iteratees or transformations can be added after this method is called.
           */
        }, {
          key: "first",
          value: function first() {
            this.take(1);
            this.__first = true;
            return this;
          }
          // Terminal methods
          /**
           * Returns the fully realized values of the iterators.
           * The return value will be an array unless `lazy.first()` was used.
           * The realized values are cached for subsequent calls
           */
        }, {
          key: "value",
          value: function value() {
            if (!this.__done) {
              this.__done = this.next(this.__buf).done;
            }
            return this.__first ? this.__buf[0] : this.__buf;
          }
          /**
           * Execute the funcion for each value. Will stop when an execution returns false.
           * @param {Function} f
           * @returns {Boolean} false iff `f` return false for any execution, otherwise true
           */
        }, {
          key: "each",
          value: function each2(f) {
            while (1) {
              var o = this.next();
              if (o.done) break;
              if (f(o.value) === false) return false;
            }
            return true;
          }
          /**
           * Returns the reduction of sequence according the reducing function
           *
           * @param {*} f a reducing function
           * @param {*} init
           */
        }, {
          key: "reduce",
          value: function reduce2(f, init) {
            var o = this.next();
            var i = 0;
            if (init === void 0 && !o.done) {
              init = o.value;
              o = this.next();
              i++;
            }
            while (!o.done) {
              init = f(init, o.value, i++);
              o = this.next();
            }
            return init;
          }
          /**
           * Returns the number of matched items in the sequence
           */
        }, {
          key: "size",
          value: function size() {
            return this.reduce(function(acc, n) {
              return ++acc;
            }, 0);
          }
        }]);
        return Iterator2;
      }();
      function $bucket(collection, expr, opt) {
        var boundaries = expr.boundaries;
        var defaultKey = expr["default"];
        var lower = boundaries[0];
        var upper = boundaries[boundaries.length - 1];
        var outputExpr = expr.output || {
          "count": {
            "$sum": 1
          }
        };
        assert(boundaries.length > 2, "$bucket 'boundaries' expression must have at least 3 elements");
        var boundType = getType(lower);
        for (var i = 0, len = boundaries.length - 1; i < len; i++) {
          assert(boundType === getType(boundaries[i + 1]), "$bucket 'boundaries' must all be of the same type");
          assert(boundaries[i] < boundaries[i + 1], "$bucket 'boundaries' must be sorted in ascending order");
        }
        !isNil(defaultKey) && getType(expr["default"]) === getType(lower) && assert(lower > expr["default"] || upper < expr["default"], "$bucket 'default' expression must be out of boundaries range");
        var grouped = {};
        each(boundaries, function(k) {
          return grouped[k] = [];
        });
        if (!isNil(defaultKey)) grouped[defaultKey] = [];
        var iter = false;
        return Lazy(function() {
          if (!iter) {
            collection.each(function(obj) {
              var key = computeValue(obj, expr.groupBy);
              if (isNil(key) || key < lower || key >= upper) {
                assert(!isNil(defaultKey), "$bucket require a default for out of range values");
                grouped[defaultKey].push(obj);
              } else {
                assert(key >= lower && key < upper, "$bucket 'groupBy' expression must resolve to a value in range of boundaries");
                var index2 = findInsertIndex(boundaries, key);
                var boundKey = boundaries[Math.max(0, index2 - 1)];
                grouped[boundKey].push(obj);
              }
            });
            boundaries.pop();
            if (!isNil(defaultKey)) boundaries.push(defaultKey);
            iter = Lazy(boundaries).map(function(key) {
              var acc = accumulate(grouped[key], null, outputExpr);
              return Object.assign(acc, {
                "_id": key
              });
            });
          }
          return iter.next();
        });
      }
      function $bucketAuto(collection, expr, opt) {
        var outputExpr = expr.output || {
          "count": {
            "$sum": 1
          }
        };
        var groupByExpr = expr.groupBy;
        var bucketCount = expr.buckets;
        assert(bucketCount > 0, "The $bucketAuto 'buckets' field must be greater than 0, but found: " + bucketCount);
        return collection.transform(function(coll) {
          var approxBucketSize = Math.max(1, Math.round(coll.length / bucketCount));
          var computeValueOptimized = memoize(computeValue);
          var grouped = {};
          var remaining = [];
          var sorted = sortBy(coll, function(o) {
            var key2 = computeValueOptimized(o, groupByExpr);
            if (isNil(key2)) {
              remaining.push(o);
            } else {
              grouped[key2] || (grouped[key2] = []);
              grouped[key2].push(o);
            }
            return key2;
          });
          var ID_KEY = idKey();
          var result = [];
          var index2 = 0;
          for (var i = 0, len = sorted.length; i < bucketCount && index2 < len; i++) {
            var boundaries = {};
            var bucketItems = [];
            for (var j = 0; j < approxBucketSize && index2 < len; j++) {
              var key = computeValueOptimized(sorted[index2], groupByExpr);
              if (isNil(key)) key = null;
              into(bucketItems, isNil(key) ? remaining : grouped[key]);
              index2 += isNil(key) ? remaining.length : grouped[key].length;
              if (!has(boundaries, "min")) boundaries.min = key;
              if (result.length > 0) {
                var lastBucket = result[result.length - 1];
                lastBucket[ID_KEY].max = boundaries.min;
              }
            }
            if (i == bucketCount - 1) {
              into(bucketItems, sorted.slice(index2));
            }
            result.push(Object.assign(accumulate(bucketItems, null, outputExpr), {
              "_id": boundaries
            }));
          }
          if (result.length > 0) {
            result[result.length - 1][ID_KEY].max = computeValueOptimized(sorted[sorted.length - 1], groupByExpr);
          }
          return result;
        });
      }
      function $count(collection, expr, opt) {
        assert(isString(expr) && expr.trim() !== "" && expr.indexOf(".") === -1 && expr.trim()[0] !== "$", "Invalid expression value for $count");
        return Lazy(function() {
          var o = {};
          o[expr] = collection.size();
          return {
            value: o,
            done: false
          };
        }).first();
      }
      function $facet(collection, expr, opt) {
        return collection.transform(function(array) {
          return [objectMap(expr, function(pipeline) {
            return aggregate(array, pipeline);
          })];
        });
      }
      function $group(collection, expr, opt) {
        var ID_KEY = idKey();
        var id = expr[ID_KEY];
        return collection.transform(function(coll) {
          var partitions = groupBy(coll, function(obj) {
            return computeValue(obj, id, id);
          });
          expr = clone(expr);
          delete expr[ID_KEY];
          var i = -1;
          var size = partitions.keys.length;
          return function() {
            if (++i === size) return {
              done: true
            };
            var value = partitions.keys[i];
            var obj = {};
            if (value !== void 0) {
              obj[ID_KEY] = value;
            }
            each(expr, function(val, key) {
              obj[key] = accumulate(partitions.groups[i], key, val);
            });
            return {
              value: obj,
              done: false
            };
          };
        });
      }
      function $limit(collection, value, opt) {
        return collection.take(value);
      }
      function $lookup(collection, expr, opt) {
        var joinColl = expr.from;
        var localField = expr.localField;
        var foreignField = expr.foreignField;
        var asField = expr.as;
        assert(isArray(joinColl) && isString(foreignField) && isString(localField) && isString(asField), "$lookup: invalid argument");
        var hash = {};
        each(joinColl, function(obj) {
          var k = hashCode(obj[foreignField]);
          hash[k] = hash[k] || [];
          hash[k].push(obj);
        });
        return collection.map(function(obj) {
          var k = hashCode(obj[localField]);
          var newObj = clone(obj);
          newObj[asField] = hash[k] || [];
          return newObj;
        });
      }
      function $match(collection, expr, opt) {
        var q = new Query(expr);
        return collection.filter(function(o) {
          return q.test(o);
        });
      }
      function $out(collection, expr, opt) {
        assert(isArray(expr), "$out expression must be an array");
        return collection.map(function(o) {
          expr.push(o);
          return o;
        });
      }
      var projectionOperators = {
        /**
         * Projects the first element in an array that matches the query condition.
         *
         * @param obj
         * @param field
         * @param expr
         */
        $: function $(obj, expr, field) {
          err("$ not implemented");
        },
        /**
         * Projects only the first element from an array that matches the specified $elemMatch condition.
         *
         * @param obj
         * @param field
         * @param expr
         * @returns {*}
         */
        $elemMatch: function $elemMatch(obj, expr, field) {
          var arr = resolve(obj, field);
          var query = new Query(expr);
          assert(isArray(arr), "$elemMatch: invalid argument");
          for (var i = 0; i < arr.length; i++) {
            if (query.test(arr[i])) return [arr[i]];
          }
          return void 0;
        },
        /**
         * Limits the number of elements projected from an array. Supports skip and limit slices.
         *
         * @param obj
         * @param field
         * @param expr
         */
        $slice: function $slice(obj, expr, field) {
          var xs = resolve(obj, field);
          if (!isArray(xs)) return xs;
          if (isArray(expr)) {
            return slice(xs, expr[0], expr[1]);
          } else {
            assert(isNumber(expr), "$slice: invalid arguments for projection");
            return slice(xs, expr);
          }
        }
      };
      function $project(collection, expr, opt) {
        if (isEmpty(expr)) return collection;
        var objKeys = keys(expr);
        var idOnlyExcludedExpression = false;
        var ID_KEY = idKey();
        var check = [false, false];
        each(expr, function(v, k) {
          if (k === ID_KEY) return;
          if (v === 0 || v === false) {
            check[0] = true;
          } else {
            check[1] = true;
          }
          assert(check[0] !== check[1], "Projection cannot have a mix of inclusion and exclusion.");
        });
        if (inArray(objKeys, ID_KEY)) {
          var id = expr[ID_KEY];
          if (id === 0 || id === false) {
            objKeys = objKeys.filter(notInArray.bind(null, [ID_KEY]));
            assert(notInArray(objKeys, ID_KEY), "Must not contain collections id key");
            idOnlyExcludedExpression = isEmpty(objKeys);
          }
        } else {
          objKeys.push(ID_KEY);
        }
        return collection.map(function(obj) {
          var newObj = {};
          var foundSlice = false;
          var foundExclusion = false;
          var dropKeys = [];
          if (idOnlyExcludedExpression) {
            dropKeys.push(ID_KEY);
          }
          each(objKeys, function(key) {
            var subExpr = expr[key];
            var value;
            if (key !== ID_KEY && inArray([0, false], subExpr)) {
              foundExclusion = true;
            }
            if (key === ID_KEY && isEmpty(subExpr)) {
              value = obj[key];
            } else if (isString(subExpr)) {
              value = computeValue(obj, subExpr, key);
            } else if (inArray([1, true], subExpr)) ;
            else if (isObject(subExpr)) {
              var operator = keys(subExpr);
              operator = operator.length > 1 ? false : operator[0];
              if (inArray(ops(OP_PROJECTION), operator)) {
                if (operator === "$slice") {
                  if (ensureArray(subExpr[operator]).every(isNumber)) {
                    value = projectionOperators[operator](obj, subExpr[operator], key);
                    foundSlice = true;
                  } else {
                    value = computeValue(obj, subExpr, key);
                  }
                } else {
                  value = projectionOperators[operator](obj, subExpr[operator], key);
                }
              } else {
                value = computeValue(obj, subExpr, key);
              }
            } else {
              dropKeys.push(key);
              return;
            }
            var objPathValue = resolveObj(obj, key, {
              preserveMissingValues: true
            });
            if (objPathValue !== void 0) {
              merge(newObj, objPathValue, {
                flatten: true
              });
            }
            if (notInArray([0, 1, false, true], subExpr)) {
              if (value === void 0) {
                removeValue(newObj, key);
              } else {
                setValue(newObj, key, value);
              }
            }
          });
          filterMissing(newObj);
          if (foundSlice || foundExclusion || idOnlyExcludedExpression) {
            newObj = Object.assign({}, obj, newObj);
            if (dropKeys.length > 0) {
              newObj = cloneDeep(newObj);
              each(dropKeys, function(k) {
                return removeValue(newObj, k);
              });
            }
          }
          return newObj;
        });
      }
      function $redact(collection, expr, opt) {
        return collection.map(function(obj) {
          return redactObj(cloneDeep(obj), expr);
        });
      }
      function $replaceRoot(collection, expr, opt) {
        return collection.map(function(obj) {
          obj = computeValue(obj, expr.newRoot);
          assert(isObject(obj), "$replaceRoot expression must return an object");
          return obj;
        });
      }
      function $sample(collection, expr, opt) {
        var size = expr.size;
        assert(isNumber(size), "$sample size must be a positive integer");
        return collection.transform(function(xs) {
          var len = xs.length;
          var i = -1;
          return function() {
            if (++i === size) return {
              done: true
            };
            var n = Math.floor(Math.random() * len);
            return {
              value: xs[n],
              done: false
            };
          };
        });
      }
      function $skip(collection, value, opt) {
        return collection.drop(value);
      }
      function $sort(collection, sortKeys, opt) {
        if (isEmpty(sortKeys) || !isObject(sortKeys)) return collection;
        opt = opt || {};
        var cmp = compare;
        var collationSpec = opt["collation"];
        if (isObject(collationSpec) && isString(collationSpec.locale)) {
          cmp = collationComparator(collationSpec);
        }
        return collection.transform(function(coll) {
          var modifiers = keys(sortKeys);
          each(modifiers.reverse(), function(key) {
            var grouped = groupBy(coll, function(obj) {
              return resolve(obj, key);
            });
            var sortedIndex = /* @__PURE__ */ new Map();
            var indexKeys = sortBy(grouped.keys, function(k, i) {
              sortedIndex.set(k, i);
              return k;
            }, cmp);
            if (sortKeys[key] === -1) indexKeys.reverse();
            coll = [];
            each(indexKeys, function(k) {
              return into(coll, grouped.groups[sortedIndex.get(k)]);
            });
            sortedIndex.clear();
          });
          return coll;
        });
      }
      var COLLATION_STRENGTH = {
        // Only strings that differ in base letters compare as unequal. Examples: a  b, a = , a = A.
        1: "base",
        //  Only strings that differ in base letters or accents and other diacritic marks compare as unequal.
        // Examples: a  b, a  , a = A.
        2: "accent",
        // Strings that differ in base letters, accents and other diacritic marks, or case compare as unequal.
        // Other differences may also be taken into consideration. Examples: a  b, a  , a  A
        3: "variant"
        // case - Only strings that differ in base letters or case compare as unequal. Examples: a  b, a = , a  A.
      };
      function collationComparator(spec) {
        var localeOpt = {
          sensitivity: COLLATION_STRENGTH[spec.strength || 3],
          caseFirst: spec.caseFirst === "off" ? "false" : spec.caseFirst || "false",
          numeric: spec.numericOrdering || false,
          ignorePunctuation: spec.alternate === "shifted"
        };
        if ((spec.caseLevel || false) === true) {
          if (localeOpt.sensitivity === "base") localeOpt.sensitivity = "case";
          if (localeOpt.sensitivity === "accent") localeOpt.sensitivity = "variant";
        }
        var collator = new Intl.Collator(spec.locale, localeOpt);
        return function(a, b) {
          if (!isString(a) || !isString(b)) return compare(a, b);
          var i = collator.compare(a, b);
          if (i < 0) return -1;
          if (i > 0) return 1;
          return 0;
        };
      }
      function $sortByCount(collection, expr, opt) {
        var newExpr = {
          count: {
            $sum: 1
          }
        };
        newExpr[idKey()] = expr;
        return this.$sort(this.$group(collection, newExpr), {
          count: -1
        }, opt);
      }
      function $unwind(collection, expr, opt) {
        if (isString(expr)) {
          expr = {
            path: expr
          };
        }
        var field = expr.path.substr(1);
        var includeArrayIndex = expr.includeArrayIndex || false;
        var preserveNullAndEmptyArrays = expr.preserveNullAndEmptyArrays || false;
        var format = function format2(o, i) {
          if (includeArrayIndex !== false) o[includeArrayIndex] = i;
          return o;
        };
        var value;
        return Lazy(function() {
          var _loop = function _loop2() {
            if (Lazy.isIterator(value)) {
              var tmp = value.next();
              if (!tmp.done) return {
                v: tmp
              };
            }
            var obj = collection.next();
            if (obj.done) return {
              v: obj
            };
            obj = obj.value;
            value = resolve(obj, field);
            if (isArray(value)) {
              if (value.length === 0 && preserveNullAndEmptyArrays === true) {
                value = null;
                var _tmp = cloneDeep(obj);
                removeValue(_tmp, field);
                return {
                  v: {
                    value: format(_tmp, null),
                    done: false
                  }
                };
              } else {
                value = Lazy(value).map(function(item, i) {
                  var tmp2 = cloneDeep(obj);
                  setValue(tmp2, field, item);
                  return format(tmp2, i);
                });
              }
            } else if (!isEmpty(value) || preserveNullAndEmptyArrays === true) {
              var _tmp2 = cloneDeep(obj);
              return {
                v: {
                  value: format(_tmp2, null),
                  done: false
                }
              };
            }
          };
          while (true) {
            var _ret = _loop();
            if (_typeof(_ret) === "object") return _ret.v;
          }
        });
      }
      var pipelineOperators = {
        $addFields,
        $bucket,
        $bucketAuto,
        $count,
        $facet,
        $group,
        $limit,
        $lookup,
        $match,
        $out,
        $project,
        $redact,
        $replaceRoot,
        $sample,
        $set,
        $skip,
        $sort,
        $sortByCount,
        $unwind
      };
      var Aggregator = /* @__PURE__ */ function() {
        function Aggregator2(operators, options) {
          _classCallCheck(this, Aggregator2);
          this.__operators = operators;
          this.__options = options;
        }
        _createClass(Aggregator2, [{
          key: "stream",
          value: function stream(collection, query) {
            var _this = this;
            collection = Lazy(collection);
            if (!isEmpty(this.__operators)) {
              each(this.__operators, function(operator) {
                var key = keys(operator);
                assert(key.length === 1 && inArray(ops(OP_PIPELINE), key[0]), "invalid aggregation operator ".concat(key));
                key = key[0];
                if (query && query instanceof Query) {
                  collection = pipelineOperators[key].call(query, collection, operator[key], _this.__options);
                } else {
                  collection = pipelineOperators[key](collection, operator[key], _this.__options);
                }
              });
            }
            return collection;
          }
          /**
           * Return the results of the aggregation as an array.
           * @param {*} collection
           * @param {*} query
           */
        }, {
          key: "run",
          value: function run(collection, query) {
            return this.stream(collection, query).value();
          }
        }]);
        return Aggregator2;
      }();
      function aggregate(collection, pipeline, options) {
        assert(isArray(pipeline), "Aggregation pipeline must be an array");
        return new Aggregator(pipeline, options).run(collection);
      }
      var Cursor = /* @__PURE__ */ function() {
        function Cursor2(source, query, projection) {
          _classCallCheck(this, Cursor2);
          this.__filterFn = query.test.bind(query);
          this.__query = query;
          this.__source = source;
          this.__projection = projection || query.__projection;
          this.__operators = [];
          this.__result = null;
          this.__stack = [];
          this.__options = {};
        }
        _createClass(Cursor2, [{
          key: "_fetch",
          value: function _fetch() {
            if (!!this.__result) return this.__result;
            if (isObject(this.__projection)) this.__operators.push({
              "$project": this.__projection
            });
            this.__result = Lazy(this.__source).filter(this.__filterFn);
            if (this.__operators.length > 0) {
              this.__result = new Aggregator(this.__operators, this.__options).stream(this.__result, this.__query);
            }
            return this.__result;
          }
          /**
           * Return remaining objects in the cursor as an array. This method exhausts the cursor
           * @returns {Array}
           */
        }, {
          key: "all",
          value: function all() {
            return this._fetch().value();
          }
          /**
           * Returns the number of objects return in the cursor. This method exhausts the cursor
           * @returns {Number}
           */
        }, {
          key: "count",
          value: function count() {
            return this.all().length;
          }
          /**
           * Returns a cursor that begins returning results only after passing or skipping a number of documents.
           * @param {Number} n the number of results to skip.
           * @return {Cursor} Returns the cursor, so you can chain this call.
           */
        }, {
          key: "skip",
          value: function skip(n) {
            this.__operators.push({
              "$skip": n
            });
            return this;
          }
          /**
           * Constrains the size of a cursor's result set.
           * @param {Number} n the number of results to limit to.
           * @return {Cursor} Returns the cursor, so you can chain this call.
           */
        }, {
          key: "limit",
          value: function limit(n) {
            this.__operators.push({
              "$limit": n
            });
            return this;
          }
          /**
           * Returns results ordered according to a sort specification.
           * @param {Object} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending
           * @return {Cursor} Returns the cursor, so you can chain this call.
           */
        }, {
          key: "sort",
          value: function sort(modifier) {
            this.__operators.push({
              "$sort": modifier
            });
            return this;
          }
          /**
           * Specifies the collation for the cursor returned by the `mingo.Query.find`
           * @param {*} options
           */
        }, {
          key: "collation",
          value: function collation(options) {
            this.__options["collation"] = options;
            return this;
          }
          /**
           * Returns the next document in a cursor.
           * @returns {Object | Boolean}
           */
        }, {
          key: "next",
          value: function next() {
            if (!this.__stack) return;
            if (this.__stack.length > 0) return this.__stack.pop();
            var o = this._fetch().next();
            if (!o.done) return o.value;
            this.__stack = null;
            return;
          }
          /**
           * Returns true if the cursor has documents and can be iterated.
           * @returns {boolean}
           */
        }, {
          key: "hasNext",
          value: function hasNext() {
            if (!this.__stack) return false;
            if (this.__stack.length > 0) return true;
            var o = this._fetch().next();
            if (!o.done) {
              this.__stack.push(o.value);
            } else {
              this.__stack = null;
            }
            return !!this.__stack;
          }
          /**
           * Applies a function to each document in a cursor and collects the return values in an array.
           * @param callback
           * @returns {Array}
           */
        }, {
          key: "map",
          value: function map(callback) {
            return this._fetch().map(callback).value();
          }
          /**
           * Applies a JavaScript function for every document in a cursor.
           * @param callback
           */
        }, {
          key: "forEach",
          value: function forEach(callback) {
            this._fetch().each(callback);
          }
          /**
           * Applies an [ES2015 Iteration protocol][] compatible implementation
           * [ES2015 Iteration protocol]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols
           * @returns {Object}
           */
        }, {
          key: Symbol.iterator,
          value: function value() {
            return this._fetch();
          }
        }]);
        return Cursor2;
      }();
      var Query = /* @__PURE__ */ function() {
        function Query2(criteria, projection) {
          _classCallCheck(this, Query2);
          this.__criteria = criteria;
          this.__projection = projection || {};
          this.__compiled = [];
          this._compile();
        }
        _createClass(Query2, [{
          key: "_compile",
          value: function _compile() {
            var _this = this;
            assert(isObject(this.__criteria), "query criteria must be an object");
            var whereOperator;
            each(this.__criteria, function(expr, field) {
              if ("$where" === field) {
                whereOperator = {
                  field,
                  expr
                };
              } else if ("$expr" === field) {
                _this._processOperator(field, field, expr);
              } else if (inArray(["$and", "$or", "$nor"], field)) {
                _this._processOperator(field, field, expr);
              } else {
                assert(!isOperator(field), "unknown top level operator: ".concat(field));
                expr = normalize(expr);
                each(expr, function(val, op) {
                  _this._processOperator(field, op, val);
                });
              }
              if (isObject(whereOperator)) {
                _this._processOperator(whereOperator.field, whereOperator.field, whereOperator.expr);
              }
            });
          }
        }, {
          key: "_processOperator",
          value: function _processOperator(field, operator, value) {
            assert(inArray(ops(OP_QUERY), operator), "Invalid query operator '" + operator + "' detected");
            this.__compiled.push(queryOperators[operator](field, value));
          }
          /**
           * Checks if the object passes the query criteria. Returns true if so, false otherwise.
           * @param obj
           * @returns {boolean}
           */
        }, {
          key: "test",
          value: function test(obj) {
            for (var i = 0, len = this.__compiled.length; i < len; i++) {
              if (!this.__compiled[i].test(obj)) {
                return false;
              }
            }
            return true;
          }
          /**
           * Performs a query on a collection and returns a cursor object.
           * @param collection
           * @param projection
           * @returns {Cursor}
           */
        }, {
          key: "find",
          value: function find2(collection, projection) {
            return new Cursor(collection, this, projection);
          }
          /**
           * Remove matched documents from the collection returning the remainder
           * @param collection
           * @returns {Array}
           */
        }, {
          key: "remove",
          value: function remove2(collection) {
            var _this2 = this;
            return reduce(collection, function(acc, obj) {
              if (!_this2.test(obj)) acc.push(obj);
              return acc;
            }, []);
          }
        }]);
        return Query2;
      }();
      function find(collection, criteria, projection) {
        return new Query(criteria).find(collection, projection);
      }
      function remove(collection, criteria) {
        return new Query(criteria).remove(collection);
      }
      function $cmp(a, b, fn) {
        return ensureArray(a).some(function(x) {
          return getType(x) === getType(b) && fn(x, b);
        });
      }
      var simpleOperators = {
        /**
         * Checks that two values are equal.
         *
         * @param a         The lhs operand as resolved from the object by the given selector
         * @param b         The rhs operand provided by the user
         * @returns {*}
         */
        $eq: function $eq(a, b) {
          if (isEqual(a, b)) return true;
          if (isNil(a) && isNil(b)) return true;
          if (isArray(a)) {
            var eq = isEqual.bind(null, b);
            return a.some(eq) || flatten(a, 1).some(eq);
          }
          return false;
        },
        /**
         * Matches all values that are not equal to the value specified in the query.
         *
         * @param a
         * @param b
         * @returns {boolean}
         */
        $ne: function $ne(a, b) {
          return !this.$eq(a, b);
        },
        /**
         * Matches any of the values that exist in an array specified in the query.
         *
         * @param a
         * @param b
         * @returns {*}
         */
        $in: function $in(a, b) {
          if (isNil(a)) return b.some(isNull);
          return intersection(ensureArray(a), b).length > 0;
        },
        /**
         * Matches values that do not exist in an array specified to the query.
         *
         * @param a
         * @param b
         * @returns {*|boolean}
         */
        $nin: function $nin(a, b) {
          return !this.$in(a, b);
        },
        /**
         * Matches values that are less than the value specified in the query.
         *
         * @param a
         * @param b
         * @returns {boolean}
         */
        $lt: function $lt(a, b) {
          return $cmp(a, b, function(x, y) {
            return x < y;
          });
        },
        /**
         * Matches values that are less than or equal to the value specified in the query.
         *
         * @param a
         * @param b
         * @returns {boolean}
         */
        $lte: function $lte(a, b) {
          return $cmp(a, b, function(x, y) {
            return x <= y;
          });
        },
        /**
         * Matches values that are greater than the value specified in the query.
         *
         * @param a
         * @param b
         * @returns {boolean}
         */
        $gt: function $gt(a, b) {
          return $cmp(a, b, function(x, y) {
            return x > y;
          });
        },
        /**
         * Matches values that are greater than or equal to the value specified in the query.
         *
         * @param a
         * @param b
         * @returns {boolean}
         */
        $gte: function $gte(a, b) {
          return $cmp(a, b, function(x, y) {
            return x >= y;
          });
        },
        /**
         * Performs a modulo operation on the value of a field and selects documents with a specified result.
         *
         * @param a
         * @param b
         * @returns {boolean}
         */
        $mod: function $mod(a, b) {
          return ensureArray(a).some(function(x) {
            return isNumber(x) && isArray(b) && b.length === 2 && x % b[0] === b[1];
          });
        },
        /**
         * Selects documents where values match a specified regular expression.
         *
         * @param a
         * @param b
         * @returns {boolean}
         */
        $regex: function $regex(a, b) {
          a = ensureArray(a);
          var match = function match2(x) {
            return isString(x) && !!x.match(b);
          };
          return a.some(match) || flatten(a, 1).some(match);
        },
        /**
         * Matches documents that have the specified field.
         *
         * @param a
         * @param b
         * @returns {boolean}
         */
        $exists: function $exists(a, b) {
          return (b === false || b === 0) && a === void 0 || (b === true || b === 1) && a !== void 0;
        },
        /**
         * Matches arrays that contain all elements specified in the query.
         *
         * @param a
         * @param b
         * @returns boolean
         */
        $all: function $all(a, b) {
          var matched = false;
          if (isArray(a) && isArray(b)) {
            for (var i = 0, len = b.length; i < len; i++) {
              if (isObject(b[i]) && inArray(keys(b[i]), "$elemMatch")) {
                matched = matched || this.$elemMatch(a, b[i].$elemMatch);
              } else {
                return intersection(b, a).length === len;
              }
            }
          }
          return matched;
        },
        /**
         * Selects documents if the array field is a specified size.
         *
         * @param a
         * @param b
         * @returns {*|boolean}
         */
        $size: function $size(a, b) {
          return isArray(a) && isNumber(b) && a.length === b;
        },
        /**
         * Selects documents if element in the array field matches all the specified $elemMatch condition.
         *
         * @param a {Array} element to match against
         * @param b {Object} subquery
         */
        $elemMatch: function $elemMatch(a, b) {
          if (isArray(a) && !isEmpty(a)) {
            var format = function format2(x) {
              return x;
            };
            var criteria = b;
            if (keys(b).every(isOperator)) {
              criteria = {
                temp: b
              };
              format = function format2(x) {
                return {
                  temp: x
                };
              };
            }
            var query = new Query(criteria);
            for (var i = 0, len = a.length; i < len; i++) {
              if (query.test(format(a[i]))) {
                return true;
              }
            }
          }
          return false;
        },
        /**
         * Selects documents if a field is of the specified type.
         *
         * @param a
         * @param b
         * @returns {boolean}
         */
        $type: function $type(a, b) {
          switch (b) {
            case 1:
            case "double":
              return isNumber(a) && (a + "").indexOf(".") !== -1;
            case 2:
            case T_STRING:
              return isString(a);
            case 3:
            case T_OBJECT:
              return isObject(a);
            case 4:
            case T_ARRAY:
              return isArray(a);
            case 6:
            case T_UNDEFINED:
              return isNil(a);
            case 8:
            case T_BOOL:
              return isBoolean(a);
            case 9:
            case T_DATE:
              return isDate(a);
            case 10:
            case T_NULL:
              return isNull(a);
            case 11:
            case T_REGEX:
              return isRegExp(a);
            case 16:
            case "int":
              return isNumber(a) && a <= 2147483647 && (a + "").indexOf(".") === -1;
            case 18:
            case "long":
              return isNumber(a) && a > 2147483647 && a <= 9223372036854776e3 && (a + "").indexOf(".") === -1;
            case 19:
            case "decimal":
              return isNumber(a);
            default:
              return false;
          }
        }
      };
      var queryOperators = {
        /**
         * Joins query clauses with a logical AND returns all documents that match the conditions of both clauses.
         *
         * @param selector
         * @param value
         * @returns {{test: Function}}
         */
        $and: function $and(selector, value) {
          assert(isArray(value), "Invalid expression: $and expects value to be an Array");
          var queries = [];
          each(value, function(expr) {
            return queries.push(new Query(expr));
          });
          return {
            test: function test(obj) {
              for (var i = 0; i < queries.length; i++) {
                if (!queries[i].test(obj)) {
                  return false;
                }
              }
              return true;
            }
          };
        },
        /**
         * Joins query clauses with a logical OR returns all documents that match the conditions of either clause.
         *
         * @param selector
         * @param value
         * @returns {{test: Function}}
         */
        $or: function $or(selector, value) {
          assert(isArray(value), "Invalid expression. $or expects value to be an Array");
          var queries = [];
          each(value, function(expr) {
            return queries.push(new Query(expr));
          });
          return {
            test: function test(obj) {
              for (var i = 0; i < queries.length; i++) {
                if (queries[i].test(obj)) {
                  return true;
                }
              }
              return false;
            }
          };
        },
        /**
         * Joins query clauses with a logical NOR returns all documents that fail to match both clauses.
         *
         * @param selector
         * @param value
         * @returns {{test: Function}}
         */
        $nor: function $nor(selector, value) {
          assert(isArray(value), "Invalid expression. $nor expects value to be an Array");
          var query = this.$or("$or", value);
          return {
            test: function test(obj) {
              return !query.test(obj);
            }
          };
        },
        /**
         * Inverts the effect of a query expression and returns documents that do not match the query expression.
         *
         * @param selector
         * @param value
         * @returns {{test: Function}}
         */
        $not: function $not(selector, value) {
          var criteria = {};
          criteria[selector] = normalize(value);
          var query = new Query(criteria);
          return {
            test: function test(obj) {
              return !query.test(obj);
            }
          };
        },
        /**
         * Matches documents that satisfy a JavaScript expression.
         *
         * @param selector
         * @param value
         * @returns {{test: test}}
         */
        $where: function $where(selector, value) {
          if (!isFunction(value)) {
            value = new Function("return " + value + ";");
          }
          return {
            test: function test(obj) {
              return value.call(obj) === true;
            }
          };
        },
        /**
         * Allows the use of aggregation expressions within the query language.
         *
         * @param selector
         * @param value
         * @returns {{test: test}}
         */
        $expr: function $expr(selector, value) {
          return {
            test: function test(obj) {
              return computeValue(obj, value);
            }
          };
        }
      };
      each(simpleOperators, function(fn, op) {
        fn = fn.bind(simpleOperators);
        queryOperators[op] = function(selector, value) {
          return {
            test: function test(obj) {
              var lhs = resolve(obj, selector, {
                meta: true
              });
              lhs = unwrap(lhs.result, lhs.depth);
              return fn(lhs, value);
            }
          };
        };
      });
      var comparisonOperators = {
        /**
         * Compares two values and returns the result of the comparison as an integer.
         *
         * @param obj
         * @param expr
         * @returns {number}
         */
        $cmp: function $cmp2(obj, expr) {
          var args = computeValue(obj, expr);
          if (args[0] > args[1]) return 1;
          if (args[0] < args[1]) return -1;
          return 0;
        }
      };
      each(["$eq", "$ne", "$gt", "$gte", "$lt", "$lte", "$nin"], function(op) {
        comparisonOperators[op] = function(obj, expr) {
          var args = computeValue(obj, expr);
          return simpleOperators[op](args[0], args[1]);
        };
      });
      var conditionalOperators = {
        /**
         * A ternary operator that evaluates one expression,
         * and depending on the result returns the value of one following expressions.
         *
         * @param obj
         * @param expr
         */
        $cond: function $cond(obj, expr) {
          var ifExpr, thenExpr, elseExpr;
          var errorMsg = "$cond: invalid arguments";
          if (isArray(expr)) {
            assert(expr.length === 3, errorMsg);
            ifExpr = expr[0];
            thenExpr = expr[1];
            elseExpr = expr[2];
          } else {
            assert(isObject(expr), errorMsg);
            ifExpr = expr["if"];
            thenExpr = expr["then"];
            elseExpr = expr["else"];
          }
          var condition = computeValue(obj, ifExpr);
          return condition ? computeValue(obj, thenExpr) : computeValue(obj, elseExpr);
        },
        /**
         * An operator that evaluates a series of case expressions. When it finds an expression which
         * evaluates to true, it returns the resulting expression for that case. If none of the cases
         * evaluate to true, it returns the default expression.
         *
         * @param obj
         * @param expr
         */
        $switch: function $switch(obj, expr) {
          var errorMsg = "Invalid arguments for $switch operator";
          assert(expr.branches, errorMsg);
          var validBranch = expr.branches.find(function(branch) {
            assert(branch["case"] && branch["then"], errorMsg);
            return computeValue(obj, branch["case"]);
          });
          if (validBranch) {
            return computeValue(obj, validBranch.then);
          } else {
            assert(expr["default"], errorMsg);
            return computeValue(obj, expr["default"]);
          }
        },
        /**
         * Evaluates an expression and returns the first expression if it evaluates to a non-null value.
         * Otherwise, $ifNull returns the second expression's value.
         *
         * @param obj
         * @param expr
         * @returns {*}
         */
        $ifNull: function $ifNull(obj, expr) {
          assert(isArray(expr) && expr.length === 2, "$ifNull expression must resolve to array(2)");
          var args = computeValue(obj, expr);
          return isNil(args[0]) ? args[1] : args[0];
        }
      };
      var DATE_SYM_TABLE = {
        "%Y": ["$year", 4],
        "%m": ["$month", 2],
        "%d": ["$dayOfMonth", 2],
        "%H": ["$hour", 2],
        "%M": ["$minute", 2],
        "%S": ["$second", 2],
        "%L": ["$millisecond", 3],
        "%j": ["$dayOfYear", 3],
        "%w": ["$dayOfWeek", 1],
        "%U": ["$week", 2],
        "%%": "%"
      };
      var dateOperators = {
        /**
         * Returns the day of the year for a date as a number between 1 and 366 (leap year).
         * @param obj
         * @param expr
         */
        $dayOfYear: function $dayOfYear(obj, expr) {
          var d = computeValue(obj, expr);
          var start = new Date(d.getFullYear(), 0, 0);
          var diff = d - start;
          var oneDay = 1e3 * 60 * 60 * 24;
          return Math.round(diff / oneDay);
        },
        /**
         * Returns the day of the month for a date as a number between 1 and 31.
         * @param obj
         * @param expr
         */
        $dayOfMonth: function $dayOfMonth(obj, expr) {
          var d = computeValue(obj, expr);
          return d.getDate();
        },
        /**
         * Returns the day of the week for a date as a number between 1 (Sunday) and 7 (Saturday).
         * @param obj
         * @param expr
         */
        $dayOfWeek: function $dayOfWeek(obj, expr) {
          var d = computeValue(obj, expr);
          return d.getDay() + 1;
        },
        /**
         * Returns the year for a date as a number (e.g. 2014).
         * @param obj
         * @param expr
         */
        $year: function $year(obj, expr) {
          var d = computeValue(obj, expr);
          return d.getFullYear();
        },
        /**
         * Returns the month for a date as a number between 1 (January) and 12 (December).
         * @param obj
         * @param expr
         */
        $month: function $month(obj, expr) {
          var d = computeValue(obj, expr);
          return d.getMonth() + 1;
        },
        /**
         * Returns the week number for a date as a number between 0
         * (the partial week that precedes the first Sunday of the year) and 53 (leap year).
         * @param obj
         * @param expr
         */
        $week: function $week(obj, expr) {
          var d = computeValue(obj, expr);
          d = /* @__PURE__ */ new Date(+d);
          d.setHours(0, 0, 0);
          d.setDate(d.getDate() + 4 - (d.getDay() || 7));
          var yearStart = new Date(d.getFullYear(), 0, 1);
          return Math.floor(((d - yearStart) / 864e5 + 1) / 7);
        },
        /**
         * Returns the hour for a date as a number between 0 and 23.
         * @param obj
         * @param expr
         */
        $hour: function $hour(obj, expr) {
          var d = computeValue(obj, expr);
          return d.getUTCHours();
        },
        /**
         * Returns the minute for a date as a number between 0 and 59.
         * @param obj
         * @param expr
         */
        $minute: function $minute(obj, expr) {
          var d = computeValue(obj, expr);
          return d.getMinutes();
        },
        /**
         * Returns the seconds for a date as a number between 0 and 60 (leap seconds).
         * @param obj
         * @param expr
         */
        $second: function $second(obj, expr) {
          var d = computeValue(obj, expr);
          return d.getSeconds();
        },
        /**
         * Returns the milliseconds of a date as a number between 0 and 999.
         * @param obj
         * @param expr
         */
        $millisecond: function $millisecond(obj, expr) {
          var d = computeValue(obj, expr);
          return d.getMilliseconds();
        },
        /**
         * Returns the date as a formatted string.
         *
         * %Y  Year (4 digits, zero padded)  0000-9999
         * %m  Month (2 digits, zero padded)  01-12
         * %d  Day of Month (2 digits, zero padded)  01-31
         * %H  Hour (2 digits, zero padded, 24-hour clock)  00-23
         * %M  Minute (2 digits, zero padded)  00-59
         * %S  Second (2 digits, zero padded)  00-60
         * %L  Millisecond (3 digits, zero padded)  000-999
         * %j  Day of year (3 digits, zero padded)  001-366
         * %w  Day of week (1-Sunday, 7-Saturday)  1-7
         * %U  Week of year (2 digits, zero padded)  00-53
         * %%  Percent Character as a Literal  %
         *
         * @param obj current object
         * @param expr operator expression
         */
        $dateToString: function $dateToString(obj, expr) {
          var fmt = expr["format"];
          var date = computeValue(obj, expr["date"]);
          var matches = fmt.match(/(%%|%Y|%m|%d|%H|%M|%S|%L|%j|%w|%U)/g);
          for (var i = 0, len = matches.length; i < len; i++) {
            var hdlr = DATE_SYM_TABLE[matches[i]];
            var value = hdlr;
            if (isArray(hdlr)) {
              var fn = this[hdlr[0]].bind(this);
              var pad = hdlr[1];
              value = padDigits(fn(obj, date), pad);
            }
            fmt = fmt.replace(matches[i], value);
          }
          return fmt;
        }
      };
      function padDigits(number, digits) {
        return new Array(Math.max(digits - String(number).length + 1, 0)).join("0") + number;
      }
      var literalOperators = {
        /**
         * Return a value without parsing.
         * @param obj
         * @param expr
         */
        $literal: function $literal(obj, expr) {
          return expr;
        }
      };
      var setOperators = {
        /**
         * Returns true if two sets have the same elements.
         * @param obj
         * @param expr
         */
        $setEquals: function $setEquals(obj, expr) {
          var args = computeValue(obj, expr);
          var xs = unique(args[0]);
          var ys = unique(args[1]);
          return xs.length === ys.length && xs.length === intersection(xs, ys).length;
        },
        /**
         * Returns the common elements of the input sets.
         * @param obj
         * @param expr
         */
        $setIntersection: function $setIntersection(obj, expr) {
          var args = computeValue(obj, expr);
          return intersection(args[0], args[1]);
        },
        /**
         * Returns elements of a set that do not appear in a second set.
         * @param obj
         * @param expr
         */
        $setDifference: function $setDifference(obj, expr) {
          var args = computeValue(obj, expr);
          return args[0].filter(notInArray.bind(null, args[1]));
        },
        /**
         * Returns a set that holds all elements of the input sets.
         * @param obj
         * @param expr
         */
        $setUnion: function $setUnion(obj, expr) {
          var args = computeValue(obj, expr);
          return union(args[0], args[1]);
        },
        /**
         * Returns true if all elements of a set appear in a second set.
         * @param obj
         * @param expr
         */
        $setIsSubset: function $setIsSubset(obj, expr) {
          var args = computeValue(obj, expr);
          return intersection(args[0], args[1]).length === args[0].length;
        },
        /**
         * Returns true if any elements of a set evaluate to true, and false otherwise.
         * @param obj
         * @param expr
         */
        $anyElementTrue: function $anyElementTrue(obj, expr) {
          var args = computeValue(obj, expr)[0];
          return args.some(truthy);
        },
        /**
         * Returns true if all elements of a set evaluate to true, and false otherwise.
         * @param obj
         * @param expr
         */
        $allElementsTrue: function $allElementsTrue(obj, expr) {
          var args = computeValue(obj, expr)[0];
          return args.every(truthy);
        }
      };
      var stringOperators = {
        /**
         * Concatenates two strings.
         *
         * @param obj
         * @param expr
         * @returns {string|*}
         */
        $concat: function $concat(obj, expr) {
          var args = computeValue(obj, expr);
          if ([null, void 0].some(inArray.bind(null, args))) return null;
          return args.join("");
        },
        /**
         * Searches a string for an occurrence of a substring and returns the UTF-8 code point index of the first occurence.
         * If the substring is not found, returns -1.
         *
         * @param  {Object} obj
         * @param  {*} expr
         * @return {*}
         */
        $indexOfBytes: function $indexOfBytes(obj, expr) {
          var arr = computeValue(obj, expr);
          var errorMsg = "$indexOfBytes expression resolves to invalid an argument";
          if (isNil(arr[0])) return null;
          assert(isString(arr[0]) && isString(arr[1]), errorMsg);
          var str = arr[0];
          var searchStr = arr[1];
          var start = arr[2];
          var end = arr[3];
          var valid = isNil(start) || isNumber(start) && start >= 0 && Math.round(start) === start;
          valid = valid && (isNil(end) || isNumber(end) && end >= 0 && Math.round(end) === end);
          assert(valid, errorMsg);
          start = start || 0;
          end = end || str.length;
          if (start > end) return -1;
          var index2 = str.substring(start, end).indexOf(searchStr);
          return index2 > -1 ? index2 + start : index2;
        },
        /**
         * Splits a string into substrings based on a delimiter.
         * If the delimiter is not found within the string, returns an array containing the original string.
         *
         * @param  {Object} obj
         * @param  {Array} expr
         * @return {Array} Returns an array of substrings.
         */
        $split: function $split(obj, expr) {
          var args = computeValue(obj, expr);
          if (isNil(args[0])) return null;
          assert(args.every(isString), "$split expression must result to array(2) of strings");
          return args[0].split(args[1]);
        },
        /**
         * Returns the number of UTF-8 encoded bytes in the specified string.
         *
         * @param  {Object} obj
         * @param  {String} expr
         * @return {Number}
         */
        $strLenBytes: function $strLenBytes(obj, expr) {
          return ~-encodeURI(computeValue(obj, expr)).split(/%..|./).length;
        },
        /**
         * Returns the number of UTF-8 code points in the specified string.
         *
         * @param  {Object} obj
         * @param  {String} expr
         * @return {Number}
         */
        $strLenCP: function $strLenCP(obj, expr) {
          return computeValue(obj, expr).length;
        },
        /**
         * Compares two strings and returns an integer that reflects the comparison.
         *
         * @param obj
         * @param expr
         * @returns {number}
         */
        $strcasecmp: function $strcasecmp(obj, expr) {
          var args = computeValue(obj, expr);
          var a = args[0];
          var b = args[1];
          if (isEqual(a, b) || args.every(isNil)) return 0;
          assert(args.every(isString), "$strcasecmp must resolve to array(2) of strings");
          a = a.toUpperCase();
          b = b.toUpperCase();
          return a > b && 1 || a < b && -1 || 0;
        },
        /**
         * Returns a substring of a string, starting at a specified index position and including the specified number of characters.
         * The index is zero-based.
         *
         * @param obj
         * @param expr
         * @returns {string}
         */
        $substrBytes: function $substrBytes(obj, expr) {
          var args = computeValue(obj, expr);
          var s = args[0];
          var index2 = args[1];
          var count = args[2];
          assert(isString(s) && isNumber(index2) && index2 >= 0 && isNumber(count) && count >= 0, "$substrBytes: invalid arguments");
          var buf = utf8Encode(s);
          var validIndex = [];
          var acc = 0;
          for (var i = 0; i < buf.length; i++) {
            validIndex.push(acc);
            acc += buf[i].length;
          }
          var begin = validIndex.indexOf(index2);
          var end = validIndex.indexOf(index2 + count);
          assert(begin > -1 && end > -1, "$substrBytes: invalid range, start or end index is a UTF-8 continuation byte.");
          return s.substring(begin, end);
        },
        /**
         * Returns a substring of a string, starting at a specified index position and including the specified number of characters.
         * The index is zero-based.
         *
         * @param obj
         * @param expr
         * @returns {string}
         */
        $substr: function $substr(obj, expr) {
          var args = computeValue(obj, expr);
          var s = args[0];
          var index2 = args[1];
          var count = args[2];
          if (isString(s)) {
            if (index2 < 0) {
              return "";
            } else if (count < 0) {
              return s.substr(index2);
            } else {
              return s.substr(index2, count);
            }
          }
          return "";
        },
        $substrCP: function $substrCP(obj, expr) {
          return this.$substr(obj, expr);
        },
        /**
         * Converts a string to lowercase.
         *
         * @param obj
         * @param expr
         * @returns {string}
         */
        $toLower: function $toLower(obj, expr) {
          var value = computeValue(obj, expr);
          return isEmpty(value) ? "" : value.toLowerCase();
        },
        /**
         * Converts a string to uppercase.
         *
         * @param obj
         * @param expr
         * @returns {string}
         */
        $toUpper: function $toUpper(obj, expr) {
          var value = computeValue(obj, expr);
          return isEmpty(value) ? "" : value.toUpperCase();
        }
      };
      var UTF8_MASK = [192, 224, 240];
      function toUtf8(n) {
        if (n < 128) return [n];
        var count = n < 2048 && 1 || n < 65536 && 2 || 3;
        var offset = UTF8_MASK[count - 1];
        var utf8 = [(n >> 6 * count) + offset];
        while (count > 0) {
          utf8.push(128 | n >> 6 * --count & 63);
        }
        return utf8;
      }
      function utf8Encode(s) {
        var buf = [];
        for (var i = 0, len = s.length; i < len; i++) {
          buf.push(toUtf8(s.codePointAt(i)));
        }
        return buf;
      }
      var variableOperators = {
        /**
         * Defines variables for use within the scope of a sub-expression and returns the result of the sub-expression.
         *
         * @param obj
         * @param expr
         * @returns {*}
         */
        $let: function $let(obj, expr) {
          var varsExpr = expr["vars"];
          var inExpr = expr["in"];
          var varsKeys = keys(varsExpr);
          each(varsKeys, function(key) {
            var val = computeValue(obj, varsExpr[key]);
            var tempKey = "$" + key;
            obj[tempKey] = val;
          });
          return computeValue(obj, inExpr);
        }
      };
      var expressionOperators = Object.assign({}, arithmeticOperators, arrayOperators, booleanOperators, comparisonOperators, conditionalOperators, dateOperators, literalOperators, setOperators, stringOperators, variableOperators);
      function $addToSet(collection, expr) {
        return unique(this.$push(collection, expr));
      }
      function $avg(collection, expr) {
        var data = this.$push(collection, expr).filter(isNumber);
        var sum = reduce(data, function(acc, n) {
          return acc + n;
        }, 0);
        return sum / (data.length || 1);
      }
      function $first(collection, expr) {
        return collection.length > 0 ? computeValue(collection[0], expr) : void 0;
      }
      function $last(collection, expr) {
        return collection.length > 0 ? computeValue(collection[collection.length - 1], expr) : void 0;
      }
      function $max(collection, expr) {
        return reduce(this.$push(collection, expr), function(acc, n) {
          return isNil(acc) || n > acc ? n : acc;
        }, void 0);
      }
      function $mergeObjects(collection, expr) {
        return reduce(collection, function(memo, o) {
          return Object.assign(memo, computeValue(o, expr));
        }, {});
      }
      function $min(collection, expr) {
        return reduce(this.$push(collection, expr), function(acc, n) {
          return isNil(acc) || n < acc ? n : acc;
        }, void 0);
      }
      function $push(collection, expr) {
        if (isNil(expr)) return collection;
        return collection.map(function(obj) {
          return computeValue(obj, expr);
        });
      }
      function $stdDevPop(collection, expr) {
        return stddev({
          data: this.$push(collection, expr).filter(isNumber),
          sampled: false
        });
      }
      function $stdDevSamp(collection, expr) {
        return stddev({
          data: this.$push(collection, expr).filter(isNumber),
          sampled: true
        });
      }
      function $sum(collection, expr) {
        if (!isArray(collection)) return 0;
        if (isNumber(expr)) return collection.length * expr;
        return reduce(this.$push(collection, expr).filter(isNumber), function(acc, n) {
          return acc + n;
        }, 0);
      }
      var groupOperators = {
        $addToSet,
        $avg,
        $first,
        $last,
        $mergeObjects,
        $max,
        $min,
        $push,
        $stdDevPop,
        $stdDevSamp,
        $sum
      };
      var OPERATORS = {
        "expression": expressionOperators,
        "group": groupOperators,
        "pipeline": pipelineOperators,
        "projection": projectionOperators,
        "query": queryOperators
      };
      function ops() {
        var args = Array.prototype.slice.call(arguments);
        return reduce(args, function(acc, cls) {
          return into(acc, keys(OPERATORS[cls]));
        }, []);
      }
      function addOperators(opClass, fn) {
        var newOperators = fn(_internal());
        assert(has(OPERATORS, opClass), "Invalid operator class ".concat(opClass));
        var operators = OPERATORS[opClass];
        each(newOperators, function(fn2, op) {
          assert(/^\$\w+$/.test(op), "Invalid operator name ".concat(op));
          assert(!has(operators, op), "".concat(op, " already exists for '").concat(opClass, "' operators"));
        });
        var wrapped = {};
        switch (opClass) {
          case OP_QUERY:
            each(newOperators, function(fn2, op) {
              fn2 = fn2.bind(newOperators);
              wrapped[op] = function(selector, value) {
                return {
                  test: function test(obj) {
                    var lhs = resolve(obj, selector);
                    var result = fn2(selector, lhs, value);
                    assert(isBoolean(result), "".concat(op, " must return a boolean"));
                    return result;
                  }
                };
              };
            });
            break;
          case OP_PROJECTION:
            each(newOperators, function(fn2, op) {
              fn2 = fn2.bind(newOperators);
              wrapped[op] = function(obj, expr, selector) {
                var lhs = resolve(obj, selector);
                return fn2(selector, lhs, expr);
              };
            });
            break;
          default:
            each(newOperators, function(fn2, op) {
              wrapped[op] = function() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                return fn2.apply(newOperators, args);
              };
            });
        }
        Object.assign(OPERATORS[opClass], wrapped);
      }
      var settings = {
        key: "_id"
      };
      function setup(options) {
        Object.assign(settings, options || {});
      }
      var systemVariables = {
        "$$ROOT": function $$ROOT(obj, expr, opt) {
          return opt.root;
        },
        "$$CURRENT": function $$CURRENT(obj, expr, opt) {
          return obj;
        },
        "$$REMOVE": function $$REMOVE(obj, expr, opt) {
          return void 0;
        }
      };
      var redactVariables = {
        "$$KEEP": function $$KEEP(obj) {
          return obj;
        },
        "$$PRUNE": function $$PRUNE() {
          return void 0;
        },
        "$$DESCEND": function $$DESCEND(obj, expr, opt) {
          if (!has(expr, "$cond")) return obj;
          var result;
          each(obj, function(current, key) {
            if (isObjectLike(current)) {
              if (isArray(current)) {
                result = [];
                each(current, function(elem) {
                  if (isObject(elem)) {
                    elem = redactObj(elem, expr, opt);
                  }
                  if (!isNil(elem)) result.push(elem);
                });
              } else {
                result = redactObj(current, expr, opt);
              }
              if (isNil(result)) {
                delete obj[key];
              } else {
                obj[key] = result;
              }
            }
          });
          return obj;
        }
      };
      var SYS_VARS = keys(systemVariables);
      var REDACT_VARS = keys(redactVariables);
      function idKey() {
        return settings.key;
      }
      function getValue(obj, field) {
        return isObjectLike(obj) ? obj[field] : void 0;
      }
      function accumulate(collection, field, expr) {
        if (inArray(ops(OP_GROUP), field)) {
          return groupOperators[field](collection, expr);
        }
        if (isObject(expr)) {
          var result = {};
          each(expr, function(val, key) {
            result[key] = accumulate(collection, key, expr[key]);
            if (inArray(ops(OP_GROUP), key)) {
              result = result[key];
              assert(keys(expr).length === 1, "Invalid $group expression '" + JSON.stringify(expr) + "'");
              return false;
            }
          });
          return result;
        }
      }
      function resolve(obj, selector) {
        var opt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var depth = 0;
        opt.meta = opt.meta || false;
        function resolve2(o, path) {
          var value = o;
          for (var i = 0; i < path.length; i++) {
            var field = path[i];
            var isText = field.match(/^\d+$/) === null;
            if (isText && isArray(value)) {
              if (i === 0 && depth > 0) break;
              depth += 1;
              path = path.slice(i);
              value = reduce(value, function(acc, item) {
                var v = resolve2(item, path);
                if (v !== void 0) acc.push(v);
                return acc;
              }, []);
              break;
            } else {
              value = getValue(value, field);
            }
            if (value === void 0) break;
          }
          return value;
        }
        obj = inArray(JS_SIMPLE_TYPES, jsType(obj)) ? obj : resolve2(obj, selector.split("."));
        return opt.meta ? {
          result: obj,
          depth
        } : obj;
      }
      function resolveObj(obj, selector) {
        var opt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        opt.preserveMissingValues = opt.preserveMissingValues || false;
        var names = selector.split(".");
        var key = names[0];
        var next = names.length === 1 || names.slice(1).join(".");
        var isIndex = key.match(/^\d+$/) !== null;
        var hasNext = names.length > 1;
        var result;
        var value;
        try {
          if (isArray(obj)) {
            if (isIndex) {
              result = getValue(obj, Number(key));
              if (hasNext) {
                result = resolveObj(result, next, opt);
              }
              result = [result];
            } else {
              result = [];
              each(obj, function(item) {
                value = resolveObj(item, selector, opt);
                if (opt.preserveMissingValues) {
                  if (value === void 0) {
                    value = MISSING;
                  }
                  result.push(value);
                } else if (value !== void 0) {
                  result.push(value);
                }
              });
            }
          } else {
            value = getValue(obj, key);
            if (hasNext) {
              value = resolveObj(value, next, opt);
            }
            assert(value !== void 0);
            result = {};
            result[key] = value;
          }
        } catch (e) {
          result = void 0;
        }
        return result;
      }
      function filterMissing(obj) {
        if (isArray(obj)) {
          for (var i = obj.length - 1; i >= 0; i--) {
            if (obj[i] === MISSING) {
              obj.splice(i, 1);
            } else {
              filterMissing(obj[i]);
            }
          }
        } else if (isObject(obj)) {
          for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
              filterMissing(obj[k]);
            }
          }
        }
        return obj;
      }
      function traverse(obj, selector, fn) {
        var force = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
        var names = selector.split(".");
        var key = names[0];
        var next = names.length === 1 || names.slice(1).join(".");
        if (names.length === 1) {
          fn(obj, key);
        } else {
          if (force === true && isNil(obj[key])) {
            obj[key] = {};
          }
          traverse(obj[key], next, fn, force);
        }
      }
      function setValue(obj, selector, value) {
        traverse(obj, selector, function(item, key) {
          item[key] = value;
        }, true);
      }
      function removeValue(obj, selector) {
        traverse(obj, selector, function(item, key) {
          if (isArray(item) && /^\d+$/.test(key)) {
            item.splice(parseInt(key), 1);
          } else if (isObject(item)) {
            delete item[key];
          }
        });
      }
      function isOperator(name) {
        return !!name && name[0] === "$";
      }
      function normalize(expr) {
        if (inArray(JS_SIMPLE_TYPES, jsType(expr))) {
          return isRegExp(expr) ? {
            "$regex": expr
          } : {
            "$eq": expr
          };
        }
        if (isObjectLike(expr)) {
          var exprKeys = keys(expr);
          if (!exprKeys.some(isOperator)) {
            return {
              "$eq": expr
            };
          }
          if (inArray(exprKeys, "$regex")) {
            var regex = expr["$regex"];
            var options = expr["$options"] || "";
            var modifiers = "";
            if (isString(regex)) {
              modifiers += regex.ignoreCase || options.indexOf("i") >= 0 ? "i" : "";
              modifiers += regex.multiline || options.indexOf("m") >= 0 ? "m" : "";
              modifiers += regex.global || options.indexOf("g") >= 0 ? "g" : "";
              regex = new RegExp(regex, modifiers);
            }
            expr["$regex"] = regex;
            delete expr["$options"];
          }
        }
        return expr;
      }
      function computeValue(obj, expr) {
        var operator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        var opt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        opt.root = opt.root || obj;
        if (inArray(ops(OP_EXPRESSION), operator)) {
          return expressionOperators[operator](obj, expr, opt);
        }
        if (inArray(ops(OP_GROUP), operator)) {
          obj = computeValue(obj, expr, null, opt);
          assert(isArray(obj), operator + " expression must resolve to an array");
          return groupOperators[operator](obj, null, opt);
        }
        if (isString(expr) && expr.length > 0 && expr[0] === "$") {
          if (inArray(SYS_VARS, expr)) {
            return systemVariables[expr](obj, null, opt);
          } else if (inArray(REDACT_VARS, expr)) {
            return expr;
          }
          var sysVar = SYS_VARS.filter(function(v) {
            return expr.indexOf(v + ".") === 0;
          });
          if (sysVar.length === 1) {
            sysVar = sysVar[0];
            if (sysVar === "$$ROOT") {
              obj = opt.root;
            }
            expr = expr.substr(sysVar.length);
          }
          return resolve(obj, expr.slice(1));
        }
        switch (jsType(expr)) {
          case T_ARRAY:
            return expr.map(function(item) {
              return computeValue(obj, item);
            });
          case T_OBJECT:
            var result = {};
            each(expr, function(val, key) {
              result[key] = computeValue(obj, val, key, opt);
              if (inArray(ops(OP_EXPRESSION, OP_GROUP), key)) {
                assert(keys(expr).length === 1, "Invalid aggregation expression '" + JSON.stringify(expr) + "'");
                result = result[key];
                return false;
              }
            });
            return result;
          default:
            return expr;
        }
      }
      function slice(xs, skip) {
        var limit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        if (isNil(limit)) {
          if (skip < 0) {
            skip = Math.max(0, xs.length + skip);
            limit = xs.length - skip + 1;
          } else {
            limit = skip;
            skip = 0;
          }
        } else {
          if (skip < 0) {
            skip = Math.max(0, xs.length + skip);
          }
          assert(limit > 0, "Invalid argument value for $slice operator. Limit must be a positive number");
          limit += skip;
        }
        return xs.slice(skip, limit);
      }
      function stddev(ctx) {
        var sum = reduce(ctx.data, function(acc, n) {
          return acc + n;
        }, 0);
        var N = ctx.data.length || 1;
        var correction = ctx.sampled && 1 || 0;
        var avg = sum / N;
        return Math.sqrt(reduce(ctx.data, function(acc, n) {
          return acc + Math.pow(n - avg, 2);
        }, 0) / (N - correction));
      }
      function redactObj(obj, expr) {
        var opt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        opt.root = opt.root || obj;
        var result = computeValue(obj, expr, null, opt);
        return inArray(REDACT_VARS, result) ? redactVariables[result](obj, expr, opt) : result;
      }
      function _internal() {
        return {
          assert,
          computeValue,
          clone,
          cloneDeep,
          each,
          err,
          hashCode,
          getType,
          has,
          idKey,
          includes: inArray.bind(null),
          isArray,
          isBoolean,
          isDate,
          isEmpty,
          isEqual,
          isFunction,
          isNil,
          isNull,
          isNumber,
          isObject,
          isRegExp,
          isString,
          isUndefined,
          keys,
          ops,
          resolve,
          resolveObj,
          reduce
        };
      }
      var CollectionMixin = {
        /**
         * Runs a query and returns a cursor to the result
         * @param criteria
         * @param projection
         * @returns {Cursor}
         */
        query: function query(criteria, projection) {
          return new Query(criteria).find(this.toJSON(), projection);
        },
        /**
         * Runs the given aggregation operators on this collection
         * @params pipeline
         * @returns {Array}
         */
        aggregate: function aggregate2(pipeline) {
          return new Aggregator(pipeline).run(this.toJSON());
        }
      };
      var VERSION = "2.4.0";
      var index = {
        _internal,
        Aggregator,
        CollectionMixin,
        Cursor,
        Lazy,
        OP_EXPRESSION,
        OP_GROUP,
        OP_PIPELINE,
        OP_PROJECTION,
        OP_QUERY,
        Query,
        VERSION,
        addOperators,
        aggregate,
        find,
        remove,
        setup
      };
      return index;
    });
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/store/transaction.js
var require_transaction = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/store/transaction.js"(exports2, module2) {
    var extend = require_node_extend_without();
    module2.exports = ({ queue }) => {
      let commitedDocuments = {};
      return {
        getCurrentDocuments(opts = {}) {
          return opts.transaction == null ? commitedDocuments : opts.transaction.documents;
        },
        begin() {
          return queue.push(async () => {
            return {
              documents: cloneDocuments(commitedDocuments),
              operations: [],
              beginTime: Date.now()
            };
          });
        },
        async operation(opts, fn) {
          if (fn == null) {
            fn = opts;
          }
          if (opts.transaction) {
            return queue.push(() => {
              opts.transaction.operations.push(fn);
              return fn(opts.transaction.documents);
            });
          }
          return queue.push(() => fn(commitedDocuments));
        },
        async commit(transaction) {
          return queue.push(async () => {
            const documentsClone = cloneDocuments(commitedDocuments);
            for (const op of transaction.operations) {
              await op(documentsClone);
            }
            for (const entitySet in documentsClone) {
              for (const transactionEntity of documentsClone[entitySet]) {
                const commitedEntity = commitedDocuments[entitySet].find((e) => e._id);
                if (commitedEntity && transactionEntity.$$etag !== commitedEntity.$$etag && commitedEntity.$$etag > transaction.beginTime) {
                  throw new Error(`Entity ${transactionEntity.name} was modified by another transaction`);
                }
              }
            }
            commitedDocuments = documentsClone;
          });
        },
        async rollback(transaction) {
        }
      };
    };
    function cloneDocuments(obj) {
      return Object.keys(obj).reduce((acu, setName) => {
        acu[setName] = obj[setName].map((doc) => extend(true, {}, doc));
        return acu;
      }, {});
    }
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/store/queue.js
var require_queue = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/store/queue.js"(exports2, module2) {
    module2.exports = () => {
      const items = [];
      let busy = false;
      function execute() {
        if (items.length < 1 || busy) {
          return;
        }
        busy = true;
        const item = items.shift();
        item.busy = true;
        Promise.resolve(item.fn()).then((res) => {
          item.resolve(res);
          busy = false;
          execute();
          return null;
        }).catch((err) => {
          item.reject(err);
          busy = false;
          execute();
          return null;
        });
      }
      return {
        push(fn) {
          let _resolve, _reject;
          const result = new Promise((resolve, reject) => {
            _resolve = resolve;
            _reject = reject;
          });
          items.push({
            fn,
            resolve: _resolve,
            reject: _reject,
            submittedOn: (/* @__PURE__ */ new Date()).getTime()
          });
          execute();
          return result;
        }
      };
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/store/memoryStoreProvider.js
var require_memoryStoreProvider = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/store/memoryStoreProvider.js"(exports2, module2) {
    var extend = require_node_extend_without();
    var { nanoid } = require_nanoid();
    var omit = require_lodash();
    var mingo = require_mingo();
    var Transaction = require_transaction();
    var Queue = require_queue();
    module2.exports = () => {
      return {
        load(model) {
          this.model = model;
          this.transaction = Transaction({ queue: Queue() });
          return this.transaction.operation(async (documents) => {
            Object.keys(model.entitySets).forEach((e) => documents[e] = []);
          });
        },
        beginTransaction() {
          return this.transaction.begin();
        },
        async commitTransaction(tran) {
          await this.transaction.commit(tran);
        },
        async rollbackTransaction(tran) {
          return this.transaction.rollback(tran);
        },
        find(entitySet, query, fields, opts = {}) {
          const documents = this.transaction.getCurrentDocuments(opts);
          const cursor = mingo.find(documents[entitySet], query, fields);
          cursor.toArray = () => cursor.all().map((e) => extend(true, {}, omit(e, "$$etag")));
          return cursor;
        },
        insert(entitySet, doc, opts = {}) {
          doc._id = doc._id || nanoid(16);
          const clonnedDoc = extend(true, {}, doc);
          clonnedDoc.$$etag = Date.now();
          return this.transaction.operation(opts, async (documents) => {
            documents[entitySet].push(clonnedDoc);
            return doc;
          });
        },
        async update(entitySet, q, u, opts = {}) {
          let count;
          const qClone = extend(true, {}, q);
          const setClone = extend(true, {}, u.$set);
          const res = await this.transaction.operation(opts, async (documents) => {
            const toUpdate = mingo.find(documents[entitySet], qClone).all();
            count = toUpdate.length;
            if (toUpdate.length === 0 && opts.upsert) {
              return "insert";
            }
            for (const doc of toUpdate) {
              Object.assign(doc, setClone);
              doc.$$etag = Date.now();
            }
          });
          if (res === "insert") {
            await this.insert(entitySet, setClone, opts);
            return 1;
          }
          return count;
        },
        remove(entitySet, q, opts = {}) {
          const qClone = extend(true, {}, q);
          return this.transaction.operation(opts, async (documents) => {
            const toRemove = mingo.find(documents[entitySet], qClone).all();
            documents[entitySet] = documents[entitySet].filter((d) => !toRemove.includes(d));
          });
        },
        drop(opts = {}) {
          return this.transaction.operation(opts, async (documents) => {
            for (const [entitySetName] of Object.entries(documents)) {
              documents[entitySetName] = [];
            }
          });
        }
      };
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/store/documentStore.js
var require_documentStore = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/store/documentStore.js"(exports2, module2) {
    var events = require("events");
    var { nanoid } = require_nanoid();
    var { v4: uuidv4 } = (init_esm_node(), __toCommonJS(esm_node_exports));
    var createListenerCollection = require_listenerCollection();
    var { resolvePropDefinition, typeDefToJSONSchema } = require_typeUtils();
    var { findReferencePropertiesInType, findLinkedEntitiesForReferenceValue, existsReferenceValue, updateReferenceValue } = require_referenceUtils();
    var collection = require_collection();
    var checkDuplicatedId = require_checkDuplicatedId();
    var DocumentStore = (options, validator, encryption) => {
      const entitySchemasToGenerate = [];
      const generateSchemaEntityTypeConfig = {};
      const defaultGenerateSchemaForEntityType = true;
      const internalEntitySets = {};
      const transactions = /* @__PURE__ */ new Map();
      const fileExtensionResolvers = [];
      transactions.getActiveTransaction = function(req) {
        if (req && req.context && req.context.storeTransaction) {
          if (!transactions.has(req.context.storeTransaction)) {
            throw new Error("transaction does not exists or is no longer active, make sure you are not closing the transaction previously using store.commitTransaction or store.rollbackTransaction");
          }
          return transactions.get(req.context.storeTransaction);
        }
      };
      let initialized = false;
      const store = {
        options,
        model: {
          namespace: "jsreport",
          complexTypes: {},
          entitySets: {}
        },
        internalAfterInitListeners: createListenerCollection("DocumentStore@internalAfterInit"),
        emitter: new events.EventEmitter(),
        registerProvider(provider) {
          this.provider = provider;
        },
        async init() {
          initialized = true;
          if (!this.provider && this.options.store.provider === "memory") {
            this.provider = require_memoryStoreProvider()();
          }
          if (!this.provider) {
            throw new Error(`The document store provider ${this.options.store.provider} was not registered.`);
          }
          this.emit("before-init", this);
          this.collections = {};
          this.internalCollections = {};
          const entitySetsLinkedReferenceProperties = {};
          Object.entries(this.model.entitySets).forEach((e) => {
            const eName = e[0];
            const es = e[1];
            es.normalizedEntityTypeName = es.entityType.replace(this.model.namespace + ".", "");
            es.entityTypeDef = this.model.entityTypes[es.normalizedEntityTypeName];
            const entityType = es.entityTypeDef;
            if (!entityType._id) {
              entityType._id = { type: "Edm.String" };
              if (!entityTypeHasKey(entityType)) {
                entityType._id.key = true;
              }
            }
            if (!entityType.creationDate) {
              entityType.creationDate = { type: "Edm.DateTimeOffset" };
            }
            if (!entityType.modificationDate) {
              entityType.modificationDate = { type: "Edm.DateTimeOffset" };
            }
            if (!entityType.shortid) {
              entityType.shortid = { type: "Edm.String" };
            }
            const referenceProperties = findReferencePropertiesInType(this.model, entityType);
            referenceProperties.forEach((property) => {
              const entitySetName = property.referenceTo;
              entitySetsLinkedReferenceProperties[entitySetName] = entitySetsLinkedReferenceProperties[entitySetName] || [];
              entitySetsLinkedReferenceProperties[entitySetName].push({
                name: property.name,
                entitySet: eName
              });
            });
            es.referenceProperties = referenceProperties;
          });
          Object.keys(this.model.entitySets).forEach((eName) => {
            const es = this.model.entitySets[eName];
            if (entitySetsLinkedReferenceProperties[eName]) {
              es.linkedReferenceProperties = entitySetsLinkedReferenceProperties[eName];
            } else {
              es.linkedReferenceProperties = [];
            }
            const col = collection(eName, this.provider, this.model, validator, encryption, transactions);
            const addDefaultFields = (doc) => {
              doc.creationDate = /* @__PURE__ */ new Date();
              doc.modificationDate = /* @__PURE__ */ new Date();
              doc.shortid = doc.shortid || nanoid(7);
            };
            col.beforeInsertListeners.add("core-default-fields", (doc, req) => {
              addDefaultFields(doc);
            });
            col.beforeUpdateListeners.add("core-default-fields", (q, u, o, req) => {
              if (u.$set && o && o.upsert === true) {
                addDefaultFields(u.$set);
              }
              if (req && req.context.skipModificationDateUpdate === true) {
                return;
              }
              if (u.$set) {
                u.$set.modificationDate = /* @__PURE__ */ new Date();
              }
            });
            this.collections[eName] = col;
          });
          Object.keys(internalEntitySets).forEach((e) => this.internalCollections[e] = collection(e, this.provider, this.model, void 0, void 0, transactions));
          if (this.provider.load) {
            const modelToLoad = Object.assign({}, this.model);
            modelToLoad.entitySets = Object.assign({}, modelToLoad.entitySets, internalEntitySets);
            await this.provider.load(modelToLoad);
          }
          entitySchemasToGenerate.forEach((entityType) => {
            const schema2 = typeDefToJSONSchema(this.model, this.model.entityTypes[entityType]);
            if (schema2 == null) {
              return;
            }
            if (initialized && validator.getSchema(entityType) != null) {
              validator.addSchema(entityType, schema2, true);
            } else {
              validator.addSchema(entityType, schema2);
            }
          });
          this.emit("after-init", this);
          return this.internalAfterInitListeners.fire();
        },
        /**
        * Register type for odata.
        * Example:
        * documentStore.registerEntityType('UserType', {
        *       _id: {type: 'Edm.String', key: true}
        * })
        *
        * @param {String} type
        * @param {Object} def
        */
        registerEntityType(type, def, generateJSONSchema = defaultGenerateSchemaForEntityType) {
          generateSchemaEntityTypeConfig[type] = generateJSONSchema === true;
          this.model.entityTypes[type] = def;
        },
        addFileExtensionResolver(fn) {
          fileExtensionResolvers.push(fn);
        },
        resolveFileExtension(doc, entitySetName, propertyName) {
          const model = this.model;
          const entitySets = { ...model.entitySets, ...internalEntitySets };
          const es = entitySets[entitySetName];
          if (es == null) {
            throw new Error(`Entity set "${entitySetName}" does not exists`);
          }
          const entityTypeName = es.entityType;
          const entityType = es.entityTypeDef;
          const propTypeParts = propertyName.split(".");
          const propTypePartsLastIndex = propTypeParts.length - 1;
          let propType = entityType;
          propTypeParts.forEach((propName, idx) => {
            if (propType == null || propType[propName] == null) {
              throw new Error(`Property "${propertyName}" does not exists in entity type "${entityTypeName}"`);
            }
            propType = propType[propName];
            const resolveResult = this.resolvePropertyDefinition(propType);
            if (!resolveResult) {
              throw new Error(`Property "${propertyName}" does not have a valid type`);
            }
            if (resolveResult.def.type.startsWith("Collection(") && resolveResult.subType == null) {
              if (propTypePartsLastIndex !== idx) {
                propType = null;
              }
            } else if (resolveResult.subType) {
              propType = resolveResult.subType;
            }
          });
          if (!propType || propType.document == null) {
            return;
          }
          for (const resolver of fileExtensionResolvers) {
            const extension = resolver(doc, entitySetName, entityType, propType);
            if (extension) {
              return extension;
            }
          }
          return propType.document.extension;
        },
        /**
         * Register complex type for odata.
         * Example:
         * documentStore.registerComplexType('DataItemRefType', {
         *       name: {type: 'Edm.String' }
         * })
         *
         * @param {String} name
         * @param {Object} def
         */
        registerComplexType(name, def) {
          this.model.complexTypes[name] = def;
        },
        /**
         * Register complete entity set for odata. The first parameter is then use as a collection name
         * Example:
         * documentStore.registerEntitySet('users', {
         *       entityType: 'jsreport.UserType'
         * })
         *
         * @param {String} name
         * @param {Object} def
         */
        registerEntitySet(name, def) {
          const isInternal = def.internal === true;
          if (def.exportable == null || def.exportable === true) {
            def.exportable = true;
          } else {
            def.exportable = false;
          }
          if (isInternal && this.model.entitySets[name] != null) {
            throw new Error(
              `Entity set "${name}" can not be registered as internal entity because it was register as public entity previously`
            );
          } else if (!isInternal && internalEntitySets[name] != null) {
            throw new Error(
              `Entity set "${name}" can not be registered as public entity because it was register as internal entity previously`
            );
          }
          if (!isInternal) {
            this.model.entitySets[name] = def;
          } else {
            def.normalizedEntityTypeName = def.entityType.replace(this.model.namespace + ".", "");
            def.entityTypeDef = this.model.entityTypes[def.normalizedEntityTypeName];
            internalEntitySets[name] = def;
          }
        },
        /**
         *  Resolves the passed definition to contain subtype definition
         *  (useful when dealing with complex types or collection types)
         *  @param  {Object} def
         *  @return {Object}
         */
        resolvePropertyDefinition(def) {
          return resolvePropDefinition(this.model, def);
        },
        /**
         * Get the document Collection by the name provided in registerEntitySet
         * @param {String} name
         * @returns {Collection}
         */
        collection(name) {
          return this.collections[name];
        },
        /**
         * Get the document internal Collection by the name provided in registerEntitySet
         * @param {String} name
         * @returns {Collection}
         */
        internalCollection(name) {
          return this.internalCollections[name];
        },
        findLinkedEntitiesForReference(entitiesByCollection, collectionReferenceTargetName, referenceValue) {
          return findLinkedEntitiesForReferenceValue(this, entitiesByCollection, collectionReferenceTargetName, referenceValue);
        },
        existsReference(collectionReferenceOriginName, entity, collectionReferenceTargetName, referenceValue) {
          return existsReferenceValue(this, collectionReferenceOriginName, entity, collectionReferenceTargetName, referenceValue);
        },
        updateReference(collectionReferenceOriginName, entity, collectionReferenceTargetName, referenceOpts, newReferenceValue) {
          return updateReferenceValue(this, collectionReferenceOriginName, entity, collectionReferenceTargetName, referenceOpts, newReferenceValue);
        },
        checkDuplicatedId(collectionName, idValue, req) {
          return checkDuplicatedId(this, collectionName, idValue, req);
        },
        async close() {
          transactions.clear();
          if (this.provider && this.provider.close) {
            await this.provider.close();
          }
        },
        /**
         * Drop the whole document store
         * @returns {Promise}
         */
        async drop(req) {
          return this.provider.drop({
            transaction: transactions.getActiveTransaction(req)
          });
        },
        async beginTransaction(req) {
          if (this.options.store?.transactions?.enabled === false) {
            return;
          }
          if (req.context.storeTransaction && transactions.has(req.context.storeTransaction)) {
            throw new Error("Can not call store.beginTransaction when an active transaction already exists, make sure you are not calling store.beginTransaction more than once");
          }
          const tran = await this.provider.beginTransaction();
          const tranId = uuidv4();
          transactions.set(tranId, tran);
          req.context.storeTransaction = tranId;
        },
        async commitTransaction(req) {
          if (this.options.store?.transactions?.enabled === false) {
            return;
          }
          const tranId = req.context.storeTransaction;
          const tran = transactions.get(tranId);
          if (!tran) {
            throw new Error("Can not call store.commitTransaction without an active transaction, make sure you are calling store.beginTransaction previously or that you are not calling store.commitTransaction, store.rollbackTransaction more than once");
          }
          await this.provider.commitTransaction(tran);
          transactions.delete(tranId);
          delete req.context.storeTransaction;
        },
        async rollbackTransaction(req) {
          if (this.options.store?.transactions?.enabled === false) {
            return;
          }
          const tranId = req.context.storeTransaction;
          const tran = transactions.get(tranId);
          if (!tran) {
            throw new Error("Can not call store.rollbackTransaction without an active transaction, make sure you are calling store.beginTransaction previously or that you are not calling store.rollbackTransaction, store.commitTransaction more than once");
          }
          await this.provider.rollbackTransaction(tran);
          transactions.delete(tranId);
          delete req.context.storeTransaction;
        },
        generateId() {
          if (this.provider.generateId) {
            return this.provider.generateId();
          }
          return uuidv4();
        }
      };
      store.model.entityTypes = proxyTypeCollection({
        toGenerate: entitySchemasToGenerate,
        config: generateSchemaEntityTypeConfig,
        generateSchemaDefault: defaultGenerateSchemaForEntityType
      });
      return store;
    };
    function entityTypeHasKey(entityType) {
      let hasKey = false;
      Object.entries(entityType).forEach(([field, fieldDef]) => {
        if (hasKey === true) {
          return;
        }
        if (fieldDef.key === true) {
          hasKey = true;
        }
      });
      return hasKey;
    }
    function proxyTypeCollection({ toGenerate, config, generateSchemaDefault }) {
      return new Proxy({}, {
        set: (target, property, value, receiver) => {
          let shouldGenerate = config[property];
          if (shouldGenerate == null) {
            shouldGenerate = generateSchemaDefault;
          }
          if (shouldGenerate === true) {
            toGenerate.push(property);
          } else {
            const index = toGenerate.indexOf(property);
            if (index !== -1) {
              toGenerate.splice(index, 1);
            }
          }
          delete config[property];
          return Reflect.set(target, property, value, receiver);
        }
      });
    }
    module2.exports = (...args) => Object.assign(DocumentStore(...args), events.EventEmitter.prototype);
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/blobStorage/blobStorage.js
var require_blobStorage = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/blobStorage/blobStorage.js"(exports2, module2) {
    module2.exports = (reporter, options) => {
      let provider;
      return {
        async read(blobName, req) {
          const r = await provider.read(blobName, req);
          if (r == null) {
            throw reporter.createError(`Blob ${blobName} wasn't found`, {
              statusCode: 404
            });
          }
          return r;
        },
        write(blobName, buffer, req) {
          return provider.write(blobName, buffer, req);
        },
        async remove(blobName, req) {
          return provider.remove(blobName);
        },
        async append(blobName, buffer, req) {
          if (!provider.append) {
            let existingBuf = Buffer.from([]);
            try {
              existingBuf = await provider.read(blobName, req);
              await provider.remove(blobName, req);
            } catch (e) {
            }
            return provider.write(blobName, existingBuf ? Buffer.concat([existingBuf, buffer]) : buffer, req);
          }
          return provider.append(blobName, buffer, req);
        },
        async init() {
          if (provider.init) {
            return provider.init();
          }
        },
        drop() {
          if (provider.drop) {
            return provider.drop();
          }
        },
        get supportsAppend() {
          return provider.append instanceof Function;
        },
        get _provider() {
          return provider;
        },
        registerProvider(p) {
          provider = p;
        }
      };
    };
  }
});

// node_modules/camelcase/index.js
var require_camelcase = __commonJS({
  "node_modules/camelcase/index.js"(exports2, module2) {
    "use strict";
    var preserveCamelCase = (input) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i = 0; i < input.length; i++) {
        const c = input[i];
        if (isLastCharLower && /[a-zA-Z]/.test(c) && c.toUpperCase() === c) {
          input = input.slice(0, i) + "-" + input.slice(i);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i++;
        } else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(c) && c.toLowerCase() === c) {
          input = input.slice(0, i - 1) + "-" + input.slice(i - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = c.toLowerCase() === c;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = c.toUpperCase() === c;
        }
      }
      return input;
    };
    module2.exports = (input, options) => {
      options = Object.assign({
        pascalCase: false
      }, options);
      const postProcess = (x) => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;
      if (Array.isArray(input)) {
        input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      if (input.length === 1) {
        return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
      }
      if (/^[a-z\d]+$/.test(input)) {
        return postProcess(input);
      }
      const hasUpperCase = input !== input.toLowerCase();
      if (hasUpperCase) {
        input = preserveCamelCase(input);
      }
      input = input.replace(/^[_.\- ]+/, "").toLowerCase().replace(/[_.\- ]+(\w|$)/g, (m, p1) => p1.toUpperCase());
      return postProcess(input);
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/extensions/fileUtils.js
var require_fileUtils = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/extensions/fileUtils.js"(exports2) {
    var fs = require("fs");
    var path = require("path");
    exports2.walkSync = (rootPath, fileName, excludePath) => {
      const results = [];
      const queue = [];
      let next = rootPath;
      function dirname(f) {
        const parts = path.dirname(f).split(path.sep);
        return parts[parts.length - 1];
      }
      while (next) {
        let list;
        try {
          list = fs.readdirSync(next);
        } catch (e) {
          list = [];
        }
        list.forEach((i) => {
          const item = path.join(next, i);
          if (item.startsWith(excludePath)) {
            return;
          }
          try {
            if (fs.statSync(item).isDirectory()) {
              queue.push(item);
              return;
            }
          } catch (e) {
          }
          if (i === fileName) {
            const extensionsDirectoryName = dirname(item);
            const alreadyListedConfig = results.filter((f) => extensionsDirectoryName === dirname(f));
            if (!alreadyListedConfig.length) {
              results.push(item);
            }
          }
        });
        next = queue.shift();
      }
      return results;
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/extensions/locationCache.js
var require_locationCache = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/extensions/locationCache.js"(exports2, module2) {
    var path = require("path");
    var fs = require("fs/promises");
    var fileUtils = require_fileUtils();
    module2.exports = (config) => {
      const cacheEntryRootPath = path.join(__dirname, "../../../../../");
      const pathToLocationCache = path.join(config.tempCoreDirectory, "locations.json");
      return {
        async get() {
          if (process.env.NODE_ENV === "jsreport-development" || config.useExtensionsLocationCache === false) {
            config.logger.info("Skipping extensions location cache when NODE_ENV=jsreport-development or when option useExtensionsLocationCache === false, crawling now");
            return fileUtils.walkSync(config.rootDirectory, "jsreport.config.js");
          }
          try {
            await fs.stat(pathToLocationCache);
          } catch (e) {
            config.logger.info("Extensions location cache not found, crawling directories");
            return fileUtils.walkSync(config.rootDirectory, "jsreport.config.js");
          }
          const content = await fs.readFile(pathToLocationCache, "utf8");
          let cache;
          try {
            cache = JSON.parse(content)[cacheEntryRootPath];
          } catch (e) {
          }
          if (!cache) {
            config.logger.info("Extensions location cache doesn't contain entry yet, crawling");
            return fileUtils.walkSync(config.rootDirectory, "jsreport.config.js");
          }
          if (cache.rootDirectory !== config.rootDirectory) {
            config.logger.info(`Extensions location cache ${pathToLocationCache} contains information with different rootDirectory, crawling`);
            return fileUtils.walkSync(config.rootDirectory, "jsreport.config.js");
          }
          const stat = await fs.stat(cacheEntryRootPath);
          if (stat.mtime.getTime() > cache.lastSync) {
            config.logger.info(`Extensions location cache ${pathToLocationCache} contains older information, crawling`);
            return fileUtils.walkSync(config.rootDirectory, "jsreport.config.js");
          }
          await Promise.all(cache.locations.map((l) => fs.stat(l)));
          config.logger.info(`Extensions location cache contains up to date information, skipping crawling in ${config.rootDirectory}`);
          const directories = fileUtils.walkSync(config.rootDirectory, "jsreport.config.js", cacheEntryRootPath);
          const result = directories.concat(cache.locations);
          return result;
        },
        async save(extensions) {
          const directories = extensions.map((e) => path.join(e.directory, "jsreport.config.js")).filter((d) => d.startsWith(cacheEntryRootPath));
          await fs.mkdir(config.tempCoreDirectory, { recursive: true });
          try {
            await fs.stat(pathToLocationCache);
          } catch (e) {
            await fs.writeFile(pathToLocationCache, JSON.stringify({}), "utf8");
          }
          const content = await fs.readFile(pathToLocationCache, "utf8");
          let nodes = {};
          try {
            nodes = JSON.parse(content);
          } catch (e) {
          }
          nodes[cacheEntryRootPath] = {
            rootDirectory: config.rootDirectory,
            locations: directories,
            lastSync: (/* @__PURE__ */ new Date()).getTime()
          };
          config.logger.debug(`Writing extension locations cache to ${pathToLocationCache}`);
          return fs.writeFile(pathToLocationCache, JSON.stringify(nodes), "utf8");
        }
      };
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/extensions/discover.js
var require_discover = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/extensions/discover.js"(exports2, module2) {
    var path = require("path");
    var locationCache = require_locationCache();
    module2.exports = async (config) => {
      const cache = locationCache(config);
      config.logger.info(`Searching for available extensions in ${config.rootDirectory}`);
      const results = await cache.get();
      config.logger.info(`Found ${results.length} extension(s)`);
      const availableExtensions = results.map((configFile) => Object.assign({
        directory: path.dirname(configFile)
      }, require(configFile)));
      await cache.save(availableExtensions);
      return availableExtensions;
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/extensions/findVersion.js
var require_findVersion = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/extensions/findVersion.js"(exports2, module2) {
    var path = require("path");
    var fsAsync = require("fs/promises");
    module2.exports = async (extension) => {
      const result = {
        source: "anonymous"
      };
      if (extension.version != null || extension.source != null) {
        result.source = extension.source;
        result.version = extension.version;
        result.pkgVersion = extension.pkgVersion;
        return result;
      }
      if (extension.name == null) {
        return result;
      }
      if (extension.directory == null) {
        result.source = "local";
        result.version = "local:inline";
        return result;
      }
      try {
        const packageJsonContent = await fsAsync.readFile(path.join(extension.directory, "package.json"));
        const packageJson = JSON.parse(packageJsonContent.toString());
        if (extension.directory.includes("node_modules") && packageJson.version != null) {
          result.source = "npm";
          result.version = packageJson.version;
          result.pkgVersion = packageJson.version;
        } else if (packageJson.version != null) {
          result.source = "local";
          result.version = `local:${extension.directory}:${packageJson.version}`;
          result.pkgVersion = packageJson.version;
        } else {
          result.source = "local";
          result.version = `local:${extension.directory}`;
        }
      } catch (e) {
        result.source = "local";
        result.version = `local:${extension.directory}`;
      }
      return result;
    };
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof _SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse2 = (version2, options, throwErrors = false) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse2;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    var parse2 = require_parse();
    var valid = (version2, options) => {
      const v = parse2(version2, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    var parse2 = require_parse();
    var clean = (version2, options) => {
      const s = parse2(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    var SemVer = require_semver();
    var inc = (version2, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version2 instanceof SemVer ? version2.version : version2,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    var parse2 = require_parse();
    var diff = (version1, version2) => {
      const v12 = parse2(version1, null, true);
      const v2 = parse2(version2, null, true);
      const comparison = v12.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v12 : v2;
      const lowVersion = v1Higher ? v2 : v12;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v12.major !== v2.major) {
        return prefix + "major";
      }
      if (v12.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v12.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    var parse2 = require_parse();
    var prerelease = (version2, options) => {
      const parsed = parse2(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse2 = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version2.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse2(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/semver/node_modules/yallist/iterator.js
var require_iterator2 = __commonJS({
  "node_modules/semver/node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/semver/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/semver/node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node2;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node2(value, null, node, self2) : new Node2(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node2(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node2(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node2(value, prev, next, list) {
      if (!(this instanceof Node2)) {
        return new Node2(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator2()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/semver/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/semver/node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key)) return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().split(/\s+/).join(" ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version2, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    var Range = require_range();
    var satisfies = (version2, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range, hilo, options) => {
      version2 = new SemVer(version2, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    var outside = require_outside();
    var gtr = (version2, range, options) => outside(version2, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    var outside = require_outside();
    var ltr = (version2, range, options) => outside(version2, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version2 of v) {
        const included = satisfies(version2, range, options);
        if (included) {
          prev = version2;
          if (!first) {
            first = version2;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse2 = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse: parse2,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/extensions/validateMinimalVersion.js
var require_validateMinimalVersion = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/extensions/validateMinimalVersion.js"(exports2, module2) {
    var semver = require_semver2();
    function validateMinimalVersion(baseExtension, extension) {
      const generalErrorMsg = `${extension.name == null ? "Anonymous extension" : `Extension "${extension.name}"`} is not compatible with "${baseExtension.name}" extension.`;
      const getExtensionLabel = () => extension.name == null ? "anonymous extension" : `"${extension.name}"`;
      const normalizeVersionResults = /^(\d+)\.(\d+)\.(\d+)(-.+)?$/.exec(baseExtension.version);
      if (normalizeVersionResults == null) {
        throw new Error(`Invalid format for version of "${baseExtension.name}" extension. Version found: "${baseExtension.version}"`);
      }
      let shouldValidateThatRequiresIsNotEmpty = true;
      if (extension.source === "anonymous" || extension.source === "local" && extension.pkgVersion == null) {
        shouldValidateThatRequiresIsNotEmpty = false;
      }
      if (shouldValidateThatRequiresIsNotEmpty && extension.requires == null) {
        throw new Error(`${generalErrorMsg} Missing ".requires" information in ${getExtensionLabel(extension)} definition`);
      }
      const extensionRequires = extension.requires || {};
      const baseExtensionRequireInExtension = extensionRequires[baseExtension.name];
      if (baseExtensionRequireInExtension == null) {
        return;
      }
      const minimalVersionFormatRegExp = /^(x{1}|\d+)\.(x{1}|\d+)\.(x{1}|\d+)$/;
      if (!minimalVersionFormatRegExp.test(baseExtensionRequireInExtension)) {
        throw new Error(`${generalErrorMsg} Invalid format for minimal version of "${baseExtension.name}" extension. Minimal version found in ${getExtensionLabel(extension)} definition: "${baseExtensionRequireInExtension}"`);
      }
      const baseVersion = `${normalizeVersionResults[1]}.${normalizeVersionResults[2]}.${normalizeVersionResults[3]}`;
      const targetSemVer = `>=${baseExtensionRequireInExtension}`;
      const isValid = semver.satisfies(baseVersion, targetSemVer);
      if (!isValid) {
        throw new Error(`${generalErrorMsg} Minimal version spec "${baseExtensionRequireInExtension}" found in ${getExtensionLabel(extension)} does not match with version "${baseExtension.version}" of "${baseExtension.name}"`);
      }
    }
    module2.exports = validateMinimalVersion;
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/extensions/sorter.js
var require_sorter = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/extensions/sorter.js"(exports2, module2) {
    module2.exports = (pa, pb) => {
      pa.dependencies = pa.dependencies || [];
      pb.dependencies = pb.dependencies || [];
      if (pa.dependencies.length > pb.dependencies.length) return 1;
      if (pa.dependencies.length < pb.dependencies.length) return -1;
      return 0;
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/extensions/extensionsManager.js
var require_extensionsManager = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/extensions/extensionsManager.js"(exports2, module2) {
    var os = require("os");
    var path = require("path");
    var extend = require_node_extend_without();
    var camelCase = require_camelcase();
    var discover = require_discover();
    var findVersion = require_findVersion();
    var validateMinimalVersion = require_validateMinimalVersion();
    var sorter = require_sorter();
    module2.exports = (reporter) => {
      return {
        availableExtensions: [],
        recipes: [],
        engines: [],
        usedExtensions: [],
        get extensions() {
          return this.availableExtensions.filter((e) => !e.options || e.options.enabled !== false);
        },
        async load(opts = {}) {
          this.availableExtensions = [];
          if (reporter.options.discover || reporter.options.discover !== false && this.usedExtensions.length === 0) {
            const extensions = await discover({
              logger: reporter.logger,
              rootDirectory: reporter.options.rootDirectory,
              tempCoreDirectory: reporter.options.tempCoreDirectory,
              useExtensionsLocationCache: reporter.options.useExtensionsLocationCache
            });
            reporter.logger.debug(`Discovered ${extensions.length} extensions`);
            this.availableExtensions = this.availableExtensions.concat(extensions);
          }
          this.availableExtensions = this.availableExtensions.concat(this.usedExtensions);
          if (reporter.options.extensionsList) {
            this.availableExtensions = this.availableExtensions.filter((e) => reporter.options.extensionsList.indexOf(e.name) !== -1);
          }
          this.availableExtensions.sort(sorter);
          this.availableExtensions = this.extensions.filter((v, i) => {
            if (!v.name) {
              return true;
            }
            const extIndex = this.availableExtensions.findIndex((e) => e.name === v.name);
            const isUnique = extIndex === i;
            if (!isUnique) {
              reporter.logger.warn(`Filtering out duplicated extension "${v.name}" from ${v.directory}, using ${this.availableExtensions[extIndex].directory}`);
            }
            return isUnique;
          });
          if (opts.onlyLocation !== true) {
            this.availableExtensions = await Promise.all(this.availableExtensions.map(async (e) => {
              const { version: version2, pkgVersion, source } = await findVersion(e);
              return Object.assign(e, { source, version: version2, pkgVersion });
            }));
          }
        },
        async init() {
          return this._useMany(this.availableExtensions);
        },
        use(extension) {
          if (typeof extension === "function") {
            this.usedExtensions.push({
              main: extension,
              directory: reporter.options.parentModuleDirectory,
              dependencies: []
            });
            return;
          }
          if (typeof extension === "object") {
            this.usedExtensions.push(extension);
            return;
          }
          throw new Error("use accepts function or object");
        },
        async _useMany(extensions) {
          const toValidateGroups = /* @__PURE__ */ new Map();
          for (const e of extensions) {
            const activated = await this._useOne(e);
            if (!activated) {
              continue;
            }
            const extensionRequires = Object.assign({}, e.requires);
            delete extensionRequires.core;
            for (const baseExtName of Object.keys(extensionRequires)) {
              if (!toValidateGroups.has(baseExtName)) {
                toValidateGroups.set(baseExtName, []);
              }
              const deps = toValidateGroups.get(baseExtName);
              deps.push(e);
            }
          }
          for (const [baseExtName, deps] of toValidateGroups.entries()) {
            const baseExt = extensions.find((ext) => ext.name === baseExtName);
            if (baseExt == null || baseExt.pkgVersion == null) {
              continue;
            }
            for (const ext of deps) {
              validateMinimalVersion({ name: baseExtName, version: baseExt.pkgVersion }, ext);
            }
          }
        },
        async _useOne(extension) {
          try {
            extension.options = extend(
              true,
              {},
              extension.options || {},
              extension.name != null ? reporter.options.extensions[camelCase(extension.name)] : {},
              extension.name != null ? reporter.options.extensions[extension.name] : {}
            );
            if (extension.options.enabled === "false" || extension.options.enabled === "0") {
              extension.options.enabled = false;
            }
            if (extension.options.enabled === false) {
              if (!extension.name) {
                reporter.logger.debug(`Anonymous Extension${extension.directory != null ? ` at ${extension.directory}` : ""} is disabled, skipping`);
              } else {
                reporter.logger.debug(`Extension ${getExtensionDisplayName(extension)} is disabled, skipping`);
              }
              return false;
            }
            validateMinimalVersion({ name: "core", version: reporter.coreVersion }, extension);
            if (!extension.name) {
              reporter.logger.info(`Using anonymous extension${extension.directory != null ? ` at ${extension.directory}` : ""}`);
            } else {
              reporter.logger.info(`Using extension ${getExtensionDisplayName(extension)}`);
            }
            let optionsSchema;
            if (extension.name != null) {
              optionsSchema = reporter.optionsValidator.getRootSchema().properties.extensions.properties[extension.name];
            }
            if (optionsSchema != null) {
              try {
                reporter.optionsValidator.addSchema(extension.name, optionsSchema);
              } catch (e) {
                throw new Error(`schema for extension options in definition does not contain a valid json schema. ${e.message}`);
              }
              const optionsValidationResult = reporter.optionsValidator.validate(extension.name, extension.options, { rootPrefix: "options" });
              if (!optionsValidationResult.valid) {
                throw new Error(formatExtensionOptionsError(extension.name, optionsValidationResult.fullErrorMessage));
              }
              const availableExtensionIndex = this.availableExtensions.indexOf(extension);
              const usedExtensionIndex = this.usedExtensions.indexOf(extension);
              extension = new Proxy(extension, {
                set: (obj, prop, value, receiver) => {
                  let newValue;
                  if (prop === "options") {
                    const newData = extend(true, {}, value);
                    const result = reporter.optionsValidator.validate(extension.name, newData, { rootPrefix: "options" });
                    if (!result.valid) {
                      throw new Error(formatExtensionOptionsError(extension.name, result.fullErrorMessage));
                    }
                    newValue = newData;
                  } else {
                    newValue = value;
                  }
                  return Reflect.set(obj, prop, newValue, receiver);
                }
              });
              if (availableExtensionIndex !== -1) {
                this.availableExtensions[availableExtensionIndex] = extension;
              }
              if (usedExtensionIndex !== -1) {
                this.usedExtensions[usedExtensionIndex] = extension;
              }
              reporter.options.extensions[extension.name] = extension.options;
            }
            if (typeof extension.main === "function") {
              await extension.main.call(this, reporter, extension);
            } else {
              if (extension.directory && extension.main) {
                await require(path.join(extension.directory, extension.main)).call(this, reporter, extension);
              }
            }
            if (extension.options.enabled === false) {
              if (!extension.name) {
                reporter.logger.debug(`Anonymous Extension${extension.directory != null ? ` at ${extension.directory}` : ""} was disabled`);
              } else {
                reporter.logger.debug(`Extension ${getExtensionDisplayName(extension)} was disabled`);
              }
            }
            return extension.options.enabled !== false;
          } catch (e) {
            let errorMsg;
            if (!extension.name) {
              errorMsg = `Error when loading anonymous extension${extension.directory != null ? ` at ${extension.directory}` : ""}${os.EOL}${e.stack}`;
            } else {
              errorMsg = `Error when loading extension ${getExtensionDisplayName(extension)}${os.EOL}${e.stack}`;
            }
            throw new Error(errorMsg);
          }
        }
      };
    };
    function getExtensionDisplayName(extension) {
      if (extension.version != null) {
        return `${extension.name}@${extension.version}`;
      }
      return extension.name;
    }
    function formatExtensionOptionsError(extName, fullErrorMessage) {
      return `options of extension ${extName} contain values that does not match the defined schema. ${fullErrorMessage}`;
    }
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/settings.js
var require_settings = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/settings.js"(exports2, module2) {
    var Request = require_request();
    var Settings = module2.exports = function() {
    };
    Settings.prototype.add = function(key, value, req) {
      const settingItem = {
        key,
        value: typeof value !== "string" ? JSON.stringify(value) : value
      };
      return this.documentStore.collection("settings").insert(settingItem, localReqWithoutAuthorization(req));
    };
    Settings.prototype.findValue = async function(key, req) {
      const res = await this.documentStore.collection("settings").find({ key }, localReqWithoutAuthorization(req));
      if (res.length !== 1) {
        return null;
      }
      return typeof res[0].value === "string" ? JSON.parse(res[0].value) : res[0].value;
    };
    Settings.prototype.set = function(key, avalue, req) {
      const value = typeof avalue !== "string" ? JSON.stringify(avalue) : avalue;
      return this.documentStore.collection("settings").update({
        key
      }, {
        $set: { value }
      }, localReqWithoutAuthorization(req));
    };
    Settings.prototype.addOrSet = async function(key, avalue, req) {
      const value = typeof avalue !== "string" ? JSON.stringify(avalue) : avalue;
      const updateCount = await this.documentStore.collection("settings").update({ key }, { $set: { key, value } }, localReqWithoutAuthorization(req));
      if (updateCount === 0) {
        await this.documentStore.collection("settings").insert({ key, value }, localReqWithoutAuthorization(req));
        return 1;
      }
    };
    Settings.prototype.init = async function(documentStore, { authentication, authorization }) {
      this.documentStore = documentStore;
      if (authentication != null && authorization != null) {
        const col = documentStore.collection("settings");
        col.beforeInsertListeners.add("settings", async (doc, req) => {
          if (req && req.context && req.context.skipAuthorization) {
            return;
          }
          const isAdmin = await authentication.isUserAdmin(req?.context?.user, req);
          if (req && req.context && req.context.user && !isAdmin) {
            throw authorization.createAuthorizationError(col.name);
          }
        });
        col.beforeUpdateListeners.add("settings", async (q, u, options, req) => {
          if (req && req.context && req.context.skipAuthorization) {
            return;
          }
          const isAdmin = await authentication.isUserAdmin(req?.context?.user, req);
          if (req && req.context && req.context.user && !isAdmin) {
            throw authorization.createAuthorizationError(col.name);
          }
        });
        col.beforeRemoveListeners.add("settings", async (q, req) => {
          if (req && req.context && req.context.skipAuthorization) {
            return;
          }
          const isAdmin = await authentication.isUserAdmin(req?.context?.user, req);
          if (req && req.context && req.context.user && !isAdmin) {
            throw authorization.createAuthorizationError(col.name);
          }
        });
      }
    };
    Settings.prototype.registerEntity = function(documentStore) {
      documentStore.registerEntityType("SettingType", {
        key: { type: "Edm.String" },
        value: { type: "Edm.String" }
      });
      documentStore.registerEntitySet("settings", {
        entityType: "jsreport.SettingType",
        shared: true,
        exportable: false
      });
    };
    function localReqWithoutAuthorization(req) {
      if (req == null) {
        return req;
      }
      const localReq = Request(req);
      localReq.context.skipAuthorization = true;
      return localReq;
    }
    module2.exports = Settings;
  }
});

// node_modules/is-primitive/index.js
var require_is_primitive = __commonJS({
  "node_modules/is-primitive/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function isPrimitive(val) {
      if (typeof val === "object") {
        return val === null;
      }
      return typeof val !== "function";
    };
  }
});

// node_modules/isobject/index.js
var require_isobject = __commonJS({
  "node_modules/isobject/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function isObject(val) {
      return val != null && typeof val === "object" && Array.isArray(val) === false;
    };
  }
});

// node_modules/is-plain-object/index.js
var require_is_plain_object = __commonJS({
  "node_modules/is-plain-object/index.js"(exports2, module2) {
    "use strict";
    var isObject = require_isobject();
    function isObjectObject(o) {
      return isObject(o) === true && Object.prototype.toString.call(o) === "[object Object]";
    }
    module2.exports = function isPlainObject(o) {
      var ctor, prot;
      if (isObjectObject(o) === false) return false;
      ctor = o.constructor;
      if (typeof ctor !== "function") return false;
      prot = ctor.prototype;
      if (isObjectObject(prot) === false) return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    };
  }
});

// node_modules/set-value/index.js
var require_set_value = __commonJS({
  "node_modules/set-value/index.js"(exports2, module2) {
    "use strict";
    var { deleteProperty } = Reflect;
    var isPrimitive = require_is_primitive();
    var isPlainObject = require_is_plain_object();
    var isObject = (value) => {
      return typeof value === "object" && value !== null || typeof value === "function";
    };
    var isUnsafeKey = (key) => {
      return key === "__proto__" || key === "constructor" || key === "prototype";
    };
    var validateKey = (key) => {
      if (!isPrimitive(key)) {
        throw new TypeError("Object keys must be strings or symbols");
      }
      if (isUnsafeKey(key)) {
        throw new Error(`Cannot set unsafe key: "${key}"`);
      }
    };
    var toStringKey = (input) => {
      return Array.isArray(input) ? input.flat().map(String).join(",") : input;
    };
    var createMemoKey = (input, options) => {
      if (typeof input !== "string" || !options) return input;
      let key = input + ";";
      if (options.arrays !== void 0) key += `arrays=${options.arrays};`;
      if (options.separator !== void 0) key += `separator=${options.separator};`;
      if (options.split !== void 0) key += `split=${options.split};`;
      if (options.merge !== void 0) key += `merge=${options.merge};`;
      if (options.preservePaths !== void 0) key += `preservePaths=${options.preservePaths};`;
      return key;
    };
    var memoize = (input, options, fn) => {
      const key = toStringKey(options ? createMemoKey(input, options) : input);
      validateKey(key);
      const value = setValue.cache.get(key) || fn();
      setValue.cache.set(key, value);
      return value;
    };
    var splitString = (input, options = {}) => {
      const sep = options.separator || ".";
      const preserve = sep === "/" ? false : options.preservePaths;
      if (typeof input === "string" && preserve !== false && /\//.test(input)) {
        return [input];
      }
      const parts = [];
      let part = "";
      const push = (part2) => {
        let number;
        if (part2.trim() !== "" && Number.isInteger(number = Number(part2))) {
          parts.push(number);
        } else {
          parts.push(part2);
        }
      };
      for (let i = 0; i < input.length; i++) {
        const value = input[i];
        if (value === "\\") {
          part += input[++i];
          continue;
        }
        if (value === sep) {
          push(part);
          part = "";
          continue;
        }
        part += value;
      }
      if (part) {
        push(part);
      }
      return parts;
    };
    var split = (input, options) => {
      if (options && typeof options.split === "function") return options.split(input);
      if (typeof input === "symbol") return [input];
      if (Array.isArray(input)) return input;
      return memoize(input, options, () => splitString(input, options));
    };
    var assignProp = (obj, prop, value, options) => {
      validateKey(prop);
      if (value === void 0) {
        deleteProperty(obj, prop);
      } else if (options && options.merge) {
        const merge = options.merge === "function" ? options.merge : Object.assign;
        if (merge && isPlainObject(obj[prop]) && isPlainObject(value)) {
          obj[prop] = merge(obj[prop], value);
        } else {
          obj[prop] = value;
        }
      } else {
        obj[prop] = value;
      }
      return obj;
    };
    var setValue = (target, path, value, options) => {
      if (!path || !isObject(target)) return target;
      const keys = split(path, options);
      let obj = target;
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const next = keys[i + 1];
        validateKey(key);
        if (next === void 0) {
          assignProp(obj, key, value, options);
          break;
        }
        if (typeof next === "number" && !Array.isArray(obj[key])) {
          obj = obj[key] = [];
          continue;
        }
        if (!isObject(obj[key])) {
          obj[key] = {};
        }
        obj = obj[key];
      }
      return target;
    };
    setValue.split = split;
    setValue.cache = /* @__PURE__ */ new Map();
    setValue.clear = () => {
      setValue.cache = /* @__PURE__ */ new Map();
    };
    module2.exports = setValue;
  }
});

// node_modules/has-own-deep/index.js
var require_has_own_deep = __commonJS({
  "node_modules/has-own-deep/index.js"(exports2, module2) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var isObject = require_isobject();
    module2.exports = function(target, path) {
      if (!isObject(target) && !Array.isArray(target)) {
        throw new TypeError("expected the first argument to be an object or array");
      }
      if (typeof path !== "string") {
        throw new TypeError("expected object path to be a string");
      }
      if (hasOwn.call(target, path)) {
        return true;
      }
      let segs = Array.isArray(path) ? path : path.split(/\\?\./);
      let obj = target;
      while ((isObject(obj) || Array.isArray(obj)) && segs.length) {
        if (hasOwn.call(obj, segs[0])) {
          obj = obj[segs.shift()];
          continue;
        }
        let rest = segs.slice();
        let has = false;
        do {
          const prop = rest.join(".");
          if (has = hasOwn.call(obj, prop)) {
            segs = segs.slice(rest.length);
            obj = obj[prop];
            break;
          }
          rest.pop();
        } while (rest.length);
        if (!has) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/unset-value/node_modules/isobject/index.cjs.js
var require_index_cjs = __commonJS({
  "node_modules/unset-value/node_modules/isobject/index.cjs.js"(exports2, module2) {
    "use strict";
    function isObject(val) {
      return val != null && typeof val === "object" && Array.isArray(val) === false;
    }
    module2.exports = isObject;
  }
});

// node_modules/get-value/index.js
var require_get_value = __commonJS({
  "node_modules/get-value/index.js"(exports2, module2) {
    var isObject = require_isobject();
    module2.exports = function(target, path, options) {
      if (!isObject(options)) {
        options = { default: options };
      }
      if (!isValidObject(target)) {
        return typeof options.default !== "undefined" ? options.default : target;
      }
      if (typeof path === "number") {
        path = String(path);
      }
      const isArray = Array.isArray(path);
      const isString = typeof path === "string";
      const splitChar = options.separator || ".";
      const joinChar = options.joinChar || (typeof splitChar === "string" ? splitChar : ".");
      if (!isString && !isArray) {
        return target;
      }
      if (isString && path in target) {
        return isValid(path, target, options) ? target[path] : options.default;
      }
      let segs = isArray ? path : split(path, splitChar, options);
      let len = segs.length;
      let idx = 0;
      do {
        let prop = segs[idx];
        if (typeof prop === "number") {
          prop = String(prop);
        }
        while (prop && prop.slice(-1) === "\\") {
          prop = join([prop.slice(0, -1), segs[++idx] || ""], joinChar, options);
        }
        if (prop in target) {
          if (!isValid(prop, target, options)) {
            return options.default;
          }
          target = target[prop];
        } else {
          let hasProp = false;
          let n = idx + 1;
          while (n < len) {
            prop = join([prop, segs[n++]], joinChar, options);
            if (hasProp = prop in target) {
              if (!isValid(prop, target, options)) {
                return options.default;
              }
              target = target[prop];
              idx = n - 1;
              break;
            }
          }
          if (!hasProp) {
            return options.default;
          }
        }
      } while (++idx < len && isValidObject(target));
      if (idx === len) {
        return target;
      }
      return options.default;
    };
    function join(segs, joinChar, options) {
      if (typeof options.join === "function") {
        return options.join(segs);
      }
      return segs[0] + joinChar + segs[1];
    }
    function split(path, splitChar, options) {
      if (typeof options.split === "function") {
        return options.split(path);
      }
      return path.split(splitChar);
    }
    function isValid(key, target, options) {
      if (typeof options.isValid === "function") {
        return options.isValid(key, target);
      }
      return true;
    }
    function isValidObject(val) {
      return isObject(val) || Array.isArray(val) || typeof val === "function";
    }
  }
});

// node_modules/kind-of/index.js
var require_kind_of = __commonJS({
  "node_modules/kind-of/index.js"(exports2, module2) {
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (val === void 0) return "undefined";
      if (val === null) return "null";
      var type = typeof val;
      if (type === "boolean") return "boolean";
      if (type === "string") return "string";
      if (type === "number") return "number";
      if (type === "symbol") return "symbol";
      if (type === "function") {
        return isGeneratorFn(val) ? "generatorfunction" : "function";
      }
      if (isArray(val)) return "array";
      if (isBuffer(val)) return "buffer";
      if (isArguments(val)) return "arguments";
      if (isDate(val)) return "date";
      if (isError(val)) return "error";
      if (isRegexp(val)) return "regexp";
      switch (ctorName(val)) {
        case "Symbol":
          return "symbol";
        case "Promise":
          return "promise";
        // Set, Map, WeakSet, WeakMap
        case "WeakMap":
          return "weakmap";
        case "WeakSet":
          return "weakset";
        case "Map":
          return "map";
        case "Set":
          return "set";
        // 8-bit typed arrays
        case "Int8Array":
          return "int8array";
        case "Uint8Array":
          return "uint8array";
        case "Uint8ClampedArray":
          return "uint8clampedarray";
        // 16-bit typed arrays
        case "Int16Array":
          return "int16array";
        case "Uint16Array":
          return "uint16array";
        // 32-bit typed arrays
        case "Int32Array":
          return "int32array";
        case "Uint32Array":
          return "uint32array";
        case "Float32Array":
          return "float32array";
        case "Float64Array":
          return "float64array";
      }
      if (isGeneratorObj(val)) {
        return "generator";
      }
      type = toString.call(val);
      switch (type) {
        case "[object Object]":
          return "object";
        // iterators
        case "[object Map Iterator]":
          return "mapiterator";
        case "[object Set Iterator]":
          return "setiterator";
        case "[object String Iterator]":
          return "stringiterator";
        case "[object Array Iterator]":
          return "arrayiterator";
      }
      return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
    };
    function ctorName(val) {
      return typeof val.constructor === "function" ? val.constructor.name : null;
    }
    function isArray(val) {
      if (Array.isArray) return Array.isArray(val);
      return val instanceof Array;
    }
    function isError(val) {
      return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
    }
    function isDate(val) {
      if (val instanceof Date) return true;
      return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
    }
    function isRegexp(val) {
      if (val instanceof RegExp) return true;
      return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
    }
    function isGeneratorFn(name, val) {
      return ctorName(name) === "GeneratorFunction";
    }
    function isGeneratorObj(val) {
      return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
    }
    function isArguments(val) {
      try {
        if (typeof val.length === "number" && typeof val.callee === "function") {
          return true;
        }
      } catch (err) {
        if (err.message.indexOf("callee") !== -1) {
          return true;
        }
      }
      return false;
    }
    function isBuffer(val) {
      if (val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
  }
});

// node_modules/has-values/index.js
var require_has_values = __commonJS({
  "node_modules/has-values/index.js"(exports2, module2) {
    "use strict";
    var typeOf = require_kind_of();
    module2.exports = function has(val) {
      switch (typeOf(val)) {
        case "boolean":
        case "date":
        case "function":
        case "null":
        case "number":
          return true;
        case "undefined":
          return false;
        case "regexp":
          return val.source !== "(?:)" && val.source !== "";
        case "buffer":
          return val.toString() !== "";
        case "error":
          return val.message !== "";
        case "string":
        case "arguments":
          return val.length !== 0;
        case "file":
        case "map":
        case "set":
          return val.size !== 0;
        case "array":
        case "object":
          for (const key of Object.keys(val)) {
            if (has(val[key])) {
              return true;
            }
          }
          return false;
        // everything else
        default: {
          return true;
        }
      }
    };
  }
});

// node_modules/has-value/index.js
var require_has_value = __commonJS({
  "node_modules/has-value/index.js"(exports2, module2) {
    "use strict";
    var get = require_get_value();
    var has = require_has_values();
    module2.exports = function(obj, path, options) {
      if (isObject(obj) && (typeof path === "string" || Array.isArray(path))) {
        return has(get(obj, path, options));
      }
      return false;
    };
    function isObject(val) {
      return val != null && (typeof val === "object" || typeof val === "function" || Array.isArray(val));
    }
  }
});

// node_modules/unset-value/index.js
var require_unset_value = __commonJS({
  "node_modules/unset-value/index.js"(exports2, module2) {
    "use strict";
    var isObject = require_index_cjs();
    var has = require_has_value();
    var isUnsafeKey = (key) => {
      return key === "__proto__" || key === "constructor" || key === "prototype";
    };
    var validateKey = (key) => {
      if (isUnsafeKey(key)) {
        throw new Error(`Cannot set unsafe key: "${key}"`);
      }
    };
    module2.exports = function unset(obj, prop) {
      if (!isObject(obj)) {
        throw new TypeError("expected an object.");
      }
      var isArray = Array.isArray(prop);
      if (!isArray && obj.hasOwnProperty(prop)) {
        delete obj[prop];
        return true;
      }
      if (has(obj, prop)) {
        var segs = isArray ? prop.slice() : prop.split(".");
        var last = segs.pop();
        while (segs.length && segs[segs.length - 1].slice(-1) === "\\") {
          last = segs.pop().slice(0, -1) + "." + last;
        }
        while (segs.length) {
          prop = segs.shift();
          validateKey(prop);
          obj = obj[prop];
        }
        return delete obj[last];
      }
      return true;
    };
  }
});

// node_modules/bytes/index.js
var require_bytes = __commonJS({
  "node_modules/bytes/index.js"(exports2, module2) {
    "use strict";
    module2.exports = bytes;
    module2.exports.format = format;
    module2.exports.parse = parse2;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5)
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
    function bytes(value, options) {
      if (typeof value === "string") {
        return parse2(value);
      }
      if (typeof value === "number") {
        return format(value, options);
      }
      return null;
    }
    function format(value, options) {
      if (!Number.isFinite(value)) {
        return null;
      }
      var mag = Math.abs(value);
      var thousandsSeparator = options && options.thousandsSeparator || "";
      var unitSeparator = options && options.unitSeparator || "";
      var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
      var fixedDecimals = Boolean(options && options.fixedDecimals);
      var unit = options && options.unit || "";
      if (!unit || !map[unit.toLowerCase()]) {
        if (mag >= map.pb) {
          unit = "PB";
        } else if (mag >= map.tb) {
          unit = "TB";
        } else if (mag >= map.gb) {
          unit = "GB";
        } else if (mag >= map.mb) {
          unit = "MB";
        } else if (mag >= map.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value / map[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.split(".").map(function(s, i) {
          return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
        }).join(".");
      }
      return str + unitSeparator + unit;
    }
    function parse2(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      if (isNaN(floatValue)) {
        return null;
      }
      return Math.floor(map[unit] * floatValue);
    }
  }
});

// node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS({
  "node_modules/uri-js/dist/es5/uri.all.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.URI = global2.URI || {});
    })(exports2, function(exports3) {
      "use strict";
      function merge() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str) {
        return "(?:" + str + ")";
      }
      function typeOf(o) {
        return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str) {
        return str.toUpperCase();
      }
      function toArray(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      function buildExps(isIRI2) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
          NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
          //RFC 6874, with relaxed parsing rules
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = /* @__PURE__ */ function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var result = [];
        var length = array.length;
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = function ucs2encode2(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (
          ;
          /* no initialization */
          delta > baseMinusTMin * tMax >> 1;
          k += base
        ) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode = function decode2(input) {
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          var oldi = i;
          for (
            var w = 1, k = base;
            ;
            /* no condition */
            k += base
          ) {
            if (index >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error$1("overflow");
            }
            i += digit * w;
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            var baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error$1("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
      };
      var encode = function encode2(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n) {
                var q = delta;
                for (
                  var k = base;
                  ;
                  /* no condition */
                  k += base
                ) {
                  var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  var qMinusT = q - t;
                  var baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      };
      var punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16) e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128) e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
      }
      function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while (i < il) {
          var c = parseInt(str.substr(i + 1, 2), 16);
          if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
          } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
              var c2 = parseInt(str.substr(i + 4, 2), 16);
              newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
              newStr += str.substr(i, 6);
            }
            i += 6;
          } else if (c >= 224) {
            if (il - i >= 9) {
              var _c = parseInt(str.substr(i + 4, 2), 16);
              var c3 = parseInt(str.substr(i + 7, 2), 16);
              newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
              newStr += str.substr(i, 9);
            }
            i += 9;
          } else {
            newStr += str.substr(i, 3);
            i += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
          var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function(acc, field, index) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index) {
                lastLongest.length++;
              } else {
                acc.push({ index, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a, b) {
            return b.length - a.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse2(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            components.scheme = matches[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s = im[0];
              input = input.slice(s.length);
              output.push(s);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host)) {
          } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
          }
          if (authority === void 0) {
            s = s.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base2, relative) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base2 = parse2(serialize(base2, options), options);
          relative = parse2(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base2.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base2.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                  target.path = "/" + relative.path;
                } else if (!base2.path) {
                  target.path = relative.path;
                } else {
                  target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base2.userinfo;
            target.host = base2.host;
            target.port = base2.port;
          }
          target.scheme = base2.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize(resolveComponents(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse2(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse2(serialize(uri, options), options);
        }
        return uri;
      }
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse2(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse2(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse3(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize2(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse3(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize2(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
            wsComponents.path = path && path !== "/" ? path : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O = {};
      var isIRI = true;
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
              var hfield = hfields[x].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray(mailtoComponents.to);
          if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
              var toAddr = String(to[x]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
              to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name in headers) {
            if (headers[name] !== O[name]) {
              fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse3(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize2(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports3.SCHEMES = SCHEMES;
      exports3.pctEncChar = pctEncChar;
      exports3.pctDecChars = pctDecChars;
      exports3.parse = parse2;
      exports3.removeDotSegments = removeDotSegments;
      exports3.serialize = serialize;
      exports3.resolveComponents = resolveComponents;
      exports3.resolve = resolve;
      exports3.normalize = normalize;
      exports3.equal = equal;
      exports3.escapeComponent = escapeComponent;
      exports3.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/ajv/lib/compile/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/ajv/lib/compile/ucs2length.js"(exports2, module2) {
    "use strict";
    module2.exports = function ucs2length(str) {
      var length = 0, len = str.length, pos = 0, value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) == 56320) pos++;
        }
      }
      return length;
    };
  }
});

// node_modules/ajv/lib/compile/util.js
var require_util = __commonJS({
  "node_modules/ajv/lib/compile/util.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      copy,
      checkDataType,
      checkDataTypes,
      coerceToTypes,
      toHash,
      getProperty,
      escapeQuotes,
      equal: require_fast_deep_equal(),
      ucs2length: require_ucs2length(),
      varOccurences,
      varReplace,
      schemaHasRules,
      schemaHasRulesExcept,
      schemaUnknownRules,
      toQuotedString,
      getPathExpr,
      getPath,
      getData,
      unescapeFragment,
      unescapeJsonPointer,
      escapeFragment,
      escapeJsonPointer
    };
    function copy(o, to) {
      to = to || {};
      for (var key in o) to[key] = o[key];
      return to;
    }
    function checkDataType(dataType, data, strictNumbers, negate) {
      var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK = negate ? "!" : "", NOT = negate ? "" : "!";
      switch (dataType) {
        case "null":
          return data + EQUAL + "null";
        case "array":
          return OK + "Array.isArray(" + data + ")";
        case "object":
          return "(" + OK + data + AND + "typeof " + data + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data + "))";
        case "integer":
          return "(typeof " + data + EQUAL + '"number"' + AND + NOT + "(" + data + " % 1)" + AND + data + EQUAL + data + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
        case "number":
          return "(typeof " + data + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
        default:
          return "typeof " + data + EQUAL + '"' + dataType + '"';
      }
    }
    function checkDataTypes(dataTypes, data, strictNumbers) {
      switch (dataTypes.length) {
        case 1:
          return checkDataType(dataTypes[0], data, strictNumbers, true);
        default:
          var code = "";
          var types = toHash(dataTypes);
          if (types.array && types.object) {
            code = types.null ? "(" : "(!" + data + " || ";
            code += "typeof " + data + ' !== "object")';
            delete types.null;
            delete types.array;
            delete types.object;
          }
          if (types.number) delete types.integer;
          for (var t in types)
            code += (code ? " && " : "") + checkDataType(t, data, strictNumbers, true);
          return code;
      }
    }
    var COERCE_TO_TYPES = toHash(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(optionCoerceTypes, dataTypes) {
      if (Array.isArray(dataTypes)) {
        var types = [];
        for (var i = 0; i < dataTypes.length; i++) {
          var t = dataTypes[i];
          if (COERCE_TO_TYPES[t]) types[types.length] = t;
          else if (optionCoerceTypes === "array" && t === "array") types[types.length] = t;
        }
        if (types.length) return types;
      } else if (COERCE_TO_TYPES[dataTypes]) {
        return [dataTypes];
      } else if (optionCoerceTypes === "array" && dataTypes === "array") {
        return ["array"];
      }
    }
    function toHash(arr) {
      var hash = {};
      for (var i = 0; i < arr.length; i++) hash[arr[i]] = true;
      return hash;
    }
    var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var SINGLE_QUOTE = /'|\\/g;
    function getProperty(key) {
      return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
    }
    function escapeQuotes(str) {
      return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
    }
    function varOccurences(str, dataVar) {
      dataVar += "[^0-9]";
      var matches = str.match(new RegExp(dataVar, "g"));
      return matches ? matches.length : 0;
    }
    function varReplace(str, dataVar, expr) {
      dataVar += "([^0-9])";
      expr = expr.replace(/\$/g, "$$$$");
      return str.replace(new RegExp(dataVar, "g"), expr + "$1");
    }
    function schemaHasRules(schema2, rules) {
      if (typeof schema2 == "boolean") return !schema2;
      for (var key in schema2) if (rules[key]) return true;
    }
    function schemaHasRulesExcept(schema2, rules, exceptKeyword) {
      if (typeof schema2 == "boolean") return !schema2 && exceptKeyword != "not";
      for (var key in schema2) if (key != exceptKeyword && rules[key]) return true;
    }
    function schemaUnknownRules(schema2, rules) {
      if (typeof schema2 == "boolean") return;
      for (var key in schema2) if (!rules[key]) return key;
    }
    function toQuotedString(str) {
      return "'" + escapeQuotes(str) + "'";
    }
    function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
      var path = jsonPointers ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
      return joinPaths(currentPath, path);
    }
    function getPath(currentPath, prop, jsonPointers) {
      var path = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
      return joinPaths(currentPath, path);
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, lvl, paths) {
      var up, jsonPointer, data, matches;
      if ($data === "") return "rootData";
      if ($data[0] == "/") {
        if (!JSON_POINTER.test($data)) throw new Error("Invalid JSON-pointer: " + $data);
        jsonPointer = $data;
        data = "rootData";
      } else {
        matches = $data.match(RELATIVE_JSON_POINTER);
        if (!matches) throw new Error("Invalid JSON-pointer: " + $data);
        up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer == "#") {
          if (up >= lvl) throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
          return paths[lvl - up];
        }
        if (up > lvl) throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
        data = "data" + (lvl - up || "");
        if (!jsonPointer) return data;
      }
      var expr = data;
      var segments = jsonPointer.split("/");
      for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        if (segment) {
          data += getProperty(unescapeJsonPointer(segment));
          expr += " && " + data;
        }
      }
      return expr;
    }
    function joinPaths(a, b) {
      if (a == '""') return b;
      return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
    }
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    function escapeJsonPointer(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
  }
});

// node_modules/ajv/lib/compile/schema_obj.js
var require_schema_obj = __commonJS({
  "node_modules/ajv/lib/compile/schema_obj.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    module2.exports = SchemaObject;
    function SchemaObject(obj) {
      util.copy(obj, this);
    }
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    var traverse = module2.exports = function(schema2, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema2, "", schema2);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema2 && typeof schema2 == "object" && !Array.isArray(schema2)) {
        pre(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema2) {
          var sch = schema2[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema2, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema2, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema2);
          }
        }
        post(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/ajv/lib/compile/resolve.js
var require_resolve2 = __commonJS({
  "node_modules/ajv/lib/compile/resolve.js"(exports2, module2) {
    "use strict";
    var URI = require_uri_all();
    var equal = require_fast_deep_equal();
    var util = require_util();
    var SchemaObject = require_schema_obj();
    var traverse = require_json_schema_traverse();
    module2.exports = resolve;
    resolve.normalizeId = normalizeId;
    resolve.fullPath = getFullPath;
    resolve.url = resolveUrl;
    resolve.ids = resolveIds;
    resolve.inlineRef = inlineRef;
    resolve.schema = resolveSchema;
    function resolve(compile, root, ref) {
      var refVal = this._refs[ref];
      if (typeof refVal == "string") {
        if (this._refs[refVal]) refVal = this._refs[refVal];
        else return resolve.call(this, compile, root, refVal);
      }
      refVal = refVal || this._schemas[ref];
      if (refVal instanceof SchemaObject) {
        return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
      }
      var res = resolveSchema.call(this, root, ref);
      var schema2, v, baseId;
      if (res) {
        schema2 = res.schema;
        root = res.root;
        baseId = res.baseId;
      }
      if (schema2 instanceof SchemaObject) {
        v = schema2.validate || compile.call(this, schema2.schema, root, void 0, baseId);
      } else if (schema2 !== void 0) {
        v = inlineRef(schema2, this._opts.inlineRefs) ? schema2 : compile.call(this, schema2, root, void 0, baseId);
      }
      return v;
    }
    function resolveSchema(root, ref) {
      var p = URI.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
      if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
        var id = normalizeId(refPath);
        var refVal = this._refs[id];
        if (typeof refVal == "string") {
          return resolveRecursive.call(this, root, refVal, p);
        } else if (refVal instanceof SchemaObject) {
          if (!refVal.validate) this._compile(refVal);
          root = refVal;
        } else {
          refVal = this._schemas[id];
          if (refVal instanceof SchemaObject) {
            if (!refVal.validate) this._compile(refVal);
            if (id == normalizeId(ref))
              return { schema: refVal, root, baseId };
            root = refVal;
          } else {
            return;
          }
        }
        if (!root.schema) return;
        baseId = getFullPath(this._getId(root.schema));
      }
      return getJsonPointer.call(this, p, baseId, root.schema, root);
    }
    function resolveRecursive(root, ref, parsedRef) {
      var res = resolveSchema.call(this, root, ref);
      if (res) {
        var schema2 = res.schema;
        var baseId = res.baseId;
        root = res.root;
        var id = this._getId(schema2);
        if (id) baseId = resolveUrl(baseId, id);
        return getJsonPointer.call(this, parsedRef, baseId, schema2, root);
      }
    }
    var PREVENT_SCOPE_CHANGE = util.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
    function getJsonPointer(parsedRef, baseId, schema2, root) {
      parsedRef.fragment = parsedRef.fragment || "";
      if (parsedRef.fragment.slice(0, 1) != "/") return;
      var parts = parsedRef.fragment.split("/");
      for (var i = 1; i < parts.length; i++) {
        var part = parts[i];
        if (part) {
          part = util.unescapeFragment(part);
          schema2 = schema2[part];
          if (schema2 === void 0) break;
          var id;
          if (!PREVENT_SCOPE_CHANGE[part]) {
            id = this._getId(schema2);
            if (id) baseId = resolveUrl(baseId, id);
            if (schema2.$ref) {
              var $ref = resolveUrl(baseId, schema2.$ref);
              var res = resolveSchema.call(this, root, $ref);
              if (res) {
                schema2 = res.schema;
                root = res.root;
                baseId = res.baseId;
              }
            }
          }
        }
      }
      if (schema2 !== void 0 && schema2 !== root.schema)
        return { schema: schema2, root, baseId };
    }
    var SIMPLE_INLINED = util.toHash([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum"
    ]);
    function inlineRef(schema2, limit) {
      if (limit === false) return false;
      if (limit === void 0 || limit === true) return checkNoRef(schema2);
      else if (limit) return countKeys(schema2) <= limit;
    }
    function checkNoRef(schema2) {
      var item;
      if (Array.isArray(schema2)) {
        for (var i = 0; i < schema2.length; i++) {
          item = schema2[i];
          if (typeof item == "object" && !checkNoRef(item)) return false;
        }
      } else {
        for (var key in schema2) {
          if (key == "$ref") return false;
          item = schema2[key];
          if (typeof item == "object" && !checkNoRef(item)) return false;
        }
      }
      return true;
    }
    function countKeys(schema2) {
      var count = 0, item;
      if (Array.isArray(schema2)) {
        for (var i = 0; i < schema2.length; i++) {
          item = schema2[i];
          if (typeof item == "object") count += countKeys(item);
          if (count == Infinity) return Infinity;
        }
      } else {
        for (var key in schema2) {
          if (key == "$ref") return Infinity;
          if (SIMPLE_INLINED[key]) {
            count++;
          } else {
            item = schema2[key];
            if (typeof item == "object") count += countKeys(item) + 1;
            if (count == Infinity) return Infinity;
          }
        }
      }
      return count;
    }
    function getFullPath(id, normalize) {
      if (normalize !== false) id = normalizeId(id);
      var p = URI.parse(id);
      return _getFullPath(p);
    }
    function _getFullPath(p) {
      return URI.serialize(p).split("#")[0] + "#";
    }
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    function resolveUrl(baseId, id) {
      id = normalizeId(id);
      return URI.resolve(baseId, id);
    }
    function resolveIds(schema2) {
      var schemaId = normalizeId(this._getId(schema2));
      var baseIds = { "": schemaId };
      var fullPaths = { "": getFullPath(schemaId, false) };
      var localRefs = {};
      var self2 = this;
      traverse(schema2, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (jsonPtr === "") return;
        var id = self2._getId(sch);
        var baseId = baseIds[parentJsonPtr];
        var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
        if (keyIndex !== void 0)
          fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util.escapeFragment(keyIndex));
        if (typeof id == "string") {
          id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
          var refVal = self2._refs[id];
          if (typeof refVal == "string") refVal = self2._refs[refVal];
          if (refVal && refVal.schema) {
            if (!equal(sch, refVal.schema))
              throw new Error('id "' + id + '" resolves to more than one schema');
          } else if (id != normalizeId(fullPath)) {
            if (id[0] == "#") {
              if (localRefs[id] && !equal(sch, localRefs[id]))
                throw new Error('id "' + id + '" resolves to more than one schema');
              localRefs[id] = sch;
            } else {
              self2._refs[id] = fullPath;
            }
          }
        }
        baseIds[jsonPtr] = baseId;
        fullPaths[jsonPtr] = fullPath;
      });
      return localRefs;
    }
  }
});

// node_modules/ajv/lib/compile/error_classes.js
var require_error_classes = __commonJS({
  "node_modules/ajv/lib/compile/error_classes.js"(exports2, module2) {
    "use strict";
    var resolve = require_resolve2();
    module2.exports = {
      Validation: errorSubclass(ValidationError),
      MissingRef: errorSubclass(MissingRefError)
    };
    function ValidationError(errors) {
      this.message = "validation failed";
      this.errors = errors;
      this.ajv = this.validation = true;
    }
    MissingRefError.message = function(baseId, ref) {
      return "can't resolve reference " + ref + " from id " + baseId;
    };
    function MissingRefError(baseId, ref, message) {
      this.message = message || MissingRefError.message(baseId, ref);
      this.missingRef = resolve.url(baseId, ref);
      this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
    }
    function errorSubclass(Subclass) {
      Subclass.prototype = Object.create(Error.prototype);
      Subclass.prototype.constructor = Subclass;
      return Subclass;
    }
  }
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "node_modules/fast-json-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(data, opts) {
      if (!opts) opts = {};
      if (typeof opts === "function") opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && /* @__PURE__ */ function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify2(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0) return;
        if (typeof node == "number") return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object") return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i) out += ",";
            out += stringify2(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null) return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles) return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify2(node[key]);
          if (!value) continue;
          if (out) out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data);
    };
  }
});

// node_modules/ajv/lib/dotjs/validate.js
var require_validate = __commonJS({
  "node_modules/ajv/lib/dotjs/validate.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_validate(it2, $keyword, $ruleType) {
      var out = "";
      var $async = it2.schema.$async === true, $refKeywords = it2.util.schemaHasRulesExcept(it2.schema, it2.RULES.all, "$ref"), $id = it2.self._getId(it2.schema);
      if (it2.opts.strictKeywords) {
        var $unknownKwd = it2.util.schemaUnknownRules(it2.schema, it2.RULES.keywords);
        if ($unknownKwd) {
          var $keywordsMsg = "unknown keyword: " + $unknownKwd;
          if (it2.opts.strictKeywords === "log") it2.logger.warn($keywordsMsg);
          else throw new Error($keywordsMsg);
        }
      }
      if (it2.isTop) {
        out += " var validate = ";
        if ($async) {
          it2.async = true;
          out += "async ";
        }
        out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
        if ($id && (it2.opts.sourceCode || it2.opts.processCode)) {
          out += " " + ("/*# sourceURL=" + $id + " */") + " ";
        }
      }
      if (typeof it2.schema == "boolean" || !($refKeywords || it2.schema.$ref)) {
        var $keyword = "false schema";
        var $lvl = it2.level;
        var $dataLvl = it2.dataLevel;
        var $schema = it2.schema[$keyword];
        var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
        var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it2.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        if (it2.schema === false) {
          if (it2.isTop) {
            $breakOnError = true;
          } else {
            out += " var " + $valid + " = false; ";
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it2.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it2.opts.messages !== false) {
              out += " , message: 'boolean schema is false' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        } else {
          if (it2.isTop) {
            if ($async) {
              out += " return data; ";
            } else {
              out += " validate.errors = null; return true; ";
            }
          } else {
            out += " var " + $valid + " = true; ";
          }
        }
        if (it2.isTop) {
          out += " }; return validate; ";
        }
        return out;
      }
      if (it2.isTop) {
        var $top = it2.isTop, $lvl = it2.level = 0, $dataLvl = it2.dataLevel = 0, $data = "data";
        it2.rootId = it2.resolve.fullPath(it2.self._getId(it2.root.schema));
        it2.baseId = it2.baseId || it2.rootId;
        delete it2.isTop;
        it2.dataPathArr = [""];
        if (it2.schema.default !== void 0 && it2.opts.useDefaults && it2.opts.strictDefaults) {
          var $defaultMsg = "default is ignored in the schema root";
          if (it2.opts.strictDefaults === "log") it2.logger.warn($defaultMsg);
          else throw new Error($defaultMsg);
        }
        out += " var vErrors = null; ";
        out += " var errors = 0;     ";
        out += " if (rootData === undefined) rootData = data; ";
      } else {
        var $lvl = it2.level, $dataLvl = it2.dataLevel, $data = "data" + ($dataLvl || "");
        if ($id) it2.baseId = it2.resolve.url(it2.baseId, $id);
        if ($async && !it2.async) throw new Error("async schema in sync schema");
        out += " var errs_" + $lvl + " = errors;";
      }
      var $valid = "valid" + $lvl, $breakOnError = !it2.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
      var $errorKeyword;
      var $typeSchema = it2.schema.type, $typeIsArray = Array.isArray($typeSchema);
      if ($typeSchema && it2.opts.nullable && it2.schema.nullable === true) {
        if ($typeIsArray) {
          if ($typeSchema.indexOf("null") == -1) $typeSchema = $typeSchema.concat("null");
        } else if ($typeSchema != "null") {
          $typeSchema = [$typeSchema, "null"];
          $typeIsArray = true;
        }
      }
      if ($typeIsArray && $typeSchema.length == 1) {
        $typeSchema = $typeSchema[0];
        $typeIsArray = false;
      }
      if (it2.schema.$ref && $refKeywords) {
        if (it2.opts.extendRefs == "fail") {
          throw new Error('$ref: validation keywords used in schema at path "' + it2.errSchemaPath + '" (see option extendRefs)');
        } else if (it2.opts.extendRefs !== true) {
          $refKeywords = false;
          it2.logger.warn('$ref: keywords ignored in schema at path "' + it2.errSchemaPath + '"');
        }
      }
      if (it2.schema.$comment && it2.opts.$comment) {
        out += " " + it2.RULES.all.$comment.code(it2, "$comment");
      }
      if ($typeSchema) {
        if (it2.opts.coerceTypes) {
          var $coerceToTypes = it2.util.coerceToTypes(it2.opts.coerceTypes, $typeSchema);
        }
        var $rulesGroup = it2.RULES.types[$typeSchema];
        if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
          var $schemaPath = it2.schemaPath + ".type", $errSchemaPath = it2.errSchemaPath + "/type";
          var $schemaPath = it2.schemaPath + ".type", $errSchemaPath = it2.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
          out += " if (" + it2.util[$method]($typeSchema, $data, it2.opts.strictNumbers, true) + ") { ";
          if ($coerceToTypes) {
            var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
            out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
            if (it2.opts.coerceTypes == "array") {
              out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it2.util.checkDataType(it2.schema.type, $data, it2.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
            }
            out += " if (" + $coerced + " !== undefined) ; ";
            var arr1 = $coerceToTypes;
            if (arr1) {
              var $type, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $type = arr1[$i += 1];
                if ($type == "string") {
                  out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
                } else if ($type == "number" || $type == "integer") {
                  out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                  if ($type == "integer") {
                    out += " && !(" + $data + " % 1)";
                  }
                  out += ")) " + $coerced + " = +" + $data + "; ";
                } else if ($type == "boolean") {
                  out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
                } else if ($type == "null") {
                  out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
                } else if (it2.opts.coerceTypes == "array" && $type == "array") {
                  out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
                }
              }
            }
            out += " else {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it2.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it2.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it2.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it2.compositeRule && $breakOnError) {
              if (it2.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } if (" + $coerced + " !== undefined) {  ";
            var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it2.dataPathArr[$dataLvl] : "parentDataProperty";
            out += " " + $data + " = " + $coerced + "; ";
            if (!$dataLvl) {
              out += "if (" + $parentData + " !== undefined)";
            }
            out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
          } else {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it2.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it2.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it2.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it2.compositeRule && $breakOnError) {
              if (it2.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          }
          out += " } ";
        }
      }
      if (it2.schema.$ref && !$refKeywords) {
        out += " " + it2.RULES.all.$ref.code(it2, "$ref") + " ";
        if ($breakOnError) {
          out += " } if (errors === ";
          if ($top) {
            out += "0";
          } else {
            out += "errs_" + $lvl;
          }
          out += ") { ";
          $closingBraces2 += "}";
        }
      } else {
        var arr2 = it2.RULES;
        if (arr2) {
          var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
          while (i2 < l2) {
            $rulesGroup = arr2[i2 += 1];
            if ($shouldUseGroup($rulesGroup)) {
              if ($rulesGroup.type) {
                out += " if (" + it2.util.checkDataType($rulesGroup.type, $data, it2.opts.strictNumbers) + ") { ";
              }
              if (it2.opts.useDefaults) {
                if ($rulesGroup.type == "object" && it2.schema.properties) {
                  var $schema = it2.schema.properties, $schemaKeys = Object.keys($schema);
                  var arr3 = $schemaKeys;
                  if (arr3) {
                    var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                    while (i3 < l3) {
                      $propertyKey = arr3[i3 += 1];
                      var $sch = $schema[$propertyKey];
                      if ($sch.default !== void 0) {
                        var $passData = $data + it2.util.getProperty($propertyKey);
                        if (it2.compositeRule) {
                          if (it2.opts.strictDefaults) {
                            var $defaultMsg = "default is ignored for: " + $passData;
                            if (it2.opts.strictDefaults === "log") it2.logger.warn($defaultMsg);
                            else throw new Error($defaultMsg);
                          }
                        } else {
                          out += " if (" + $passData + " === undefined ";
                          if (it2.opts.useDefaults == "empty") {
                            out += " || " + $passData + " === null || " + $passData + " === '' ";
                          }
                          out += " ) " + $passData + " = ";
                          if (it2.opts.useDefaults == "shared") {
                            out += " " + it2.useDefault($sch.default) + " ";
                          } else {
                            out += " " + JSON.stringify($sch.default) + " ";
                          }
                          out += "; ";
                        }
                      }
                    }
                  }
                } else if ($rulesGroup.type == "array" && Array.isArray(it2.schema.items)) {
                  var arr4 = it2.schema.items;
                  if (arr4) {
                    var $sch, $i = -1, l4 = arr4.length - 1;
                    while ($i < l4) {
                      $sch = arr4[$i += 1];
                      if ($sch.default !== void 0) {
                        var $passData = $data + "[" + $i + "]";
                        if (it2.compositeRule) {
                          if (it2.opts.strictDefaults) {
                            var $defaultMsg = "default is ignored for: " + $passData;
                            if (it2.opts.strictDefaults === "log") it2.logger.warn($defaultMsg);
                            else throw new Error($defaultMsg);
                          }
                        } else {
                          out += " if (" + $passData + " === undefined ";
                          if (it2.opts.useDefaults == "empty") {
                            out += " || " + $passData + " === null || " + $passData + " === '' ";
                          }
                          out += " ) " + $passData + " = ";
                          if (it2.opts.useDefaults == "shared") {
                            out += " " + it2.useDefault($sch.default) + " ";
                          } else {
                            out += " " + JSON.stringify($sch.default) + " ";
                          }
                          out += "; ";
                        }
                      }
                    }
                  }
                }
              }
              var arr5 = $rulesGroup.rules;
              if (arr5) {
                var $rule, i5 = -1, l5 = arr5.length - 1;
                while (i5 < l5) {
                  $rule = arr5[i5 += 1];
                  if ($shouldUseRule($rule)) {
                    var $code = $rule.code(it2, $rule.keyword, $rulesGroup.type);
                    if ($code) {
                      out += " " + $code + " ";
                      if ($breakOnError) {
                        $closingBraces1 += "}";
                      }
                    }
                  }
                }
              }
              if ($breakOnError) {
                out += " " + $closingBraces1 + " ";
                $closingBraces1 = "";
              }
              if ($rulesGroup.type) {
                out += " } ";
                if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                  out += " else { ";
                  var $schemaPath = it2.schemaPath + ".type", $errSchemaPath = it2.errSchemaPath + "/type";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it2.createErrors !== false) {
                    out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                    if ($typeIsArray) {
                      out += "" + $typeSchema.join(",");
                    } else {
                      out += "" + $typeSchema;
                    }
                    out += "' } ";
                    if (it2.opts.messages !== false) {
                      out += " , message: 'should be ";
                      if ($typeIsArray) {
                        out += "" + $typeSchema.join(",");
                      } else {
                        out += "" + $typeSchema;
                      }
                      out += "' ";
                    }
                    if (it2.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it2.compositeRule && $breakOnError) {
                    if (it2.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  out += " } ";
                }
              }
              if ($breakOnError) {
                out += " if (errors === ";
                if ($top) {
                  out += "0";
                } else {
                  out += "errs_" + $lvl;
                }
                out += ") { ";
                $closingBraces2 += "}";
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces2 + " ";
      }
      if ($top) {
        if ($async) {
          out += " if (errors === 0) return data;           ";
          out += " else throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; ";
          out += " return errors === 0;       ";
        }
        out += " }; return validate;";
      } else {
        out += " var " + $valid + " = errors === errs_" + $lvl + ";";
      }
      function $shouldUseGroup($rulesGroup2) {
        var rules = $rulesGroup2.rules;
        for (var i = 0; i < rules.length; i++)
          if ($shouldUseRule(rules[i])) return true;
      }
      function $shouldUseRule($rule2) {
        return it2.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
      }
      function $ruleImplementsSomeKeyword($rule2) {
        var impl = $rule2.implements;
        for (var i = 0; i < impl.length; i++)
          if (it2.schema[impl[i]] !== void 0) return true;
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/compile/index.js
var require_compile = __commonJS({
  "node_modules/ajv/lib/compile/index.js"(exports2, module2) {
    "use strict";
    var resolve = require_resolve2();
    var util = require_util();
    var errorClasses = require_error_classes();
    var stableStringify = require_fast_json_stable_stringify();
    var validateGenerator = require_validate();
    var ucs2length = util.ucs2length;
    var equal = require_fast_deep_equal();
    var ValidationError = errorClasses.Validation;
    module2.exports = compile;
    function compile(schema2, root, localRefs, baseId) {
      var self2 = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
      root = root || { schema: schema2, refVal, refs };
      var c = checkCompiling.call(this, schema2, root, baseId);
      var compilation = this._compilations[c.index];
      if (c.compiling) return compilation.callValidate = callValidate;
      var formats = this._formats;
      var RULES = this.RULES;
      try {
        var v = localCompile(schema2, root, localRefs, baseId);
        compilation.validate = v;
        var cv = compilation.callValidate;
        if (cv) {
          cv.schema = v.schema;
          cv.errors = null;
          cv.refs = v.refs;
          cv.refVal = v.refVal;
          cv.root = v.root;
          cv.$async = v.$async;
          if (opts.sourceCode) cv.source = v.source;
        }
        return v;
      } finally {
        endCompiling.call(this, schema2, root, baseId);
      }
      function callValidate() {
        var validate2 = compilation.validate;
        var result = validate2.apply(this, arguments);
        callValidate.errors = validate2.errors;
        return result;
      }
      function localCompile(_schema, _root, localRefs2, baseId2) {
        var isRoot = !_root || _root && _root.schema == _schema;
        if (_root.schema != root.schema)
          return compile.call(self2, _schema, _root, localRefs2, baseId2);
        var $async = _schema.$async === true;
        var sourceCode = validateGenerator({
          isTop: true,
          schema: _schema,
          isRoot,
          baseId: baseId2,
          root: _root,
          schemaPath: "",
          errSchemaPath: "#",
          errorPath: '""',
          MissingRefError: errorClasses.MissingRef,
          RULES,
          validate: validateGenerator,
          util,
          resolve,
          resolveRef,
          usePattern,
          useDefault,
          useCustomRule,
          opts,
          formats,
          logger: self2.logger,
          self: self2
        });
        sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
        if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
        var validate2;
        try {
          var makeValidate = new Function(
            "self",
            "RULES",
            "formats",
            "root",
            "refVal",
            "defaults",
            "customRules",
            "equal",
            "ucs2length",
            "ValidationError",
            sourceCode
          );
          validate2 = makeValidate(
            self2,
            RULES,
            formats,
            root,
            refVal,
            defaults,
            customRules,
            equal,
            ucs2length,
            ValidationError
          );
          refVal[0] = validate2;
        } catch (e) {
          self2.logger.error("Error compiling schema, function code:", sourceCode);
          throw e;
        }
        validate2.schema = _schema;
        validate2.errors = null;
        validate2.refs = refs;
        validate2.refVal = refVal;
        validate2.root = isRoot ? validate2 : _root;
        if ($async) validate2.$async = true;
        if (opts.sourceCode === true) {
          validate2.source = {
            code: sourceCode,
            patterns,
            defaults
          };
        }
        return validate2;
      }
      function resolveRef(baseId2, ref, isRoot) {
        ref = resolve.url(baseId2, ref);
        var refIndex = refs[ref];
        var _refVal, refCode;
        if (refIndex !== void 0) {
          _refVal = refVal[refIndex];
          refCode = "refVal[" + refIndex + "]";
          return resolvedRef(_refVal, refCode);
        }
        if (!isRoot && root.refs) {
          var rootRefId = root.refs[ref];
          if (rootRefId !== void 0) {
            _refVal = root.refVal[rootRefId];
            refCode = addLocalRef(ref, _refVal);
            return resolvedRef(_refVal, refCode);
          }
        }
        refCode = addLocalRef(ref);
        var v2 = resolve.call(self2, localCompile, root, ref);
        if (v2 === void 0) {
          var localSchema = localRefs && localRefs[ref];
          if (localSchema) {
            v2 = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self2, localSchema, root, localRefs, baseId2);
          }
        }
        if (v2 === void 0) {
          removeLocalRef(ref);
        } else {
          replaceLocalRef(ref, v2);
          return resolvedRef(v2, refCode);
        }
      }
      function addLocalRef(ref, v2) {
        var refId = refVal.length;
        refVal[refId] = v2;
        refs[ref] = refId;
        return "refVal" + refId;
      }
      function removeLocalRef(ref) {
        delete refs[ref];
      }
      function replaceLocalRef(ref, v2) {
        var refId = refs[ref];
        refVal[refId] = v2;
      }
      function resolvedRef(refVal2, code) {
        return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code, schema: refVal2, inline: true } : { code, $async: refVal2 && !!refVal2.$async };
      }
      function usePattern(regexStr) {
        var index = patternsHash[regexStr];
        if (index === void 0) {
          index = patternsHash[regexStr] = patterns.length;
          patterns[index] = regexStr;
        }
        return "pattern" + index;
      }
      function useDefault(value) {
        switch (typeof value) {
          case "boolean":
          case "number":
            return "" + value;
          case "string":
            return util.toQuotedString(value);
          case "object":
            if (value === null) return "null";
            var valueStr = stableStringify(value);
            var index = defaultsHash[valueStr];
            if (index === void 0) {
              index = defaultsHash[valueStr] = defaults.length;
              defaults[index] = value;
            }
            return "default" + index;
        }
      }
      function useCustomRule(rule, schema3, parentSchema, it2) {
        if (self2._opts.validateSchema !== false) {
          var deps = rule.definition.dependencies;
          if (deps && !deps.every(function(keyword) {
            return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
          }))
            throw new Error("parent schema must have all required keywords: " + deps.join(","));
          var validateSchema = rule.definition.validateSchema;
          if (validateSchema) {
            var valid = validateSchema(schema3);
            if (!valid) {
              var message = "keyword schema is invalid: " + self2.errorsText(validateSchema.errors);
              if (self2._opts.validateSchema == "log") self2.logger.error(message);
              else throw new Error(message);
            }
          }
        }
        var compile2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
        var validate2;
        if (compile2) {
          validate2 = compile2.call(self2, schema3, parentSchema, it2);
        } else if (macro) {
          validate2 = macro.call(self2, schema3, parentSchema, it2);
          if (opts.validateSchema !== false) self2.validateSchema(validate2, true);
        } else if (inline) {
          validate2 = inline.call(self2, it2, rule.keyword, schema3, parentSchema);
        } else {
          validate2 = rule.definition.validate;
          if (!validate2) return;
        }
        if (validate2 === void 0)
          throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
        var index = customRules.length;
        customRules[index] = validate2;
        return {
          code: "customRule" + index,
          validate: validate2
        };
      }
    }
    function checkCompiling(schema2, root, baseId) {
      var index = compIndex.call(this, schema2, root, baseId);
      if (index >= 0) return { index, compiling: true };
      index = this._compilations.length;
      this._compilations[index] = {
        schema: schema2,
        root,
        baseId
      };
      return { index, compiling: false };
    }
    function endCompiling(schema2, root, baseId) {
      var i = compIndex.call(this, schema2, root, baseId);
      if (i >= 0) this._compilations.splice(i, 1);
    }
    function compIndex(schema2, root, baseId) {
      for (var i = 0; i < this._compilations.length; i++) {
        var c = this._compilations[i];
        if (c.schema == schema2 && c.root == root && c.baseId == baseId) return i;
      }
      return -1;
    }
    function patternCode(i, patterns) {
      return "var pattern" + i + " = new RegExp(" + util.toQuotedString(patterns[i]) + ");";
    }
    function defaultCode(i) {
      return "var default" + i + " = defaults[" + i + "];";
    }
    function refValCode(i, refVal) {
      return refVal[i] === void 0 ? "" : "var refVal" + i + " = refVal[" + i + "];";
    }
    function customRuleCode(i) {
      return "var customRule" + i + " = customRules[" + i + "];";
    }
    function vars(arr, statement) {
      if (!arr.length) return "";
      var code = "";
      for (var i = 0; i < arr.length; i++)
        code += statement(i, arr);
      return code;
    }
  }
});

// node_modules/ajv/lib/cache.js
var require_cache = __commonJS({
  "node_modules/ajv/lib/cache.js"(exports2, module2) {
    "use strict";
    var Cache = module2.exports = function Cache2() {
      this._cache = {};
    };
    Cache.prototype.put = function Cache_put(key, value) {
      this._cache[key] = value;
    };
    Cache.prototype.get = function Cache_get(key) {
      return this._cache[key];
    };
    Cache.prototype.del = function Cache_del(key) {
      delete this._cache[key];
    };
    Cache.prototype.clear = function Cache_clear() {
      this._cache = {};
    };
  }
});

// node_modules/ajv/lib/compile/formats.js
var require_formats2 = __commonJS({
  "node_modules/ajv/lib/compile/formats.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
    var URL2 = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
    var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
    var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
    var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
    var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
    module2.exports = formats;
    function formats(mode) {
      mode = mode == "full" ? "full" : "fast";
      return util.copy(formats[mode]);
    }
    formats.fast = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
      "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      "uri-template": URITEMPLATE,
      url: URL2,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
      hostname: HOSTNAME,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: UUID,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": JSON_POINTER,
      "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    formats.full = {
      date,
      time,
      "date-time": date_time,
      uri,
      "uri-reference": URIREF,
      "uri-template": URITEMPLATE,
      url: URL2,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: HOSTNAME,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      uuid: UUID,
      "json-pointer": JSON_POINTER,
      "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function date(str) {
      var matches = str.match(DATE);
      if (!matches) return false;
      var year = +matches[1];
      var month = +matches[2];
      var day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function time(str, full) {
      var matches = str.match(TIME);
      if (!matches) return false;
      var hour = matches[1];
      var minute = matches[2];
      var second = matches[3];
      var timeZone = matches[5];
      return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      var dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str)) return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// node_modules/ajv/lib/dotjs/ref.js
var require_ref = __commonJS({
  "node_modules/ajv/lib/dotjs/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_ref(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $async, $refCode;
      if ($schema == "#" || $schema == "#/") {
        if (it2.isRoot) {
          $async = it2.async;
          $refCode = "validate";
        } else {
          $async = it2.root.schema.$async === true;
          $refCode = "root.refVal[0]";
        }
      } else {
        var $refVal = it2.resolveRef(it2.baseId, $schema, it2.isRoot);
        if ($refVal === void 0) {
          var $message = it2.MissingRefError.message(it2.baseId, $schema);
          if (it2.opts.missingRefs == "fail") {
            it2.logger.error($message);
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it2.createErrors !== false) {
              out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it2.util.escapeQuotes($schema) + "' } ";
              if (it2.opts.messages !== false) {
                out += " , message: 'can\\'t resolve reference " + it2.util.escapeQuotes($schema) + "' ";
              }
              if (it2.opts.verbose) {
                out += " , schema: " + it2.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it2.compositeRule && $breakOnError) {
              if (it2.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            if ($breakOnError) {
              out += " if (false) { ";
            }
          } else if (it2.opts.missingRefs == "ignore") {
            it2.logger.warn($message);
            if ($breakOnError) {
              out += " if (true) { ";
            }
          } else {
            throw new it2.MissingRefError(it2.baseId, $schema, $message);
          }
        } else if ($refVal.inline) {
          var $it = it2.util.copy(it2);
          $it.level++;
          var $nextValid = "valid" + $it.level;
          $it.schema = $refVal.schema;
          $it.schemaPath = "";
          $it.errSchemaPath = $schema;
          var $code = it2.validate($it).replace(/validate\.schema/g, $refVal.code);
          out += " " + $code + " ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
          }
        } else {
          $async = $refVal.$async === true || it2.async && $refVal.$async !== false;
          $refCode = $refVal.code;
        }
      }
      if ($refCode) {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it2.opts.passContext) {
          out += " " + $refCode + ".call(this, ";
        } else {
          out += " " + $refCode + "( ";
        }
        out += " " + $data + ", (dataPath || '')";
        if (it2.errorPath != '""') {
          out += " + " + it2.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it2.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
        var __callValidate = out;
        out = $$outStack.pop();
        if ($async) {
          if (!it2.async) throw new Error("async schema referenced by sync schema");
          if ($breakOnError) {
            out += " var " + $valid + "; ";
          }
          out += " try { await " + __callValidate + "; ";
          if ($breakOnError) {
            out += " " + $valid + " = true; ";
          }
          out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
          if ($breakOnError) {
            out += " " + $valid + " = false; ";
          }
          out += " } ";
          if ($breakOnError) {
            out += " if (" + $valid + ") { ";
          }
        } else {
          out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
          if ($breakOnError) {
            out += " else { ";
          }
        }
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/allOf.js
var require_allOf = __commonJS({
  "node_modules/ajv/lib/dotjs/allOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_allOf(it2, $keyword, $ruleType) {
      var out = " ";
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $it = it2.util.copy(it2);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
            $allSchemasEmpty = false;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it2.validate($it) + " ";
            $it.baseId = $currentBaseId;
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($breakOnError) {
        if ($allSchemasEmpty) {
          out += " if (true) { ";
        } else {
          out += " " + $closingBraces.slice(0, -1) + " ";
        }
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/ajv/lib/dotjs/anyOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_anyOf(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it2.util.copy(it2);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $noEmptySchema = $schema.every(function($sch2) {
        return it2.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it2.util.schemaHasRules($sch2, it2.RULES.all);
      });
      if ($noEmptySchema) {
        var $currentBaseId = $it.baseId;
        out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
        var $wasComposite = it2.compositeRule;
        it2.compositeRule = $it.compositeRule = true;
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it2.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
            $closingBraces += "}";
          }
        }
        it2.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
        if (it2.createErrors !== false) {
          out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it2.opts.messages !== false) {
            out += " , message: 'should match some schema in anyOf' ";
          }
          if (it2.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it2.opts.allErrors) {
          out += " } ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/comment.js
var require_comment = __commonJS({
  "node_modules/ajv/lib/dotjs/comment.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_comment(it2, $keyword, $ruleType) {
      var out = " ";
      var $schema = it2.schema[$keyword];
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $comment = it2.util.toQuotedString($schema);
      if (it2.opts.$comment === true) {
        out += " console.log(" + $comment + ");";
      } else if (typeof it2.opts.$comment == "function") {
        out += " self._opts.$comment(" + $comment + ", " + it2.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/const.js
var require_const = __commonJS({
  "node_modules/ajv/lib/dotjs/const.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_const(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!$isData) {
        out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.createErrors !== false) {
        out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
        if (it2.opts.messages !== false) {
          out += " , message: 'should be equal to constant' ";
        }
        if (it2.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/contains.js
var require_contains = __commonJS({
  "node_modules/ajv/lib/dotjs/contains.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_contains(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it2.util.copy(it2);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it2.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it2.baseId, $nonEmptySchema = it2.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it2.util.schemaHasRules($schema, it2.RULES.all);
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($nonEmptySchema) {
        var $wasComposite = it2.compositeRule;
        it2.compositeRule = $it.compositeRule = true;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it2.util.getPathExpr(it2.errorPath, $idx, it2.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it2.validate($it);
        $it.baseId = $currentBaseId;
        if (it2.util.varOccurences($code, $nextData) < 2) {
          out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        out += " if (" + $nextValid + ") break; }  ";
        it2.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $nextValid + ") {";
      } else {
        out += " if (" + $data + ".length == 0) {";
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.createErrors !== false) {
        out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it2.opts.messages !== false) {
          out += " , message: 'should contain a valid item' ";
        }
        if (it2.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else { ";
      if ($nonEmptySchema) {
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      }
      if (it2.opts.allErrors) {
        out += " } ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/ajv/lib/dotjs/dependencies.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_dependencies(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it2.util.copy(it2);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it2.opts.ownProperties;
      for ($property in $schema) {
        if ($property == "__proto__") continue;
        var $sch = $schema[$property];
        var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
        $deps[$property] = $sch;
      }
      out += "var " + $errs + " = errors;";
      var $currentErrorPath = it2.errorPath;
      out += "var missing" + $lvl + ";";
      for (var $property in $propertyDeps) {
        $deps = $propertyDeps[$property];
        if ($deps.length) {
          out += " if ( " + $data + it2.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($property) + "') ";
          }
          if ($breakOnError) {
            out += " && ( ";
            var arr1 = $deps;
            if (arr1) {
              var $propertyKey, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $propertyKey = arr1[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it2.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it2.util.toQuotedString(it2.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ")) {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it2.opts._errorDataPathProperty) {
              it2.errorPath = it2.opts.jsonPointers ? it2.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it2.createErrors !== false) {
              out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it2.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it2.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
              if (it2.opts.messages !== false) {
                out += " , message: 'should have ";
                if ($deps.length == 1) {
                  out += "property " + it2.util.escapeQuotes($deps[0]);
                } else {
                  out += "properties " + it2.util.escapeQuotes($deps.join(", "));
                }
                out += " when property " + it2.util.escapeQuotes($property) + " is present' ";
              }
              if (it2.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it2.compositeRule && $breakOnError) {
              if (it2.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          } else {
            out += " ) { ";
            var arr2 = $deps;
            if (arr2) {
              var $propertyKey, i2 = -1, l2 = arr2.length - 1;
              while (i2 < l2) {
                $propertyKey = arr2[i2 += 1];
                var $prop = it2.util.getProperty($propertyKey), $missingProperty = it2.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it2.opts._errorDataPathProperty) {
                  it2.errorPath = it2.util.getPath($currentErrorPath, $propertyKey, it2.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it2.createErrors !== false) {
                  out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it2.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it2.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                  if (it2.opts.messages !== false) {
                    out += " , message: 'should have ";
                    if ($deps.length == 1) {
                      out += "property " + it2.util.escapeQuotes($deps[0]);
                    } else {
                      out += "properties " + it2.util.escapeQuotes($deps.join(", "));
                    }
                    out += " when property " + it2.util.escapeQuotes($property) + " is present' ";
                  }
                  if (it2.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
          out += " }   ";
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
      }
      it2.errorPath = $currentErrorPath;
      var $currentBaseId = $it.baseId;
      for (var $property in $schemaDeps) {
        var $sch = $schemaDeps[$property];
        if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
          out += " " + $nextValid + " = true; if ( " + $data + it2.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($property) + "') ";
          }
          out += ") { ";
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + it2.util.getProperty($property);
          $it.errSchemaPath = $errSchemaPath + "/" + it2.util.escapeFragment($property);
          out += "  " + it2.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
      if ($breakOnError) {
        out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/enum.js
var require_enum = __commonJS({
  "node_modules/ajv/lib/dotjs/enum.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_enum(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
      if (!$isData) {
        out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + ";";
      if ($isData) {
        out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
      }
      out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
      if ($isData) {
        out += "  }  ";
      }
      out += " if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.createErrors !== false) {
        out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
        if (it2.opts.messages !== false) {
          out += " , message: 'should be equal to one of the allowed values' ";
        }
        if (it2.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/format.js
var require_format2 = __commonJS({
  "node_modules/ajv/lib/dotjs/format.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_format(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      if (it2.opts.format === false) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      }
      var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $unknownFormats = it2.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
      if ($isData) {
        var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
        out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
        if (it2.async) {
          out += " var async" + $lvl + " = " + $format + ".async; ";
        }
        out += " " + $format + " = " + $format + ".validate; } if (  ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
        }
        out += " (";
        if ($unknownFormats != "ignore") {
          out += " (" + $schemaValue + " && !" + $format + " ";
          if ($allowUnknown) {
            out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
          }
          out += ") || ";
        }
        out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
        if (it2.async) {
          out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
        } else {
          out += " " + $format + "(" + $data + ") ";
        }
        out += " : " + $format + ".test(" + $data + "))))) {";
      } else {
        var $format = it2.formats[$schema];
        if (!$format) {
          if ($unknownFormats == "ignore") {
            it2.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it2.errSchemaPath + '"');
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else {
            throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it2.errSchemaPath + '"');
          }
        }
        var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
        var $formatType = $isObject && $format.type || "string";
        if ($isObject) {
          var $async = $format.async === true;
          $format = $format.validate;
        }
        if ($formatType != $ruleType) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        }
        if ($async) {
          if (!it2.async) throw new Error("async format in sync schema");
          var $formatRef = "formats" + it2.util.getProperty($schema) + ".validate";
          out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
        } else {
          out += " if (! ";
          var $formatRef = "formats" + it2.util.getProperty($schema);
          if ($isObject) $formatRef += ".validate";
          if (typeof $format == "function") {
            out += " " + $formatRef + "(" + $data + ") ";
          } else {
            out += " " + $formatRef + ".test(" + $data + ") ";
          }
          out += ") { ";
        }
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.createErrors !== false) {
        out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it2.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it2.opts.messages !== false) {
          out += ` , message: 'should match format "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it2.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it2.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it2.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/if.js
var require_if = __commonJS({
  "node_modules/ajv/lib/dotjs/if.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_if(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it2.util.copy(it2);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $thenSch = it2.schema["then"], $elseSch = it2.schema["else"], $thenPresent = $thenSch !== void 0 && (it2.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it2.util.schemaHasRules($thenSch, it2.RULES.all)), $elsePresent = $elseSch !== void 0 && (it2.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it2.util.schemaHasRules($elseSch, it2.RULES.all)), $currentBaseId = $it.baseId;
      if ($thenPresent || $elsePresent) {
        var $ifClause;
        $it.createErrors = false;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
        var $wasComposite = it2.compositeRule;
        it2.compositeRule = $it.compositeRule = true;
        out += "  " + it2.validate($it) + " ";
        $it.baseId = $currentBaseId;
        $it.createErrors = true;
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
        it2.compositeRule = $it.compositeRule = $wasComposite;
        if ($thenPresent) {
          out += " if (" + $nextValid + ") {  ";
          $it.schema = it2.schema["then"];
          $it.schemaPath = it2.schemaPath + ".then";
          $it.errSchemaPath = it2.errSchemaPath + "/then";
          out += "  " + it2.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $nextValid + "; ";
          if ($thenPresent && $elsePresent) {
            $ifClause = "ifClause" + $lvl;
            out += " var " + $ifClause + " = 'then'; ";
          } else {
            $ifClause = "'then'";
          }
          out += " } ";
          if ($elsePresent) {
            out += " else { ";
          }
        } else {
          out += " if (!" + $nextValid + ") { ";
        }
        if ($elsePresent) {
          $it.schema = it2.schema["else"];
          $it.schemaPath = it2.schemaPath + ".else";
          $it.errSchemaPath = it2.errSchemaPath + "/else";
          out += "  " + it2.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $nextValid + "; ";
          if ($thenPresent && $elsePresent) {
            $ifClause = "ifClause" + $lvl;
            out += " var " + $ifClause + " = 'else'; ";
          } else {
            $ifClause = "'else'";
          }
          out += " } ";
        }
        out += " if (!" + $valid + ") {   var err =   ";
        if (it2.createErrors !== false) {
          out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
          if (it2.opts.messages !== false) {
            out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
          }
          if (it2.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += " }   ";
        if ($breakOnError) {
          out += " else { ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/items.js
var require_items = __commonJS({
  "node_modules/ajv/lib/dotjs/items.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_items(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it2.util.copy(it2);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it2.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it2.baseId;
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if (Array.isArray($schema)) {
        var $additionalItems = it2.schema.additionalItems;
        if ($additionalItems === false) {
          out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it2.errSchemaPath + "/additionalItems";
          out += "  if (!" + $valid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it2.createErrors !== false) {
            out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ";
            if (it2.opts.messages !== false) {
              out += " , message: 'should NOT have more than " + $schema.length + " items' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } ";
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
              out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
              var $passData = $data + "[" + $i + "]";
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + "[" + $i + "]";
              $it.errSchemaPath = $errSchemaPath + "/" + $i;
              $it.errorPath = it2.util.getPathExpr(it2.errorPath, $i, it2.opts.jsonPointers, true);
              $it.dataPathArr[$dataNxt] = $i;
              var $code = it2.validate($it);
              $it.baseId = $currentBaseId;
              if (it2.util.varOccurences($code, $nextData) < 2) {
                out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
        if (typeof $additionalItems == "object" && (it2.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it2.util.schemaHasRules($additionalItems, it2.RULES.all))) {
          $it.schema = $additionalItems;
          $it.schemaPath = it2.schemaPath + ".additionalItems";
          $it.errSchemaPath = it2.errSchemaPath + "/additionalItems";
          out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
          $it.errorPath = it2.util.getPathExpr(it2.errorPath, $idx, it2.opts.jsonPointers, true);
          var $passData = $data + "[" + $idx + "]";
          $it.dataPathArr[$dataNxt] = $idx;
          var $code = it2.validate($it);
          $it.baseId = $currentBaseId;
          if (it2.util.varOccurences($code, $nextData) < 2) {
            out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          if ($breakOnError) {
            out += " if (!" + $nextValid + ") break; ";
          }
          out += " } }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      } else if (it2.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it2.util.schemaHasRules($schema, it2.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += "  for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it2.util.getPathExpr(it2.errorPath, $idx, it2.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it2.validate($it);
        $it.baseId = $currentBaseId;
        if (it2.util.varOccurences($code, $nextData) < 2) {
          out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        if ($breakOnError) {
          out += " if (!" + $nextValid + ") break; ";
        }
        out += " }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/_limit.js
var require_limit = __commonJS({
  "node_modules/ajv/lib/dotjs/_limit.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limit(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it2.schema[$exclusiveKeyword], $isDataExcl = it2.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
      if (!($isData || typeof $schema == "number" || $schema === void 0)) {
        throw new Error($keyword + " must be number");
      }
      if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
        throw new Error($exclusiveKeyword + " must be number or boolean");
      }
      if ($isDataExcl) {
        var $schemaValueExcl = it2.util.getData($schemaExcl.$data, $dataLvl, it2.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
        out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
        $schemaValueExcl = "schemaExcl" + $lvl;
        out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
        var $errorKeyword = $exclusiveKeyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it2.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it2.opts.messages !== false) {
            out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
          }
          if (it2.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
        if ($schema === void 0) {
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it2.errSchemaPath + "/" + $exclusiveKeyword;
          $schemaValue = $schemaValueExcl;
          $isData = $isDataExcl;
        }
      } else {
        var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
        if ($exclIsNumber && $isData) {
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
        } else {
          if ($exclIsNumber && $schema === void 0) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it2.errSchemaPath + "/" + $exclusiveKeyword;
            $schemaValue = $schemaExcl;
            $notOp += "=";
          } else {
            if ($exclIsNumber) $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema);
            if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
              $exclusive = true;
              $errorKeyword = $exclusiveKeyword;
              $errSchemaPath = it2.errSchemaPath + "/" + $exclusiveKeyword;
              $notOp += "=";
            } else {
              $exclusive = false;
              $opStr += "=";
            }
          }
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
        }
      }
      $errorKeyword = $errorKeyword || $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
        if (it2.opts.messages !== false) {
          out += " , message: 'should be " + $opStr + " ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it2.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/_limitItems.js
var require_limitItems = __commonJS({
  "node_modules/ajv/lib/dotjs/_limitItems.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limitItems(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxItems" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it2.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxItems") {
            out += "more";
          } else {
            out += "fewer";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " items' ";
        }
        if (it2.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/_limitLength.js
var require_limitLength = __commonJS({
  "node_modules/ajv/lib/dotjs/_limitLength.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limitLength(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxLength" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      if (it2.opts.unicode === false) {
        out += " " + $data + ".length ";
      } else {
        out += " ucs2length(" + $data + ") ";
      }
      out += " " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it2.opts.messages !== false) {
          out += " , message: 'should NOT be ";
          if ($keyword == "maxLength") {
            out += "longer";
          } else {
            out += "shorter";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " characters' ";
        }
        if (it2.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/_limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/ajv/lib/dotjs/_limitProperties.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limitProperties(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxProperties" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it2.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxProperties") {
            out += "more";
          } else {
            out += "fewer";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " properties' ";
        }
        if (it2.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/ajv/lib/dotjs/multipleOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_multipleOf(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      out += "var division" + $lvl + ";if (";
      if ($isData) {
        out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
      }
      out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
      if (it2.opts.multipleOfPrecision) {
        out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it2.opts.multipleOfPrecision + " ";
      } else {
        out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
      }
      out += " ) ";
      if ($isData) {
        out += "  )  ";
      }
      out += " ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.createErrors !== false) {
        out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
        if (it2.opts.messages !== false) {
          out += " , message: 'should be multiple of ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it2.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/not.js
var require_not = __commonJS({
  "node_modules/ajv/lib/dotjs/not.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_not(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it2.util.copy(it2);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      if (it2.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it2.util.schemaHasRules($schema, it2.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors;  ";
        var $wasComposite = it2.compositeRule;
        it2.compositeRule = $it.compositeRule = true;
        $it.createErrors = false;
        var $allErrorsOption;
        if ($it.opts.allErrors) {
          $allErrorsOption = $it.opts.allErrors;
          $it.opts.allErrors = false;
        }
        out += " " + it2.validate($it) + " ";
        $it.createErrors = true;
        if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
        it2.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (" + $nextValid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it2.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it2.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it2.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it2.opts.allErrors) {
          out += " } ";
        }
      } else {
        out += "  var err =   ";
        if (it2.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it2.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it2.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if ($breakOnError) {
          out += " if (false) { ";
        }
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/ajv/lib/dotjs/oneOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_oneOf(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it2.util.copy(it2);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
      out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
      var $wasComposite = it2.compositeRule;
      it2.compositeRule = $it.compositeRule = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it2.validate($it) + " ";
            $it.baseId = $currentBaseId;
          } else {
            out += " var " + $nextValid + " = true; ";
          }
          if ($i) {
            out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
            $closingBraces += "}";
          }
          out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
        }
      }
      it2.compositeRule = $it.compositeRule = $wasComposite;
      out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
      if (it2.createErrors !== false) {
        out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
        if (it2.opts.messages !== false) {
          out += " , message: 'should match exactly one schema in oneOf' ";
        }
        if (it2.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
      if (it2.opts.allErrors) {
        out += " } ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/pattern.js
var require_pattern = __commonJS({
  "node_modules/ajv/lib/dotjs/pattern.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_pattern(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it2.usePattern($schema);
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
      }
      out += " !" + $regexp + ".test(" + $data + ") ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.createErrors !== false) {
        out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it2.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it2.opts.messages !== false) {
          out += ` , message: 'should match pattern "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it2.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it2.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it2.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/properties.js
var require_properties = __commonJS({
  "node_modules/ajv/lib/dotjs/properties.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_properties(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it2.util.copy(it2);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it2.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
      var $schemaKeys = Object.keys($schema || {}).filter(notProto), $pProperties = it2.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it2.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it2.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it2.opts.ownProperties, $currentBaseId = it2.baseId;
      var $required = it2.schema.required;
      if ($required && !(it2.opts.$data && $required.$data) && $required.length < it2.opts.loopRequired) {
        var $requiredHash = it2.util.toHash($required);
      }
      function notProto(p) {
        return p !== "__proto__";
      }
      out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
      if ($ownProperties) {
        out += " var " + $dataProperties + " = undefined;";
      }
      if ($checkAdditional) {
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        if ($someProperties) {
          out += " var isAdditional" + $lvl + " = !(false ";
          if ($schemaKeys.length) {
            if ($schemaKeys.length > 8) {
              out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
            } else {
              var arr1 = $schemaKeys;
              if (arr1) {
                var $propertyKey, i1 = -1, l1 = arr1.length - 1;
                while (i1 < l1) {
                  $propertyKey = arr1[i1 += 1];
                  out += " || " + $key + " == " + it2.util.toQuotedString($propertyKey) + " ";
                }
              }
            }
          }
          if ($pPropertyKeys.length) {
            var arr2 = $pPropertyKeys;
            if (arr2) {
              var $pProperty, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $pProperty = arr2[$i += 1];
                out += " || " + it2.usePattern($pProperty) + ".test(" + $key + ") ";
              }
            }
          }
          out += " ); if (isAdditional" + $lvl + ") { ";
        }
        if ($removeAdditional == "all") {
          out += " delete " + $data + "[" + $key + "]; ";
        } else {
          var $currentErrorPath = it2.errorPath;
          var $additionalProperty = "' + " + $key + " + '";
          if (it2.opts._errorDataPathProperty) {
            it2.errorPath = it2.util.getPathExpr(it2.errorPath, $key, it2.opts.jsonPointers);
          }
          if ($noAdditional) {
            if ($removeAdditional) {
              out += " delete " + $data + "[" + $key + "]; ";
            } else {
              out += " " + $nextValid + " = false; ";
              var $currErrSchemaPath = $errSchemaPath;
              $errSchemaPath = it2.errSchemaPath + "/additionalProperties";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it2.createErrors !== false) {
                out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
                if (it2.opts.messages !== false) {
                  out += " , message: '";
                  if (it2.opts._errorDataPathProperty) {
                    out += "is an invalid additional property";
                  } else {
                    out += "should NOT have additional properties";
                  }
                  out += "' ";
                }
                if (it2.opts.verbose) {
                  out += " , schema: false , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it2.compositeRule && $breakOnError) {
                if (it2.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              $errSchemaPath = $currErrSchemaPath;
              if ($breakOnError) {
                out += " break; ";
              }
            }
          } else if ($additionalIsSchema) {
            if ($removeAdditional == "failing") {
              out += " var " + $errs + " = errors;  ";
              var $wasComposite = it2.compositeRule;
              it2.compositeRule = $it.compositeRule = true;
              $it.schema = $aProperties;
              $it.schemaPath = it2.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it2.errSchemaPath + "/additionalProperties";
              $it.errorPath = it2.opts._errorDataPathProperty ? it2.errorPath : it2.util.getPathExpr(it2.errorPath, $key, it2.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it2.validate($it);
              $it.baseId = $currentBaseId;
              if (it2.util.varOccurences($code, $nextData) < 2) {
                out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
              it2.compositeRule = $it.compositeRule = $wasComposite;
            } else {
              $it.schema = $aProperties;
              $it.schemaPath = it2.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it2.errSchemaPath + "/additionalProperties";
              $it.errorPath = it2.opts._errorDataPathProperty ? it2.errorPath : it2.util.getPathExpr(it2.errorPath, $key, it2.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it2.validate($it);
              $it.baseId = $currentBaseId;
              if (it2.util.varOccurences($code, $nextData) < 2) {
                out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
            }
          }
          it2.errorPath = $currentErrorPath;
        }
        if ($someProperties) {
          out += " } ";
        }
        out += " }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
      var $useDefaults = it2.opts.useDefaults && !it2.compositeRule;
      if ($schemaKeys.length) {
        var arr3 = $schemaKeys;
        if (arr3) {
          var $propertyKey, i3 = -1, l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $sch = $schema[$propertyKey];
            if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
              var $prop = it2.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + $prop;
              $it.errSchemaPath = $errSchemaPath + "/" + it2.util.escapeFragment($propertyKey);
              $it.errorPath = it2.util.getPath(it2.errorPath, $propertyKey, it2.opts.jsonPointers);
              $it.dataPathArr[$dataNxt] = it2.util.toQuotedString($propertyKey);
              var $code = it2.validate($it);
              $it.baseId = $currentBaseId;
              if (it2.util.varOccurences($code, $nextData) < 2) {
                $code = it2.util.varReplace($code, $nextData, $passData);
                var $useData = $passData;
              } else {
                var $useData = $nextData;
                out += " var " + $nextData + " = " + $passData + "; ";
              }
              if ($hasDefault) {
                out += " " + $code + " ";
              } else {
                if ($requiredHash && $requiredHash[$propertyKey]) {
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") { " + $nextValid + " = false; ";
                  var $currentErrorPath = it2.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it2.util.escapeQuotes($propertyKey);
                  if (it2.opts._errorDataPathProperty) {
                    it2.errorPath = it2.util.getPath($currentErrorPath, $propertyKey, it2.opts.jsonPointers);
                  }
                  $errSchemaPath = it2.errSchemaPath + "/required";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it2.createErrors !== false) {
                    out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                    if (it2.opts.messages !== false) {
                      out += " , message: '";
                      if (it2.opts._errorDataPathProperty) {
                        out += "is a required property";
                      } else {
                        out += "should have required property \\'" + $missingProperty + "\\'";
                      }
                      out += "' ";
                    }
                    if (it2.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it2.compositeRule && $breakOnError) {
                    if (it2.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  $errSchemaPath = $currErrSchemaPath;
                  it2.errorPath = $currentErrorPath;
                  out += " } else { ";
                } else {
                  if ($breakOnError) {
                    out += " if ( " + $useData + " === undefined ";
                    if ($ownProperties) {
                      out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += ") { " + $nextValid + " = true; } else { ";
                  } else {
                    out += " if (" + $useData + " !== undefined ";
                    if ($ownProperties) {
                      out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += " ) { ";
                  }
                }
                out += " " + $code + " } ";
              }
            }
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr4 = $pPropertyKeys;
        if (arr4) {
          var $pProperty, i4 = -1, l4 = arr4.length - 1;
          while (i4 < l4) {
            $pProperty = arr4[i4 += 1];
            var $sch = $pProperties[$pProperty];
            if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
              $it.schema = $sch;
              $it.schemaPath = it2.schemaPath + ".patternProperties" + it2.util.getProperty($pProperty);
              $it.errSchemaPath = it2.errSchemaPath + "/patternProperties/" + it2.util.escapeFragment($pProperty);
              if ($ownProperties) {
                out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
              } else {
                out += " for (var " + $key + " in " + $data + ") { ";
              }
              out += " if (" + it2.usePattern($pProperty) + ".test(" + $key + ")) { ";
              $it.errorPath = it2.util.getPathExpr(it2.errorPath, $key, it2.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it2.validate($it);
              $it.baseId = $currentBaseId;
              if (it2.util.varOccurences($code, $nextData) < 2) {
                out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
              out += " } ";
              if ($breakOnError) {
                out += " else " + $nextValid + " = true; ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/ajv/lib/dotjs/propertyNames.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_propertyNames(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it2.util.copy(it2);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      out += "var " + $errs + " = errors;";
      if (it2.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it2.util.schemaHasRules($schema, it2.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it2.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it2.opts.ownProperties, $currentBaseId = it2.baseId;
        if ($ownProperties) {
          out += " var " + $dataProperties + " = undefined; ";
        }
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        out += " var startErrs" + $lvl + " = errors; ";
        var $passData = $key;
        var $wasComposite = it2.compositeRule;
        it2.compositeRule = $it.compositeRule = true;
        var $code = it2.validate($it);
        $it.baseId = $currentBaseId;
        if (it2.util.varOccurences($code, $nextData) < 2) {
          out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        it2.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
        if (it2.createErrors !== false) {
          out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
          if (it2.opts.messages !== false) {
            out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
          }
          if (it2.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        if ($breakOnError) {
          out += " break; ";
        }
        out += " } }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/required.js
var require_required = __commonJS({
  "node_modules/ajv/lib/dotjs/required.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_required(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $vSchema = "schema" + $lvl;
      if (!$isData) {
        if ($schema.length < it2.opts.loopRequired && it2.schema.properties && Object.keys(it2.schema.properties).length) {
          var $required = [];
          var arr1 = $schema;
          if (arr1) {
            var $property, i1 = -1, l1 = arr1.length - 1;
            while (i1 < l1) {
              $property = arr1[i1 += 1];
              var $propertySch = it2.schema.properties[$property];
              if (!($propertySch && (it2.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it2.util.schemaHasRules($propertySch, it2.RULES.all)))) {
                $required[$required.length] = $property;
              }
            }
          }
        } else {
          var $required = $schema;
        }
      }
      if ($isData || $required.length) {
        var $currentErrorPath = it2.errorPath, $loopRequired = $isData || $required.length >= it2.opts.loopRequired, $ownProperties = it2.opts.ownProperties;
        if ($breakOnError) {
          out += " var missing" + $lvl + "; ";
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it2.opts._errorDataPathProperty) {
              it2.errorPath = it2.util.getPathExpr($currentErrorPath, $propertyPath, it2.opts.jsonPointers);
            }
            out += " var " + $valid + " = true; ";
            if ($isData) {
              out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
            if ($ownProperties) {
              out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += "; if (!" + $valid + ") break; } ";
            if ($isData) {
              out += "  }  ";
            }
            out += "  if (!" + $valid + ") {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it2.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it2.opts.messages !== false) {
                out += " , message: '";
                if (it2.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it2.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it2.compositeRule && $breakOnError) {
              if (it2.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          } else {
            out += " if ( ";
            var arr2 = $required;
            if (arr2) {
              var $propertyKey, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $propertyKey = arr2[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it2.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it2.util.toQuotedString(it2.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ") {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it2.opts._errorDataPathProperty) {
              it2.errorPath = it2.opts.jsonPointers ? it2.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it2.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it2.opts.messages !== false) {
                out += " , message: '";
                if (it2.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it2.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it2.compositeRule && $breakOnError) {
              if (it2.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          }
        } else {
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it2.opts._errorDataPathProperty) {
              it2.errorPath = it2.util.getPathExpr($currentErrorPath, $propertyPath, it2.opts.jsonPointers);
            }
            if ($isData) {
              out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
              if (it2.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it2.opts.messages !== false) {
                  out += " , message: '";
                  if (it2.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it2.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += ") {  var err =   ";
            if (it2.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it2.opts.messages !== false) {
                out += " , message: '";
                if (it2.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it2.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
            if ($isData) {
              out += "  }  ";
            }
          } else {
            var arr3 = $required;
            if (arr3) {
              var $propertyKey, i3 = -1, l3 = arr3.length - 1;
              while (i3 < l3) {
                $propertyKey = arr3[i3 += 1];
                var $prop = it2.util.getProperty($propertyKey), $missingProperty = it2.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it2.opts._errorDataPathProperty) {
                  it2.errorPath = it2.util.getPath($currentErrorPath, $propertyKey, it2.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it2.createErrors !== false) {
                  out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                  if (it2.opts.messages !== false) {
                    out += " , message: '";
                    if (it2.opts._errorDataPathProperty) {
                      out += "is a required property";
                    } else {
                      out += "should have required property \\'" + $missingProperty + "\\'";
                    }
                    out += "' ";
                  }
                  if (it2.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
        }
        it2.errorPath = $currentErrorPath;
      } else if ($breakOnError) {
        out += " if (true) {";
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/ajv/lib/dotjs/uniqueItems.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_uniqueItems(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (($schema || $isData) && it2.opts.uniqueItems !== false) {
        if ($isData) {
          out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
        }
        out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
        var $itemType = it2.schema.items && it2.schema.items.type, $typeIsArray = Array.isArray($itemType);
        if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
          out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
        } else {
          out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
          var $method = "checkDataType" + ($typeIsArray ? "s" : "");
          out += " if (" + it2.util[$method]($itemType, "item", it2.opts.strictNumbers, true) + ") continue; ";
          if ($typeIsArray) {
            out += ` if (typeof item == 'string') item = '"' + item; `;
          }
          out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
        }
        out += " } ";
        if ($isData) {
          out += "  }  ";
        }
        out += " if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it2.createErrors !== false) {
          out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
          if (it2.opts.messages !== false) {
            out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
          }
          if (it2.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/dotjs/index.js
var require_dotjs = __commonJS({
  "node_modules/ajv/lib/dotjs/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "$ref": require_ref(),
      allOf: require_allOf(),
      anyOf: require_anyOf(),
      "$comment": require_comment(),
      const: require_const(),
      contains: require_contains(),
      dependencies: require_dependencies(),
      "enum": require_enum(),
      format: require_format2(),
      "if": require_if(),
      items: require_items(),
      maximum: require_limit(),
      minimum: require_limit(),
      maxItems: require_limitItems(),
      minItems: require_limitItems(),
      maxLength: require_limitLength(),
      minLength: require_limitLength(),
      maxProperties: require_limitProperties(),
      minProperties: require_limitProperties(),
      multipleOf: require_multipleOf(),
      not: require_not(),
      oneOf: require_oneOf(),
      pattern: require_pattern(),
      properties: require_properties(),
      propertyNames: require_propertyNames(),
      required: require_required(),
      uniqueItems: require_uniqueItems(),
      validate: require_validate()
    };
  }
});

// node_modules/ajv/lib/compile/rules.js
var require_rules = __commonJS({
  "node_modules/ajv/lib/compile/rules.js"(exports2, module2) {
    "use strict";
    var ruleModules = require_dotjs();
    var toHash = require_util().toHash;
    module2.exports = function rules() {
      var RULES = [
        {
          type: "number",
          rules: [
            { "maximum": ["exclusiveMaximum"] },
            { "minimum": ["exclusiveMinimum"] },
            "multipleOf",
            "format"
          ]
        },
        {
          type: "string",
          rules: ["maxLength", "minLength", "pattern", "format"]
        },
        {
          type: "array",
          rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
        },
        {
          type: "object",
          rules: [
            "maxProperties",
            "minProperties",
            "required",
            "dependencies",
            "propertyNames",
            { "properties": ["additionalProperties", "patternProperties"] }
          ]
        },
        { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
      ];
      var ALL = ["type", "$comment"];
      var KEYWORDS = [
        "$schema",
        "$id",
        "id",
        "$data",
        "$async",
        "title",
        "description",
        "default",
        "definitions",
        "examples",
        "readOnly",
        "writeOnly",
        "contentMediaType",
        "contentEncoding",
        "additionalItems",
        "then",
        "else"
      ];
      var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
      RULES.all = toHash(ALL);
      RULES.types = toHash(TYPES);
      RULES.forEach(function(group) {
        group.rules = group.rules.map(function(keyword) {
          var implKeywords;
          if (typeof keyword == "object") {
            var key = Object.keys(keyword)[0];
            implKeywords = keyword[key];
            keyword = key;
            implKeywords.forEach(function(k) {
              ALL.push(k);
              RULES.all[k] = true;
            });
          }
          ALL.push(keyword);
          var rule = RULES.all[keyword] = {
            keyword,
            code: ruleModules[keyword],
            implements: implKeywords
          };
          return rule;
        });
        RULES.all.$comment = {
          keyword: "$comment",
          code: ruleModules.$comment
        };
        if (group.type) RULES.types[group.type] = group;
      });
      RULES.keywords = toHash(ALL.concat(KEYWORDS));
      RULES.custom = {};
      return RULES;
    };
  }
});

// node_modules/ajv/lib/data.js
var require_data = __commonJS({
  "node_modules/ajv/lib/data.js"(exports2, module2) {
    "use strict";
    var KEYWORDS = [
      "multipleOf",
      "maximum",
      "exclusiveMaximum",
      "minimum",
      "exclusiveMinimum",
      "maxLength",
      "minLength",
      "pattern",
      "additionalItems",
      "maxItems",
      "minItems",
      "uniqueItems",
      "maxProperties",
      "minProperties",
      "required",
      "additionalProperties",
      "enum",
      "format",
      "const"
    ];
    module2.exports = function(metaSchema, keywordsJsonPointers) {
      for (var i = 0; i < keywordsJsonPointers.length; i++) {
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        var segments = keywordsJsonPointers[i].split("/");
        var keywords = metaSchema;
        var j;
        for (j = 1; j < segments.length; j++)
          keywords = keywords[segments[j]];
        for (j = 0; j < KEYWORDS.length; j++) {
          var key = KEYWORDS[j];
          var schema2 = keywords[key];
          if (schema2) {
            keywords[key] = {
              anyOf: [
                schema2,
                { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
              ]
            };
          }
        }
      }
      return metaSchema;
    };
  }
});

// node_modules/ajv/lib/compile/async.js
var require_async2 = __commonJS({
  "node_modules/ajv/lib/compile/async.js"(exports2, module2) {
    "use strict";
    var MissingRefError = require_error_classes().MissingRef;
    module2.exports = compileAsync;
    function compileAsync(schema2, meta, callback) {
      var self2 = this;
      if (typeof this._opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      if (typeof meta == "function") {
        callback = meta;
        meta = void 0;
      }
      var p = loadMetaSchemaOf(schema2).then(function() {
        var schemaObj = self2._addSchema(schema2, void 0, meta);
        return schemaObj.validate || _compileAsync(schemaObj);
      });
      if (callback) {
        p.then(
          function(v) {
            callback(null, v);
          },
          callback
        );
      }
      return p;
      function loadMetaSchemaOf(sch) {
        var $schema = sch.$schema;
        return $schema && !self2.getSchema($schema) ? compileAsync.call(self2, { $ref: $schema }, true) : Promise.resolve();
      }
      function _compileAsync(schemaObj) {
        try {
          return self2._compile(schemaObj);
        } catch (e) {
          if (e instanceof MissingRefError) return loadMissingSchema(e);
          throw e;
        }
        function loadMissingSchema(e) {
          var ref = e.missingSchema;
          if (added(ref)) throw new Error("Schema " + ref + " is loaded but " + e.missingRef + " cannot be resolved");
          var schemaPromise = self2._loadingSchemas[ref];
          if (!schemaPromise) {
            schemaPromise = self2._loadingSchemas[ref] = self2._opts.loadSchema(ref);
            schemaPromise.then(removePromise, removePromise);
          }
          return schemaPromise.then(function(sch) {
            if (!added(ref)) {
              return loadMetaSchemaOf(sch).then(function() {
                if (!added(ref)) self2.addSchema(sch, ref, void 0, meta);
              });
            }
          }).then(function() {
            return _compileAsync(schemaObj);
          });
          function removePromise() {
            delete self2._loadingSchemas[ref];
          }
          function added(ref2) {
            return self2._refs[ref2] || self2._schemas[ref2];
          }
        }
      }
    }
  }
});

// node_modules/ajv/lib/dotjs/custom.js
var require_custom = __commonJS({
  "node_modules/ajv/lib/dotjs/custom.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_custom(it2, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
      var $compile, $inline, $macro, $ruleValidate, $validateCode;
      if ($isData && $rDef.$data) {
        $validateCode = "keywordValidate" + $lvl;
        var $validateSchema = $rDef.validateSchema;
        out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
      } else {
        $ruleValidate = it2.useCustomRule($rule, $schema, it2.schema, it2);
        if (!$ruleValidate) return;
        $schemaValue = "validate.schema" + $schemaPath;
        $validateCode = $ruleValidate.code;
        $compile = $rDef.compile;
        $inline = $rDef.inline;
        $macro = $rDef.macro;
      }
      var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
      if ($asyncKeyword && !it2.async) throw new Error("async keyword in sync schema");
      if (!($inline || $macro)) {
        out += "" + $ruleErrs + " = null;";
      }
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($isData && $rDef.$data) {
        $closingBraces += "}";
        out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
        if ($validateSchema) {
          $closingBraces += "}";
          out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
        }
      }
      if ($inline) {
        if ($rDef.statements) {
          out += " " + $ruleValidate.validate + " ";
        } else {
          out += " " + $valid + " = " + $ruleValidate.validate + "; ";
        }
      } else if ($macro) {
        var $it = it2.util.copy(it2);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        $it.schema = $ruleValidate.validate;
        $it.schemaPath = "";
        var $wasComposite = it2.compositeRule;
        it2.compositeRule = $it.compositeRule = true;
        var $code = it2.validate($it).replace(/validate\.schema/g, $validateCode);
        it2.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $code;
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        out += "  " + $validateCode + ".call( ";
        if (it2.opts.passContext) {
          out += "this";
        } else {
          out += "self";
        }
        if ($compile || $rDef.schema === false) {
          out += " , " + $data + " ";
        } else {
          out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it2.schemaPath + " ";
        }
        out += " , (dataPath || '')";
        if (it2.errorPath != '""') {
          out += " + " + it2.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it2.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
        var def_callRuleValidate = out;
        out = $$outStack.pop();
        if ($rDef.errors === false) {
          out += " " + $valid + " = ";
          if ($asyncKeyword) {
            out += "await ";
          }
          out += "" + def_callRuleValidate + "; ";
        } else {
          if ($asyncKeyword) {
            $ruleErrs = "customErrors" + $lvl;
            out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
          } else {
            out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
          }
        }
      }
      if ($rDef.modifying) {
        out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
      }
      out += "" + $closingBraces;
      if ($rDef.valid) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      } else {
        out += " if ( ";
        if ($rDef.valid === void 0) {
          out += " !";
          if ($macro) {
            out += "" + $nextValid;
          } else {
            out += "" + $valid;
          }
        } else {
          out += " " + !$rDef.valid + " ";
        }
        out += ") { ";
        $errorKeyword = $rule.keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it2.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
          if (it2.opts.messages !== false) {
            out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
          }
          if (it2.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        var def_customError = out;
        out = $$outStack.pop();
        if ($inline) {
          if ($rDef.errors) {
            if ($rDef.errors != "full") {
              out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it2.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it2.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } ";
            }
          } else {
            if ($rDef.errors === false) {
              out += " " + def_customError + " ";
            } else {
              out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it2.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it2.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } } ";
            }
          }
        } else if ($macro) {
          out += "   var err =   ";
          if (it2.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
            if (it2.opts.messages !== false) {
              out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError(vErrors); ";
            } else {
              out += " validate.errors = vErrors; return false; ";
            }
          }
        } else {
          if ($rDef.errors === false) {
            out += " " + def_customError + " ";
          } else {
            out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it2.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
            if (it2.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } } else { " + def_customError + " } ";
          }
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      }
      return out;
    };
  }
});

// node_modules/ajv/lib/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/ajv/lib/refs/json-schema-draft-07.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [
            { $ref: "#/definitions/nonNegativeInteger" },
            { default: 0 }
          ]
        },
        simpleTypes: {
          enum: [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string"
          ]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [
            { $ref: "#" },
            { $ref: "#/definitions/schemaArray" }
          ],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [
              { $ref: "#" },
              { $ref: "#/definitions/stringArray" }
            ]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/ajv/lib/definition_schema.js
var require_definition_schema = __commonJS({
  "node_modules/ajv/lib/definition_schema.js"(exports2, module2) {
    "use strict";
    var metaSchema = require_json_schema_draft_07();
    module2.exports = {
      $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
      definitions: {
        simpleTypes: metaSchema.definitions.simpleTypes
      },
      type: "object",
      dependencies: {
        schema: ["validate"],
        $data: ["validate"],
        statements: ["inline"],
        valid: { not: { required: ["macro"] } }
      },
      properties: {
        type: metaSchema.properties.type,
        schema: { type: "boolean" },
        statements: { type: "boolean" },
        dependencies: {
          type: "array",
          items: { type: "string" }
        },
        metaSchema: { type: "object" },
        modifying: { type: "boolean" },
        valid: { type: "boolean" },
        $data: { type: "boolean" },
        async: { type: "boolean" },
        errors: {
          anyOf: [
            { type: "boolean" },
            { const: "full" }
          ]
        }
      }
    };
  }
});

// node_modules/ajv/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/ajv/lib/keyword.js"(exports2, module2) {
    "use strict";
    var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
    var customRuleCode = require_custom();
    var definitionSchema = require_definition_schema();
    module2.exports = {
      add: addKeyword,
      get: getKeyword,
      remove: removeKeyword,
      validate: validateKeyword
    };
    function addKeyword(keyword, definition) {
      var RULES = this.RULES;
      if (RULES.keywords[keyword])
        throw new Error("Keyword " + keyword + " is already defined");
      if (!IDENTIFIER.test(keyword))
        throw new Error("Keyword " + keyword + " is not a valid identifier");
      if (definition) {
        this.validateKeyword(definition, true);
        var dataType = definition.type;
        if (Array.isArray(dataType)) {
          for (var i = 0; i < dataType.length; i++)
            _addRule(keyword, dataType[i], definition);
        } else {
          _addRule(keyword, dataType, definition);
        }
        var metaSchema = definition.metaSchema;
        if (metaSchema) {
          if (definition.$data && this._opts.$data) {
            metaSchema = {
              anyOf: [
                metaSchema,
                { "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
              ]
            };
          }
          definition.validateSchema = this.compile(metaSchema, true);
        }
      }
      RULES.keywords[keyword] = RULES.all[keyword] = true;
      function _addRule(keyword2, dataType2, definition2) {
        var ruleGroup;
        for (var i2 = 0; i2 < RULES.length; i2++) {
          var rg = RULES[i2];
          if (rg.type == dataType2) {
            ruleGroup = rg;
            break;
          }
        }
        if (!ruleGroup) {
          ruleGroup = { type: dataType2, rules: [] };
          RULES.push(ruleGroup);
        }
        var rule = {
          keyword: keyword2,
          definition: definition2,
          custom: true,
          code: customRuleCode,
          implements: definition2.implements
        };
        ruleGroup.rules.push(rule);
        RULES.custom[keyword2] = rule;
      }
      return this;
    }
    function getKeyword(keyword) {
      var rule = this.RULES.custom[keyword];
      return rule ? rule.definition : this.RULES.keywords[keyword] || false;
    }
    function removeKeyword(keyword) {
      var RULES = this.RULES;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      delete RULES.custom[keyword];
      for (var i = 0; i < RULES.length; i++) {
        var rules = RULES[i].rules;
        for (var j = 0; j < rules.length; j++) {
          if (rules[j].keyword == keyword) {
            rules.splice(j, 1);
            break;
          }
        }
      }
      return this;
    }
    function validateKeyword(definition, throwError) {
      validateKeyword.errors = null;
      var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
      if (v(definition)) return true;
      validateKeyword.errors = v.errors;
      if (throwError)
        throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
      else
        return false;
    }
  }
});

// node_modules/ajv/lib/refs/data.json
var require_data2 = __commonJS({
  "node_modules/ajv/lib/refs/data.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON Schema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [
            { format: "relative-json-pointer" },
            { format: "json-pointer" }
          ]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/ajv/lib/ajv.js
var require_ajv = __commonJS({
  "node_modules/ajv/lib/ajv.js"(exports2, module2) {
    "use strict";
    var compileSchema = require_compile();
    var resolve = require_resolve2();
    var Cache = require_cache();
    var SchemaObject = require_schema_obj();
    var stableStringify = require_fast_json_stable_stringify();
    var formats = require_formats2();
    var rules = require_rules();
    var $dataMetaSchema = require_data();
    var util = require_util();
    module2.exports = Ajv;
    Ajv.prototype.validate = validate2;
    Ajv.prototype.compile = compile;
    Ajv.prototype.addSchema = addSchema;
    Ajv.prototype.addMetaSchema = addMetaSchema;
    Ajv.prototype.validateSchema = validateSchema;
    Ajv.prototype.getSchema = getSchema;
    Ajv.prototype.removeSchema = removeSchema;
    Ajv.prototype.addFormat = addFormat;
    Ajv.prototype.errorsText = errorsText;
    Ajv.prototype._addSchema = _addSchema;
    Ajv.prototype._compile = _compile;
    Ajv.prototype.compileAsync = require_async2();
    var customKeyword = require_keyword();
    Ajv.prototype.addKeyword = customKeyword.add;
    Ajv.prototype.getKeyword = customKeyword.get;
    Ajv.prototype.removeKeyword = customKeyword.remove;
    Ajv.prototype.validateKeyword = customKeyword.validate;
    var errorClasses = require_error_classes();
    Ajv.ValidationError = errorClasses.Validation;
    Ajv.MissingRefError = errorClasses.MissingRef;
    Ajv.$dataMetaSchema = $dataMetaSchema;
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
    var META_SUPPORT_DATA = ["/properties"];
    function Ajv(opts) {
      if (!(this instanceof Ajv)) return new Ajv(opts);
      opts = this._opts = util.copy(opts) || {};
      setLogger(this);
      this._schemas = {};
      this._refs = {};
      this._fragments = {};
      this._formats = formats(opts.format);
      this._cache = opts.cache || new Cache();
      this._loadingSchemas = {};
      this._compilations = [];
      this.RULES = rules();
      this._getId = chooseGetId(opts);
      opts.loopRequired = opts.loopRequired || Infinity;
      if (opts.errorDataPath == "property") opts._errorDataPathProperty = true;
      if (opts.serialize === void 0) opts.serialize = stableStringify;
      this._metaOpts = getMetaSchemaOptions(this);
      if (opts.formats) addInitialFormats(this);
      if (opts.keywords) addInitialKeywords(this);
      addDefaultMetaSchema(this);
      if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
      if (opts.nullable) this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
      addInitialSchemas(this);
    }
    function validate2(schemaKeyRef, data) {
      var v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
      } else {
        var schemaObj = this._addSchema(schemaKeyRef);
        v = schemaObj.validate || this._compile(schemaObj);
      }
      var valid = v(data);
      if (v.$async !== true) this.errors = v.errors;
      return valid;
    }
    function compile(schema2, _meta) {
      var schemaObj = this._addSchema(schema2, void 0, _meta);
      return schemaObj.validate || this._compile(schemaObj);
    }
    function addSchema(schema2, key, _skipValidation, _meta) {
      if (Array.isArray(schema2)) {
        for (var i = 0; i < schema2.length; i++) this.addSchema(schema2[i], void 0, _skipValidation, _meta);
        return this;
      }
      var id = this._getId(schema2);
      if (id !== void 0 && typeof id != "string")
        throw new Error("schema id must be string");
      key = resolve.normalizeId(key || id);
      checkUnique(this, key);
      this._schemas[key] = this._addSchema(schema2, _skipValidation, _meta, true);
      return this;
    }
    function addMetaSchema(schema2, key, skipValidation) {
      this.addSchema(schema2, key, skipValidation, true);
      return this;
    }
    function validateSchema(schema2, throwOrLogError) {
      var $schema = schema2.$schema;
      if ($schema !== void 0 && typeof $schema != "string")
        throw new Error("$schema must be a string");
      $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
      if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      var valid = this.validate($schema, schema2);
      if (!valid && throwOrLogError) {
        var message = "schema is invalid: " + this.errorsText();
        if (this._opts.validateSchema == "log") this.logger.error(message);
        else throw new Error(message);
      }
      return valid;
    }
    function defaultMeta(self2) {
      var meta = self2._opts.meta;
      self2._opts.defaultMeta = typeof meta == "object" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
      return self2._opts.defaultMeta;
    }
    function getSchema(keyRef) {
      var schemaObj = _getSchemaObj(this, keyRef);
      switch (typeof schemaObj) {
        case "object":
          return schemaObj.validate || this._compile(schemaObj);
        case "string":
          return this.getSchema(schemaObj);
        case "undefined":
          return _getSchemaFragment(this, keyRef);
      }
    }
    function _getSchemaFragment(self2, ref) {
      var res = resolve.schema.call(self2, { schema: {} }, ref);
      if (res) {
        var schema2 = res.schema, root = res.root, baseId = res.baseId;
        var v = compileSchema.call(self2, schema2, root, void 0, baseId);
        self2._fragments[ref] = new SchemaObject({
          ref,
          fragment: true,
          schema: schema2,
          root,
          baseId,
          validate: v
        });
        return v;
      }
    }
    function _getSchemaObj(self2, keyRef) {
      keyRef = resolve.normalizeId(keyRef);
      return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
    }
    function removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        _removeAllSchemas(this, this._schemas, schemaKeyRef);
        _removeAllSchemas(this, this._refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          _removeAllSchemas(this, this._schemas);
          _removeAllSchemas(this, this._refs);
          this._cache.clear();
          return this;
        case "string":
          var schemaObj = _getSchemaObj(this, schemaKeyRef);
          if (schemaObj) this._cache.del(schemaObj.cacheKey);
          delete this._schemas[schemaKeyRef];
          delete this._refs[schemaKeyRef];
          return this;
        case "object":
          var serialize = this._opts.serialize;
          var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
          this._cache.del(cacheKey);
          var id = this._getId(schemaKeyRef);
          if (id) {
            id = resolve.normalizeId(id);
            delete this._schemas[id];
            delete this._refs[id];
          }
      }
      return this;
    }
    function _removeAllSchemas(self2, schemas, regex) {
      for (var keyRef in schemas) {
        var schemaObj = schemas[keyRef];
        if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
          self2._cache.del(schemaObj.cacheKey);
          delete schemas[keyRef];
        }
      }
    }
    function _addSchema(schema2, skipValidation, meta, shouldAddSchema) {
      if (typeof schema2 != "object" && typeof schema2 != "boolean")
        throw new Error("schema should be object or boolean");
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schema2) : schema2;
      var cached = this._cache.get(cacheKey);
      if (cached) return cached;
      shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
      var id = resolve.normalizeId(this._getId(schema2));
      if (id && shouldAddSchema) checkUnique(this, id);
      var willValidate = this._opts.validateSchema !== false && !skipValidation;
      var recursiveMeta;
      if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema2.$schema)))
        this.validateSchema(schema2, true);
      var localRefs = resolve.ids.call(this, schema2);
      var schemaObj = new SchemaObject({
        id,
        schema: schema2,
        localRefs,
        cacheKey,
        meta
      });
      if (id[0] != "#" && shouldAddSchema) this._refs[id] = schemaObj;
      this._cache.put(cacheKey, schemaObj);
      if (willValidate && recursiveMeta) this.validateSchema(schema2, true);
      return schemaObj;
    }
    function _compile(schemaObj, root) {
      if (schemaObj.compiling) {
        schemaObj.validate = callValidate;
        callValidate.schema = schemaObj.schema;
        callValidate.errors = null;
        callValidate.root = root ? root : callValidate;
        if (schemaObj.schema.$async === true)
          callValidate.$async = true;
        return callValidate;
      }
      schemaObj.compiling = true;
      var currentOpts;
      if (schemaObj.meta) {
        currentOpts = this._opts;
        this._opts = this._metaOpts;
      }
      var v;
      try {
        v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
      } catch (e) {
        delete schemaObj.validate;
        throw e;
      } finally {
        schemaObj.compiling = false;
        if (schemaObj.meta) this._opts = currentOpts;
      }
      schemaObj.validate = v;
      schemaObj.refs = v.refs;
      schemaObj.refVal = v.refVal;
      schemaObj.root = v.root;
      return v;
      function callValidate() {
        var _validate = schemaObj.validate;
        var result = _validate.apply(this, arguments);
        callValidate.errors = _validate.errors;
        return result;
      }
    }
    function chooseGetId(opts) {
      switch (opts.schemaId) {
        case "auto":
          return _get$IdOrId;
        case "id":
          return _getId;
        default:
          return _get$Id;
      }
    }
    function _getId(schema2) {
      if (schema2.$id) this.logger.warn("schema $id ignored", schema2.$id);
      return schema2.id;
    }
    function _get$Id(schema2) {
      if (schema2.id) this.logger.warn("schema id ignored", schema2.id);
      return schema2.$id;
    }
    function _get$IdOrId(schema2) {
      if (schema2.$id && schema2.id && schema2.$id != schema2.id)
        throw new Error("schema $id is different from id");
      return schema2.$id || schema2.id;
    }
    function errorsText(errors, options) {
      errors = errors || this.errors;
      if (!errors) return "No errors";
      options = options || {};
      var separator = options.separator === void 0 ? ", " : options.separator;
      var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
      var text = "";
      for (var i = 0; i < errors.length; i++) {
        var e = errors[i];
        if (e) text += dataVar + e.dataPath + " " + e.message + separator;
      }
      return text.slice(0, -separator.length);
    }
    function addFormat(name, format) {
      if (typeof format == "string") format = new RegExp(format);
      this._formats[name] = format;
      return this;
    }
    function addDefaultMetaSchema(self2) {
      var $dataSchema;
      if (self2._opts.$data) {
        $dataSchema = require_data2();
        self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
      }
      if (self2._opts.meta === false) return;
      var metaSchema = require_json_schema_draft_07();
      if (self2._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
      self2.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
      self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    function addInitialSchemas(self2) {
      var optsSchemas = self2._opts.schemas;
      if (!optsSchemas) return;
      if (Array.isArray(optsSchemas)) self2.addSchema(optsSchemas);
      else for (var key in optsSchemas) self2.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats(self2) {
      for (var name in self2._opts.formats) {
        var format = self2._opts.formats[name];
        self2.addFormat(name, format);
      }
    }
    function addInitialKeywords(self2) {
      for (var name in self2._opts.keywords) {
        var keyword = self2._opts.keywords[name];
        self2.addKeyword(name, keyword);
      }
    }
    function checkUnique(self2, id) {
      if (self2._schemas[id] || self2._refs[id])
        throw new Error('schema with key or id "' + id + '" already exists');
    }
    function getMetaSchemaOptions(self2) {
      var metaOpts = util.copy(self2._opts);
      for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
        delete metaOpts[META_IGNORE_OPTIONS[i]];
      return metaOpts;
    }
    function setLogger(self2) {
      var logger = self2._opts.logger;
      if (logger === false) {
        self2.logger = { log: noop, warn: noop, error: noop };
      } else {
        if (logger === void 0) logger = console;
        if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
          throw new Error("logger must implement log, warn and error methods");
        self2.logger = logger;
      }
    }
    function noop() {
    }
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/schemaValidator.js
var require_schemaValidator = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/schemaValidator.js"(exports2, module2) {
    var extend = require_node_extend_without();
    var set = require_set_value();
    var hasOwn = require_has_own_deep();
    var unsetValue = require_unset_value();
    var ms = require_ms();
    var bytes = require_bytes();
    var Ajv = require_ajv();
    var validatorCollection = /* @__PURE__ */ new WeakMap();
    var SchemaValidator = class {
      constructor(_options = {}) {
        const options = Object.assign({
          rootSchema: null
        }, _options);
        this.schemaVersion = "http://json-schema.org/draft-07/schema#";
        const validator = new Ajv({
          useDefaults: true,
          coerceTypes: true,
          format: "full"
        });
        const stringDateFormatValidate = validator.compile({ type: "string", format: "date-time" });
        validator.addKeyword("$jsreport-constantOrArray", {
          type: "string",
          modifying: true,
          compile: (sch) => {
            if (!Array.isArray(sch)) {
              throw new Error("$jsreport-constantOrArray json schema keyword should contain an array");
            }
            return (data, dataPath, parentData, parentDataProperty) => {
              if (sch.indexOf(data) !== -1) {
                parentData[parentDataProperty] = data;
                return true;
              }
              parentData[parentDataProperty] = data.split(",");
              return true;
            };
          }
        });
        validator.addKeyword("$jsreport-stringToDate", {
          modifying: true,
          compile: (sch) => {
            if (sch !== true) {
              return () => true;
            }
            return (data, dataPath, parentData, parentDataProperty) => {
              if (!stringDateFormatValidate(data)) {
                return false;
              }
              const newData = new Date(data);
              if (Object.prototype.toString.call(newData) !== "[object Date]") {
                return false;
              }
              parentData[parentDataProperty] = newData;
              return true;
            };
          }
        });
        validator.addKeyword("$jsreport-acceptsDate", {
          compile: (sch) => {
            if (sch !== true) {
              return () => true;
            }
            return (data) => {
              return Boolean(
                data && Object.prototype.toString.call(data) === "[object Date]" && !isNaN(data)
              );
            };
          }
        });
        validator.addKeyword("$jsreport-acceptsBuffer", {
          compile: (sch) => {
            if (sch !== true) {
              return () => true;
            }
            return (data) => {
              return Buffer.isBuffer(data);
            };
          }
        });
        validator.addKeyword("$jsreport-acceptsDuration", {
          modifying: true,
          compile: (sch) => {
            if (sch !== true) {
              return () => true;
            }
            return (data, dataPath, parentData, parentDataProperty) => {
              if (typeof data !== "string" && typeof data !== "number") {
                return false;
              }
              if (typeof data === "number") {
                return true;
              }
              const newData = ms(data);
              if (newData == null) {
                return false;
              }
              parentData[parentDataProperty] = newData;
              return true;
            };
          }
        });
        validator.addKeyword("$jsreport-acceptsSize", {
          modifying: true,
          compile: (sch) => {
            if (sch !== true) {
              return () => true;
            }
            return (data, dataPath, parentData, parentDataProperty) => {
              if (typeof data !== "string" && typeof data !== "number") {
                return false;
              }
              if (typeof data === "number") {
                return true;
              }
              const newData = bytes(data);
              if (newData == null) {
                return false;
              }
              parentData[parentDataProperty] = newData;
              return true;
            };
          }
        });
        let rootValidate;
        if (options.rootSchema != null) {
          rootValidate = validator.compile(addDefaultsAndValidateRootSchema(
            validator,
            options.rootSchema,
            this.schemaVersion
          ));
          this.setRootSchema = (schema2) => {
            rootValidate = validator.compile(addDefaultsAndValidateRootSchema(
              validator,
              schema2,
              this.schemaVersion
            ));
          };
          this.getRootSchema = () => rootValidate && rootValidate.schema;
          this.validateRoot = (data, { rootPrefix = "", ignore = [] } = {}) => {
            let validateFn;
            if (ignore.length > 0) {
              const newRootSchema = extend(true, {}, this.getRootSchema());
              ignore.forEach((prop) => {
                if (hasOwn(newRootSchema, prop)) {
                  set(newRootSchema, prop, true);
                  unsetValue(newRootSchema, prop);
                }
              });
              validateFn = validator.compile(newRootSchema);
            } else {
              validateFn = rootValidate;
            }
            return runSchemaValidation(validator, validateFn, data, rootPrefix);
          };
        }
        validatorCollection.set(this, validator);
      }
      addSchema(name, _schema, replace = false) {
        const validator = validatorCollection.get(this);
        let schema2 = _schema;
        if (typeof schema2 === "object" && !Array.isArray(schema2) && schema2.$schema == null) {
          schema2 = Object.assign({}, schema2, { $schema: this.schemaVersion });
        }
        if (replace === true && validator.getSchema(name) != null) {
          validator.removeSchema(name);
        }
        validator.addSchema(schema2, name);
      }
      // after validate, data will be coerced (modified) with value types
      // that match the schema
      validate(name, data, { rootPrefix = "" } = {}) {
        const validator = validatorCollection.get(this);
        const schemaValidate = validator.getSchema(name);
        if (schemaValidate == null) {
          throw new Error(`schema ${name} is not registered in validator`);
        }
        return runSchemaValidation(validator, schemaValidate, data, rootPrefix);
      }
      getSchema(name) {
        const validator = validatorCollection.get(this);
        const schemaValidate = validator.getSchema(name);
        return schemaValidate ? schemaValidate.schema : void 0;
      }
    };
    function addDefaultsAndValidateRootSchema(validator, _rootSchema, schemaVersion) {
      let rootSchema = _rootSchema;
      if (typeof schema === "object" && !Array.isArray(rootSchema) && rootSchema.$schema == null) {
        rootSchema = Object.assign({}, rootSchema, { $schema: schemaVersion });
      }
      const schemaValid = validator.validateSchema(rootSchema);
      if (!schemaValid) {
        throw new Error(`root schema is not valid. errors: ${validator.errorsText(validator.errors, { dataVar: "rootSchema" })}`);
      }
      return rootSchema;
    }
    function runSchemaValidation(validator, schemaValidate, data, rootPrefix) {
      const valid = schemaValidate(data);
      const result = { valid };
      if (!valid) {
        result.errors = schemaValidate.errors.map((err) => {
          if (err.keyword === "enum" && err.params && Array.isArray(err.params.allowedValues)) {
            err.message += `. allowed values: [${err.params.allowedValues.map((v) => JSON.stringify(v)).join(", ")}]`;
          }
          return err;
        });
        result.fullErrorMessage = `schema validation errors: ${validator.errorsText(result.errors, { dataVar: rootPrefix })}`;
      }
      return result;
    }
    module2.exports = SchemaValidator;
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/templates.js
var require_templates = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/templates.js"(exports2, module2) {
    module2.exports = (reporter) => {
      reporter.documentStore.registerEntityType("TemplateType", {
        name: { type: "Edm.String" },
        content: { type: "Edm.String", document: { main: true, extension: "html", engine: true } },
        recipe: { type: "Edm.String" },
        helpers: { type: "Edm.String", document: { main: true, extension: "js" }, schema: { type: "object" } },
        engine: { type: "Edm.String" }
      }, true);
      reporter.documentStore.registerEntitySet("templates", {
        entityType: "jsreport.TemplateType",
        splitIntoDirectories: true
      });
      reporter.initializeListeners.add("templates", () => {
        const templatesCol = reporter.documentStore.collection("templates");
        templatesCol.beforeInsertListeners.add("templates", (doc) => {
          if (!doc.engine) {
            throw reporter.createError("Template must contain engine", {
              weak: true,
              statusCode: 400
            });
          }
          if (!doc.recipe) {
            throw reporter.createError("Template must contain recipe", {
              weak: true,
              statusCode: 400
            });
          }
        });
      });
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/folders/validateReservedName.js
var require_validateReservedName = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/folders/validateReservedName.js"(exports2, module2) {
    function validateReservedName(reporter, c, doc) {
      if (doc.folder) {
        return;
      }
      if (!reporter.documentStore.model.entitySets[c].entityTypeDef.name) {
        return;
      }
      const name = doc.name;
      if (!name) {
        return;
      }
      const reservedNames = [
        "storage",
        ...Object.keys(
          reporter.documentStore.model.entitySets
        ).filter((name2) => !reporter.documentStore.model.entitySets[name2].splitIntoDirectories).map((name2) => name2.toLowerCase())
      ];
      if (reservedNames.includes(name.toLowerCase())) {
        throw reporter.createError(`The name "${name}" is reserved in the root folder.`, {
          statusCode: 400
        });
      }
    }
    module2.exports = function(reporter) {
      for (const c of Object.keys(reporter.documentStore.collections)) {
        if (!reporter.documentStore.model.entitySets[c].splitIntoDirectories) {
          continue;
        }
        reporter.documentStore.collection(c).beforeInsertListeners.add("folders", (doc, req) => validateReservedName(reporter, c, doc));
        reporter.documentStore.collection(c).beforeUpdateListeners.add("folders", async (q, update, opts, req) => {
          if (update.$set && opts && opts.upsert === true) {
            await validateReservedName(reporter, c, update.$set);
          }
          if (!update.$set.name || update.$set.folder) {
            return;
          }
          const entitiesToUpdate = await reporter.documentStore.collection(c).find(q, req);
          entitiesToUpdate.forEach((e) => validateReservedName(reporter, c, Object.assign({}, e, update.$set)));
        });
      }
    };
    module2.exports.validateReservedName = validateReservedName;
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/folders/cascadeFolderRemove.js
var require_cascadeFolderRemove = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/folders/cascadeFolderRemove.js"(exports2, module2) {
    module2.exports = (reporter) => {
      reporter.documentStore.collection("folders").beforeRemoveListeners.add("folders", async (q, req) => {
        const foldersToRemove = await reporter.documentStore.collection("folders").find(q, req);
        for (const folder of foldersToRemove) {
          for (const c of Object.keys(reporter.documentStore.collections)) {
            const entities = await reporter.documentStore.collection(c).find({
              folder: {
                shortid: folder.shortid
              }
            }, req);
            if (entities.length === 0) {
              continue;
            }
            for (const e of entities) {
              await reporter.documentStore.collection(c).remove({
                _id: e._id
              }, req);
            }
          }
        }
      });
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/shared/folders/resolveEntityPath.js
var require_resolveEntityPath = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/shared/folders/resolveEntityPath.js"(exports2, module2) {
    async function resolveEntityPath(reporter, entity, lookup, req) {
      const fullPath = [];
      let currentEntity = entity;
      while (currentEntity != null) {
        if (currentEntity.folder != null) {
          let folder;
          if (lookup) {
            folder = await lookup(currentEntity.folder.shortid);
          } else {
            folder = await reporter.documentStore.collection("folders").findOne({
              shortid: currentEntity.folder.shortid
            }, req);
          }
          if (folder != null) {
            fullPath.unshift(folder.name);
            currentEntity = folder;
          } else {
            throw new Error(`Folder with shortid "${currentEntity.folder.shortid}" does not exists`);
          }
        } else {
          currentEntity = null;
        }
      }
      fullPath.push(entity.name);
      return `/${fullPath.join("/")}`;
    }
    module2.exports = (reporter) => async (entity, entitySet, req, lookup) => {
      const entitySetInfo = reporter.documentStore.model.entitySets[entitySet];
      if (!entitySetInfo) {
        throw new Error(`Unknown entitySet "${entitySet}"`);
      }
      if (entitySetInfo.entityTypeDef.name == null) {
        throw new Error(`Could not find name attribute of entity of type "${entitySet}"`);
      }
      return resolveEntityPath(reporter, entity, lookup, req);
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/folders/validateDuplicatedName.js
var require_validateDuplicatedName = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/folders/validateDuplicatedName.js"(exports2, module2) {
    var resolveEntityPath = require_resolveEntityPath();
    async function findEntity(reporter, name, folder, req) {
      for (const c of Object.keys(reporter.documentStore.collections)) {
        if (!reporter.documentStore.model.entitySets[c].entityTypeDef.name) {
          continue;
        }
        const allEntities = await reporter.documentStore.collection(c).findAdmin({
          folder
        }, {
          name: 1
        }, req);
        const existingEntity = allEntities.find((entity) => {
          if (entity.name) {
            return entity.name.toLowerCase() === name.toLowerCase();
          }
          return false;
        });
        if (existingEntity) {
          return { entity: existingEntity, entitySet: c };
        }
      }
    }
    async function validateDuplicatedName(reporter, c, doc, originalIdValue, req) {
      const resolveEntityPathFn = resolveEntityPath(reporter);
      if (!reporter.documentStore.model.entitySets[c].entityTypeDef.name) {
        return;
      }
      const name = doc.name;
      if (!name) {
        return;
      }
      const existingEntity = await findEntity(reporter, name, doc.folder, req);
      if (existingEntity) {
        if (originalIdValue != null && existingEntity.entity._id === originalIdValue) {
          return;
        }
        let msg = `Entity with name "${name}" already exists`;
        let folder;
        if (doc.folder != null) {
          folder = await reporter.documentStore.collection("folders").findOne({
            shortid: doc.folder.shortid
          }, req);
          if (folder) {
            const folderFullPath = await resolveEntityPathFn(folder, "folders", req);
            msg = `${msg} in the ${folderFullPath} folder.`;
          } else {
            msg = `${msg} in the same folder.`;
          }
        } else {
          msg = `${msg} at the root level.`;
        }
        if (reporter.documentStore.model.entitySets[existingEntity.entitySet].entityTypeDef.name && existingEntity.entity.name !== name) {
          msg = `${msg} existing: "${existingEntity.entity.name}".`;
        }
        throw reporter.createError(msg, {
          statusCode: 400,
          weak: true,
          code: "DUPLICATED_ENTITY",
          existingEntity: existingEntity.entity,
          existingEntityEntitySet: existingEntity.entitySet
        });
      }
    }
    module2.exports = function(reporter) {
      for (const c of Object.keys(reporter.documentStore.collections)) {
        reporter.documentStore.collection(c).beforeInsertListeners.add("unique-name-folders", (doc, req) => validateDuplicatedName(reporter, c, doc, void 0, req));
        reporter.documentStore.collection(c).beforeUpdateListeners.add("unique-name-folders", async (q, update, opts, req) => {
          if (update.$set && opts && opts.upsert === true) {
            await validateDuplicatedName(reporter, c, update.$set, void 0, req);
          }
          const entitiesToUpdate = await reporter.documentStore.collection(c).find(q, req);
          return Promise.all(entitiesToUpdate.map((e) => validateDuplicatedName(reporter, c, Object.assign({}, e, update.$set), e._id, req)));
        });
      }
    };
    module2.exports.validateDuplicatedName = validateDuplicatedName;
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/folders/getEntitiesInFolder.js
var require_getEntitiesInFolder = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/folders/getEntitiesInFolder.js"(exports2, module2) {
    module2.exports = (reporter) => async function getEntitiesInFolder(folderShortId, recursive, req) {
      if (folderShortId == null) {
        throw new Error("Missing folder shortid param");
      }
      const entities = [];
      const lookup = [];
      for (const [entitySetName] of Object.entries(reporter.documentStore.model.entitySets)) {
        lookup.push(reporter.documentStore.collection(entitySetName).find({
          folder: {
            shortid: folderShortId
          }
        }, req).then((results) => {
          if (results.length === 0) {
            return;
          }
          if (entitySetName === "folders") {
            return Promise.all(results.map((folder) => {
              entities.push({
                entitySet: entitySetName,
                entity: folder
              });
              if (recursive === true) {
                return getEntitiesInFolder(folder.shortid, true, req);
              }
              return void 0;
            })).then((folderLookupResults) => {
              folderLookupResults.forEach((childEntities) => {
                if (childEntities) {
                  entities.push(...childEntities);
                }
              });
            });
          } else {
            results.forEach((entity) => {
              entities.push({
                entitySet: entitySetName,
                entity
              });
            });
          }
        }));
      }
      await Promise.all(lookup);
      return entities;
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/folders/moveBetweenFolders.js
var require_moveBetweenFolders = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/folders/moveBetweenFolders.js"(exports2, module2) {
    var omit = require_lodash();
    async function collectEntitiesInHierarchy(reporter, entities, sourceEntity, onlyChildren, req) {
      if (sourceEntity.__entitySet === "folders") {
        if (!onlyChildren) {
          entities.push(sourceEntity);
        }
        const childEntities = await reporter.folders.getEntitiesInFolder(sourceEntity.shortid, true, req);
        for (const { entitySet, entity } of childEntities) {
          entities.push(Object.assign(entity, {
            __entitySet: entitySet
          }));
        }
      } else {
        entities.push(sourceEntity);
      }
    }
    async function throwIfEntityIsNotFolder(reporter, targetShortid, req) {
      const folder = await reporter.documentStore.collection("folders").findOne({
        shortid: targetShortid
      }, req);
      if (!folder) {
        throw reporter.createError(`Target entity "${targetShortid}" is not a folder, please review that the copy/move is against a valid folder entity`, {
          statusCode: 400
        });
      }
    }
    module2.exports = (reporter) => async ({ source, target, shouldCopy, shouldReplace }, req) => {
      const isSingleSource = Array.isArray(source) ? source.length === 1 : true;
      const sourceList = isSingleSource ? [source] : source;
      if (target.shortid === void 0) {
        throw reporter.createError('target should specify ".shortid"', {
          statusCode: 400
        });
      }
      if (target.shortid != null) {
        await throwIfEntityIsNotFolder(reporter, target.shortid, req);
      }
      const targetUpdateReferences = target.updateReferences === true && target.shortid != null;
      const allEntitiesInvolved = [];
      for (const sourceInfo of sourceList) {
        const sourceCol = reporter.documentStore.collection(sourceInfo.entitySet);
        if (!sourceCol) {
          throw reporter.createError(`Invalid entity set "${sourceInfo.entitySet}" for source`, {
            statusCode: 400
          });
        }
        const sourceEntity = await sourceCol.findOne({ _id: sourceInfo.id }, req);
        if (!sourceEntity) {
          throw reporter.createError("Source entity with specified id does not exists", {
            statusCode: 400
          });
        }
        const onlyChildren = sourceInfo.onlyChildren === true;
        if (onlyChildren && sourceInfo.entitySet !== "folders") {
          throw reporter.createError("onlyChildren option can only be enabled when source is a folder");
        }
        let entitiesInHierarchy = [];
        await collectEntitiesInHierarchy(
          reporter,
          entitiesInHierarchy,
          Object.assign(sourceEntity, { __entitySet: sourceInfo.entitySet }),
          onlyChildren,
          req
        );
        let rootChildren;
        if (onlyChildren) {
          rootChildren = entitiesInHierarchy.filter((e) => {
            return e.folder.shortid === sourceEntity.shortid;
          });
        }
        if (sourceEntity.folder == null && target.shortid === null || sourceEntity.folder != null && target.shortid != null && sourceEntity.folder.shortid === target.shortid) {
          continue;
        }
        if (!shouldCopy) {
          if (entitiesInHierarchy.some((e) => e.shortid === target.shortid)) {
            continue;
          }
          let updateQ;
          if (target.shortid === null) {
            updateQ = {
              $set: {
                folder: null
              }
            };
          } else {
            updateQ = {
              $set: {
                folder: {
                  shortid: target.shortid
                }
              }
            };
          }
          let sourceEntities;
          if (!onlyChildren) {
            sourceEntities = [sourceEntity];
          } else {
            sourceEntities = rootChildren;
          }
          for (const entity of sourceEntities) {
            try {
              await reporter.documentStore.collection(entity.__entitySet).update({
                _id: entity._id
              }, updateQ, req);
            } catch (e) {
              if (e.code === "DUPLICATED_ENTITY" && shouldReplace) {
                if (e.existingEntityEntitySet === "folders") {
                  throw e;
                }
                const removeFolderQ = target.shortid === null ? { folder: null } : { folder: { shortid: target.shortid } };
                await reporter.documentStore.collection(e.existingEntityEntitySet).remove({
                  _id: e.existingEntity._id,
                  ...removeFolderQ
                }, req);
                await reporter.documentStore.collection(entity.__entitySet).update({
                  _id: entity._id
                }, updateQ, req);
              } else {
                throw e;
              }
            }
          }
          const sourceEntityItems = entitiesInHierarchy.filter((e) => {
            return sourceEntities.find((childE) => childE._id === e._id) != null;
          });
          for (const sourceEntityItem of sourceEntityItems) {
            if (target.shortid === null) {
              sourceEntityItem.folder = null;
            } else {
              sourceEntityItem.folder = {
                shortid: target.shortid
              };
            }
          }
        } else {
          let createUpdateReferences2 = function(record) {
            return async (newEntity) => {
              const { entitySet, entity, originalEntity } = record;
              const linkedEntities = entityReferencesMap.get(entity);
              if (linkedEntities.length === 0) {
                return;
              }
              for (const { properties: linkedProperties, entity: originalLinkedEntity } of linkedEntities) {
                const currentNewLinkedEntity = originalEntitiesNewMap.get(originalLinkedEntity);
                if (entityRecordNewValueMap.has(currentNewLinkedEntity)) {
                  const currentEntityProcessedNew = entityRecordNewValueMap.get(currentNewLinkedEntity);
                  const currentEntityUpdate = {};
                  for (const prop of linkedProperties) {
                    reporter.documentStore.updateReference(originalLinkedEntity.__entitySet, currentEntityProcessedNew, entitySet, { referenceProp: prop, referenceValue: originalEntity.shortid }, newEntity.shortid);
                    const rootProp = prop.split(".")[0];
                    currentEntityUpdate[rootProp] = currentEntityProcessedNew[rootProp];
                  }
                  await reporter.documentStore.collection(originalLinkedEntity.__entitySet).update({
                    _id: currentEntityProcessedNew._id
                  }, { $set: currentEntityUpdate }, req);
                } else {
                  reporter.documentStore.updateReference(originalLinkedEntity.__entitySet, currentNewLinkedEntity, entitySet, { referenceValue: originalEntity.shortid }, newEntity.shortid);
                }
              }
            };
          };
          var createUpdateReferences = createUpdateReferences2;
          const entitiesInHierarchyByCollection = entitiesInHierarchy.reduce((acu, entity) => {
            acu[entity.__entitySet] = acu[entity.__entitySet] || [];
            acu[entity.__entitySet].push(entity);
            return acu;
          }, {});
          const entityReferencesMap = /* @__PURE__ */ new WeakMap();
          const originalEntitiesNewMap = /* @__PURE__ */ new WeakMap();
          const entityRecordNewValueMap = /* @__PURE__ */ new WeakMap();
          const records = [];
          if (targetUpdateReferences) {
            const targetEntity = await reporter.documentStore.collection("folders").findOne({
              shortid: target.shortid
            }, req);
            targetEntity.__entitySet = "folders";
            entitiesInHierarchyByCollection.folders = entitiesInHierarchyByCollection.folders || [];
            entitiesInHierarchyByCollection.folders.push(targetEntity);
            originalEntitiesNewMap.set(targetEntity, targetEntity);
            entityRecordNewValueMap.set(targetEntity, targetEntity);
          }
          for (const entity of entitiesInHierarchy) {
            const newEntity = {
              ...omit(entity, ["_id", "shortid", "__entitySet"])
            };
            let isSourceEntityItem;
            if (!onlyChildren) {
              isSourceEntityItem = sourceInfo.id === entity._id;
            } else {
              isSourceEntityItem = rootChildren.find((e) => e._id === entity._id) != null;
            }
            if (isSourceEntityItem) {
              if (target.shortid === null) {
                newEntity.folder = null;
              } else {
                newEntity.folder = {
                  shortid: target.shortid
                };
              }
              if (!isSingleSource) {
                let copyAttempt = 0;
                let existsAtTarget;
                do {
                  existsAtTarget = await reporter.documentStore.collection(entity.__entitySet).findOne({
                    name: newEntity.name,
                    folder: newEntity.folder
                  });
                  if (existsAtTarget != null) {
                    copyAttempt++;
                    newEntity.name = `${entity.name}(copy${copyAttempt > 1 ? copyAttempt : ""})`;
                  }
                } while (existsAtTarget != null);
              }
            }
            const entitySet = entity.__entitySet;
            newEntity.__entitySet = entitySet;
            const linkedEntities = reporter.documentStore.findLinkedEntitiesForReference(
              entitiesInHierarchyByCollection,
              entitySet,
              entity.shortid
            );
            const record = {
              entitySet,
              originalEntity: entity,
              entity: newEntity
            };
            record.updateReferences = createUpdateReferences2(record);
            originalEntitiesNewMap.set(entity, newEntity);
            entityReferencesMap.set(newEntity, linkedEntities);
            records.push(record);
          }
          const processNewEntity = async (entitySet, entity) => {
            const newEntityFromStore = await reporter.documentStore.collection(entitySet).insert({
              ...omit(entity, ["__entitySet"])
            }, req);
            entityRecordNewValueMap.set(entity, newEntityFromStore);
          };
          for (const record of records) {
            try {
              await processNewEntity(record.entitySet, record.entity);
            } catch (e) {
              if (e.code === "DUPLICATED_ENTITY" && shouldReplace) {
                if (e.existingEntityEntitySet === "folders") {
                  throw e;
                }
                const removeFolderQ = target.shortid === null ? { folder: null } : { folder: { shortid: target.shortid } };
                await reporter.documentStore.collection(e.existingEntityEntitySet).remove({
                  _id: e.existingEntity._id,
                  ...removeFolderQ
                }, req);
                await processNewEntity(record.entitySet, record.entity);
              } else {
                throw e;
              }
            }
            await record.updateReferences(entityRecordNewValueMap.get(record.entity));
          }
          entitiesInHierarchy = records.map((record) => ({
            ...omit(entityRecordNewValueMap.get(record.entity), ["$entitySet", "__entitySet"]),
            __entitySet: record.entitySet
          }));
        }
        allEntitiesInvolved.push(...entitiesInHierarchy);
      }
      await Promise.all(allEntitiesInvolved.map(async (entity) => {
        const entitySet = reporter.documentStore.model.entitySets[entity.__entitySet];
        const entityType = entitySet.entityTypeDef;
        const projection = {};
        if (entityType.creationDate != null && entityType.creationDate.type === "Edm.DateTimeOffset") {
          projection.creationDate = 1;
        }
        if (entityType.modificationDate != null && entityType.modificationDate.type === "Edm.DateTimeOffset") {
          projection.modificationDate = 1;
        }
        if (Object.keys(projection).length === 0) {
          return;
        }
        const doc = await reporter.documentStore.collection(entity.__entitySet).findOne({
          _id: entity._id
        }, {
          creationDate: 1,
          modificationDate: 1
        }, req);
        if (projection.creationDate) {
          entity.creationDate = doc.creationDate;
        }
        if (projection.modificationDate) {
          entity.modificationDate = doc.modificationDate;
        }
      }));
      return allEntitiesInvolved;
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/folders/index.js
var require_folders = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/folders/index.js"(exports2, module2) {
    var validateReservedName = require_validateReservedName();
    var cascadeFolderRemove = require_cascadeFolderRemove();
    var validateDuplicatedName = require_validateDuplicatedName();
    var getEntitiesInFolder = require_getEntitiesInFolder();
    var moveBetweenFolders = require_moveBetweenFolders();
    module2.exports = (reporter) => {
      reporter.documentStore.registerEntityType("FolderType", {
        name: { type: "Edm.String" }
      });
      reporter.documentStore.registerEntitySet("folders", {
        entityType: "jsreport.FolderType",
        splitIntoDirectories: true
      });
      reporter.documentStore.registerComplexType("FolderRefType", {
        shortid: { type: "Edm.String", referenceTo: "folders" }
      });
      reporter.documentStore.on("before-init", (documentStore) => {
        Object.entries(documentStore.model.entitySets).forEach(([k, entitySet]) => {
          const entityTypeName = entitySet.entityType.replace(documentStore.model.namespace + ".", "");
          documentStore.model.entityTypes[entityTypeName].folder = {
            type: "jsreport.FolderRefType",
            // folder reference can be null when entity is at the root level
            schema: { type: "null" }
          };
        });
      });
      reporter.documentStore.internalAfterInitListeners.add("core-validate-reserved-name", () => validateReservedName(reporter));
      reporter.documentStore.internalAfterInitListeners.add("core-cascade-remove", () => cascadeFolderRemove(reporter));
      reporter.documentStore.internalAfterInitListeners.add("core-validate-duplicated-name", () => validateDuplicatedName(reporter));
      return {
        move: moveBetweenFolders(reporter),
        getEntitiesInFolder: getEntitiesInFolder(reporter)
      };
    };
  }
});

// node_modules/@jsreport/serializator/index.js
var require_serializator = __commonJS({
  "node_modules/@jsreport/serializator/index.js"(exports2, module2) {
    "use strict";
    var defaultTypeKeys = {
      date: "$$$date$$$",
      buffer: "$$$buffer$$$"
    };
    var serializing = false;
    var serializingTypeKeys = defaultTypeKeys;
    var originalDateToJSON = Date.prototype.toJSON;
    var originalBufferToJSON = Buffer.prototype.toJSON;
    Date.prototype.toJSON = function() {
      if (serializing) {
        return { [serializingTypeKeys.date]: this.getTime() };
      } else {
        return originalDateToJSON.call(this);
      }
    };
    Buffer.prototype.toJSON = function(...args) {
      if (serializing) {
        return { [serializingTypeKeys.buffer]: this.toString("base64") };
      } else {
        return originalBufferToJSON.call(this);
      }
    };
    module2.exports.serialize = (obj, { prettify = false, prettifySpace = 2, typeKeys = defaultTypeKeys } = {}) => {
      serializing = true;
      serializingTypeKeys = typeKeys;
      try {
        let res;
        res = JSON.stringify(obj, (key, value) => {
          if (typeof value === "undefined") {
            return null;
          }
          if (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || value === null) {
            return value;
          }
          return value;
        }, prettify ? prettifySpace : null);
        return res;
      } finally {
        serializing = false;
        serializingTypeKeys = defaultTypeKeys;
      }
    };
    module2.exports.parse = (json, { typeKeys = defaultTypeKeys } = {}) => {
      return JSON.parse(json, (key, value) => {
        if (key === typeKeys.date) {
          return new Date(value);
        }
        if (key === typeKeys.buffer && value != null && typeof value === "string") {
          return Buffer.from(value, "base64");
        }
        if (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || value === null) {
          return value;
        }
        if (value && value[typeKeys.date]) {
          return value[typeKeys.date];
        }
        if (value && value[typeKeys.buffer]) {
          return value[typeKeys.buffer];
        }
        return value;
      });
    };
  }
});

// node_modules/@jsreport/advanced-workers/lib/threadWorker.js
var require_threadWorker = __commonJS({
  "node_modules/@jsreport/advanced-workers/lib/threadWorker.js"(exports2, module2) {
    var serializator = require_serializator();
    function asyncAwaiter(id) {
      const awaiter = {};
      awaiter.promise = new Promise((resolve, reject) => {
        awaiter.resolve = (v) => {
          awaiter.isSettled = true;
          resolve(v);
        };
        awaiter.reject = (e) => {
          awaiter.isSettled = true;
          reject(e);
        };
      });
      return awaiter;
    }
    module2.exports = ({
      worker,
      generalTimeout,
      closeTimeout = 5e3,
      initTimeout = 15e3
    }) => {
      let currentAsyncAwaiter;
      let closingWhenWaitingForMainExecution;
      worker.on("message", (m) => {
        if (currentAsyncAwaiter) {
          currentAsyncAwaiter.resolve(m);
        }
      });
      function postAndWait(m, { executeMain, timeout }) {
        let timeoutId;
        worker.ref();
        return new Promise(async (resolve, reject) => {
          let isDone = false;
          if (timeout) {
            timeoutId = setTimeout(() => {
              if (!isDone) {
                isDone = true;
                const e = new Error(`Timeout occurred when waiting for the worker${m.systemAction != null ? ` action "${m.systemAction}"` : ""}`);
                e.code = "WORKER_TIMEOUT";
                worker.unref();
                reject(e);
              }
            }, timeout).unref();
          }
          while (!isDone) {
            currentAsyncAwaiter = asyncAwaiter();
            worker.postMessage(m);
            const workerResponse = await currentAsyncAwaiter.promise;
            if (workerResponse.workerCrashed) {
              isDone = true;
              worker.unref();
              return reject(workerResponse.err);
            }
            if (isDone) {
              return;
            }
            if (workerResponse.type === "response") {
              isDone = true;
              if (workerResponse.errorData) {
                const error = new Error(workerResponse.errorData.message);
                error.stack = workerResponse.errorData.stack;
                Object.assign(error, workerResponse.errorData);
                worker.unref();
                return reject(error);
              }
              worker.unref();
              return resolve(workerResponse.userData);
            }
            if (workerResponse.type === "callback") {
              try {
                const callbackResponse = await executeMain(serializator.parse(workerResponse.userData));
                if (closingWhenWaitingForMainExecution) {
                  const err = new Error("Worker aborted");
                  err.code = "WORKER_ABORTED";
                  worker.unref();
                  return reject(err);
                }
                m = {
                  systemAction: "callback-response",
                  userData: callbackResponse
                };
              } catch (e) {
                m = {
                  systemAction: "callback-response",
                  errorData: {
                    message: e.message,
                    stack: e.stack,
                    ...e
                  }
                };
              }
            }
          }
        }).finally(() => {
          if (timeoutId != null) {
            clearTimeout(timeoutId);
          }
          if (currentAsyncAwaiter && currentAsyncAwaiter.isSettled) {
            currentAsyncAwaiter = null;
          }
        });
      }
      let closingAwaiter;
      let closingTimeoutId;
      let exited = false;
      worker.on("exit", (exitCode) => {
        exited = true;
        if (closingAwaiter && !closingAwaiter.isSettled) {
          closingAwaiter.resolve();
          closingAwaiter = null;
          clearTimeout(closingTimeoutId);
          closingTimeoutId = null;
        } else {
          if (currentAsyncAwaiter && !currentAsyncAwaiter.isSettled) {
            const err = new Error("Worker unexpectedly exited");
            err.code = "WORKER_CRASHED";
            currentAsyncAwaiter.resolve({
              workerCrashed: true,
              err
            });
            currentAsyncAwaiter = null;
          }
        }
        worker.unref();
      });
      worker.on("error", (err) => {
        if (!currentAsyncAwaiter) {
          console.log("Worker crashed after the response was processed.", err);
          return;
        }
        err.code = "WORKER_CRASHED";
        currentAsyncAwaiter.resolve({
          workerCrashed: true,
          err
        });
        currentAsyncAwaiter = null;
        worker.unref();
      });
      worker.unref();
      return {
        init: () => {
          return postAndWait({
            systemAction: "init"
          }, { timeout: initTimeout });
        },
        execute: (userData, { executeMain, timeout }) => {
          return postAndWait({
            systemAction: "execute",
            userData
          }, { executeMain, timeout });
        },
        close: () => {
          if (exited) {
            return;
          }
          if (currentAsyncAwaiter && !currentAsyncAwaiter.isSettled) {
            const err = new Error("Worker aborted");
            err.code = "WORKER_ABORTED";
            currentAsyncAwaiter.resolve({
              workerCrashed: true,
              err
            });
            currentAsyncAwaiter = null;
            worker.unref();
          } else {
            closingWhenWaitingForMainExecution = true;
          }
          closingTimeoutId = setTimeout(() => {
            if (!exited && closingAwaiter && !closingAwaiter.isSettled) {
              worker.terminate();
              closingAwaiter.resolve();
              closingAwaiter = null;
              worker.unref();
            }
            closingTimeoutId = null;
          }, closeTimeout).unref();
          closingAwaiter = asyncAwaiter();
          worker.ref();
          worker.postMessage({
            systemAction: "close"
          });
          return closingAwaiter.promise;
        }
      };
    };
  }
});

// node_modules/@jsreport/advanced-workers/lib/convertUint8ArrayToBuffer.js
var require_convertUint8ArrayToBuffer = __commonJS({
  "node_modules/@jsreport/advanced-workers/lib/convertUint8ArrayToBuffer.js"(exports2, module2) {
    module2.exports = function convertUint8ArrayToBuffer(obj) {
      const shouldContinue = isObject(obj) || Array.isArray(obj);
      if (!shouldContinue) {
        return;
      }
      for (const [key, value] of Object.entries(obj)) {
        if (isUint8Array(value)) {
          obj[key] = typeArrayToBuffer(value);
        } else if (isObject(value)) {
          convertUint8ArrayToBuffer(value);
        } else if (Array.isArray(value)) {
          convertUint8ArrayToBuffer(value);
        }
      }
    };
    function isUint8Array(input) {
      return Object.prototype.toString.call(input) === "[object Uint8Array]";
    }
    function isObject(input) {
      return Object.prototype.toString.call(input) === "[object Object]";
    }
    function typeArrayToBuffer(input) {
      let newBuf = Buffer.from(input.buffer);
      if (input.byteLength !== input.buffer.byteLength) {
        newBuf = newBuf.slice(input.byteOffset, input.byteOffset + input.byteLength);
      }
      return newBuf;
    }
  }
});

// node_modules/@jsreport/advanced-workers/lib/pool.js
var require_pool = __commonJS({
  "node_modules/@jsreport/advanced-workers/lib/pool.js"(exports2, module2) {
    module2.exports = ({
      createWorker,
      numberOfWorkers,
      initTimeout
    }) => {
      return {
        init() {
          this.workers = [];
          this.tasksQueue = [];
          this._pendingInitializedWorkersToEventualyCleanup = [];
          const workersCreateFn = [];
          for (let i = 0; i < numberOfWorkers; i++) {
            workersCreateFn.push(async () => {
              const worker = createWorker();
              await worker.init();
              this.workers.push(worker);
            });
          }
          return Promise.all(workersCreateFn.map((fn) => fn()));
        },
        async close() {
          for (const w of this.workers) {
            await w.close();
          }
        },
        async allocate(data, opts) {
          const notBusyWorkers = this.workers.filter((w) => w.isBusy !== true);
          const worker = notBusyWorkers.sort((a, b) => {
            if (a.lastUsed == null) {
              return -1;
            }
            if (b.lastUsed == null) {
              return 1;
            }
            return a.lastUsed <= b.lastUsed ? -1 : 1;
          })[0];
          if (worker) {
            worker.isBusy = true;
            worker.lastUsed = /* @__PURE__ */ new Date();
            return {
              release: async () => {
                if (worker.needRestart || worker.running) {
                  this.workers = this.workers.filter((w) => w !== worker);
                  worker.close();
                  const newWorker = createWorker();
                  newWorker.isBusy = true;
                  this.workers.push(newWorker);
                  await newWorker.init({ timeout: initTimeout });
                  newWorker.isBusy = false;
                } else {
                  worker.isBusy = false;
                }
                this._flushTasksQueue();
              },
              execute: async (userData, options = {}) => {
                try {
                  worker.running = true;
                  return await worker.execute(userData, options);
                } catch (e) {
                  if (e.code === "WORKER_TIMEOUT" && options.timeoutErrorMessage) {
                    e.message = options.timeoutErrorMessage;
                  }
                  if (e.code === "WORKER_TIMEOUT" || e.code === "WORKER_CRASHED") {
                    worker.needRestart = true;
                  }
                  throw e;
                } finally {
                  worker.running = false;
                }
              }
            };
          }
          let timeoutId;
          return new Promise((resolve, reject) => {
            const task = { resolve, reject };
            this.tasksQueue.push(task);
            if (opts && opts.timeout) {
              timeoutId = setTimeout(() => {
                const taskIndex = this.tasksQueue.indexOf(task);
                if (taskIndex !== -1) {
                  this.tasksQueue.splice(taskIndex, 1);
                  task.reject(new Error("Timeout when waiting for worker"));
                }
              }, opts.timeout).unref();
            }
          }).finally(() => {
            if (timeoutId != null) {
              clearTimeout(timeoutId);
            }
          });
        },
        _flushTasksQueue() {
          if (this.tasksQueue.length === 0) {
            return;
          }
          const task = this.tasksQueue.shift();
          this.allocate().then(task.resolve).catch(task.reject);
        }
      };
    };
  }
});

// node_modules/@jsreport/advanced-workers/lib/workersManager.js
var require_workersManager = __commonJS({
  "node_modules/@jsreport/advanced-workers/lib/workersManager.js"(exports2, module2) {
    var { Worker } = require("worker_threads");
    var path = require("path");
    var ThreadWorker = require_threadWorker();
    var convertUint8ArrayToBuffer = require_convertUint8ArrayToBuffer();
    var pool = require_pool();
    module2.exports = (userOptions, {
      workerModule,
      numberOfWorkers,
      resourceLimits,
      initTimeout
    }) => {
      function createWorker() {
        const worker = new Worker(path.join(__dirname, "workerHandler.js"), {
          workerData: {
            systemData: {
              workerModule
            },
            userData: userOptions
          },
          resourceLimits
        });
        return ThreadWorker({
          worker,
          initTimeout
        });
      }
      return {
        async init() {
          this.pool = pool({
            createWorker: () => createWorker(),
            numberOfWorkers,
            initTimeout
          });
          return this.pool.init();
        },
        async allocate(data, opts) {
          return this.pool.allocate(data, opts);
        },
        close() {
          if (this.closed) {
            return;
          }
          this.closed = true;
          return this.pool.close();
        },
        convertUint8ArrayToBuffer
      };
    };
  }
});

// node_modules/@jsreport/advanced-workers/index.js
var require_advanced_workers = __commonJS({
  "node_modules/@jsreport/advanced-workers/index.js"(exports2, module2) {
    module2.exports = require_workersManager();
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/store/setupValidateId.js
var require_setupValidateId = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/store/setupValidateId.js"(exports2, module2) {
    module2.exports = (reporter) => {
      reporter.initializeListeners.add("core-validate-id", () => {
        for (const c of Object.keys(reporter.documentStore.collections)) {
          reporter.documentStore.collection(c).beforeInsertListeners.add("validate-id", (doc, req) => {
            if (req == null || req.context.skipValidationFor !== doc) {
              return validateIdForStoreChange(reporter, c, doc._id, void 0, req);
            }
          });
          reporter.documentStore.collection(c).beforeUpdateListeners.add("validate-id", async (q, update, opts, req) => {
            if (req != null && req.context.skipValidationFor === update) {
              return;
            }
            if (update.$set && opts && opts.upsert === true) {
              await validateIdForStoreChange(reporter, c, update.$set._id, void 0, req);
            }
            if (!update.$set._id) {
              return;
            }
            const entitiesToUpdate = await reporter.documentStore.collection(c).find(q, req);
            return Promise.all(entitiesToUpdate.map((e) => validateIdForStoreChange(reporter, c, Object.assign({}, e, update.$set)._id, e._id, req)));
          });
        }
      });
    };
    async function validateIdForStoreChange(reporter, collectionName, idValue, originalIdValue, req) {
      const existingEntity = await reporter.documentStore.checkDuplicatedId(collectionName, idValue, req);
      if (!existingEntity) {
        return;
      }
      if (originalIdValue != null && existingEntity._id === originalIdValue) {
        return;
      }
      throw reporter.createError(`Entity with _id "${idValue}" already exists.`, {
        statusCode: 400,
        code: "DUPLICATED_ENTITY",
        existingEntity,
        existingEntityEntitySet: collectionName
      });
    }
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/store/setupValidateShortid.js
var require_setupValidateShortid = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/store/setupValidateShortid.js"(exports2, module2) {
    module2.exports = (reporter) => {
      reporter.initializeListeners.add("core-validate-shortid", () => {
        for (const c of Object.keys(reporter.documentStore.collections)) {
          const es = reporter.documentStore.model.entitySets[c];
          const et = reporter.documentStore.model.entityTypes[es.entityType.substring("jsreport.".length)];
          if (!et.shortid) {
            return;
          }
          reporter.documentStore.collection(c).beforeInsertListeners.add("validate-shortid", (doc, req) => {
            return validateShortid(reporter, c, doc, void 0, req);
          });
          reporter.documentStore.collection(c).beforeUpdateListeners.add("validate-shortid", async (q, update, opts, req) => {
            if (update.$set && opts && opts.upsert === true) {
              await validateShortid(reporter, c, update.$set, void 0, req);
            }
            if (typeof update.$set.shortid === "undefined") {
              return;
            }
            const entitiesToUpdate = await reporter.documentStore.collection(c).find(q, req);
            return Promise.all(entitiesToUpdate.map((e) => validateShortid(reporter, c, Object.assign({}, e, update.$set), e._id, req)));
          });
        }
      });
    };
    async function validateShortid(reporter, collectionName, doc, originalIdValue, req) {
      if (req != null && req.context.skipValidationFor === doc) {
        return;
      }
      const shortid = doc.shortid;
      if (!shortid) {
        throw reporter.createError("Entity shortid property can not be empty", {
          statusCode: 400
        });
      }
      const existingEntity = await findEntity(reporter, collectionName, shortid, req);
      if (existingEntity) {
        if (originalIdValue != null && existingEntity._id === originalIdValue) {
          return;
        }
        throw reporter.createError(`Entity with shortid "${shortid}" already exists.`, {
          statusCode: 400,
          code: "DUPLICATED_ENTITY",
          existingEntity,
          existingEntityEntitySet: collectionName
        });
      }
    }
    async function findEntity(reporter, collectionName, shortid, req) {
      const existingEntity = await reporter.documentStore.collection(collectionName).findOneAdmin({
        shortid
      }, req);
      return existingEntity;
    }
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/store/mainActions.js
var require_mainActions = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/store/mainActions.js"(exports2, module2) {
    module2.exports = (reporter) => {
      reporter.registerMainAction("documentStore.collection.find", async (spec, originalReq) => {
        const localReq = reporter.Request(originalReq);
        localReq.context.userFindCall = true;
        const collection = reporter.documentStore.collection(spec.collection);
        let method = "find";
        if (spec.admin) {
          method = "findAdmin";
        }
        const res = await collection[method](spec.query, localReq);
        return res;
      });
      reporter.registerMainAction("documentStore.collection.findOne", async (spec, originalReq) => {
        const localReq = reporter.Request(originalReq);
        localReq.context.userFindCall = true;
        const collection = reporter.documentStore.collection(spec.collection);
        let method = "findOne";
        if (spec.admin) {
          method = "findOneAdmin";
        }
        const res = await collection[method](spec.query, localReq);
        return res;
      });
      reporter.registerMainAction("documentStore.collection.insert", async (spec, originalReq) => {
        const localReq = reporter.Request(originalReq);
        const res = await reporter.documentStore.collection(spec.collection).insert(spec.doc, localReq);
        return res;
      });
      reporter.registerMainAction("documentStore.collection.update", async (spec, originalReq) => {
        const localReq = reporter.Request(originalReq);
        const res = await reporter.documentStore.collection(spec.collection).update(spec.query, spec.update, spec.options, localReq);
        return res;
      });
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/blobStorage/mainActions.js
var require_mainActions2 = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/blobStorage/mainActions.js"(exports2, module2) {
    module2.exports = (reporter) => {
      reporter.registerMainAction("blobStorage.read", async (spec, originalReq) => {
        const localReq = reporter.Request(originalReq);
        const res = await reporter.blobStorage.read(spec.blobName, localReq);
        return res.toString("base64");
      });
      reporter.registerMainAction("blobStorage.write", async (spec, originalReq) => {
        const localReq = reporter.Request(originalReq);
        return await reporter.blobStorage.write(spec.blobName, Buffer.from(spec.content, "base64"), localReq);
      });
      reporter.registerMainAction("blobStorage.remove", async (spec, originalReq) => {
        const localReq = reporter.Request(originalReq);
        return reporter.blobStorage.remove(spec.blobName, localReq);
      });
      reporter.registerMainAction("blobStorage.append", async (spec, originalReq) => {
        const localReq = reporter.Request(originalReq);
        return reporter.blobStorage.append(spec.blobName, Buffer.from(spec.content, "base64"), localReq);
      });
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/shared/response.js
var require_response = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/shared/response.js"(exports2, module2) {
    var extend = require_node_extend_without();
    var fs = require("fs/promises");
    var { Readable } = require("stream");
    var { pipeline } = require("stream/promises");
    var path = require("path");
    var isArrayBufferView = require("util").types.isArrayBufferView;
    module2.exports = (reporter, requestId, obj) => {
      let outputImpl = new BufferOutput(reporter);
      let cachedStream;
      const response = {
        meta: extend(true, {}, (obj || {}).meta),
        /** back compatibility methods **/
        get content() {
          return outputImpl.getBufferSync();
        },
        set content(v) {
          outputImpl.setBufferSync(Buffer.from(v));
        },
        get stream() {
          if (cachedStream == null) {
            cachedStream = outputImpl.getStream();
          }
          return cachedStream;
        },
        /** //// back compatibility methods **/
        get isInStreamingMode() {
          return outputImpl instanceof StreamOutput;
        },
        get __isJsreportResponse__() {
          return true;
        },
        output: {
          async getBuffer() {
            return outputImpl.getBuffer();
          },
          async getStream() {
            return outputImpl.getStream();
          },
          async getSize() {
            return outputImpl.getSize();
          },
          async writeToTempFile(...args) {
            return outputImpl.writeToTempFile(...args);
          },
          async update(bufOrStreamOrPath) {
            if (Buffer.isBuffer(bufOrStreamOrPath) || isArrayBufferView(bufOrStreamOrPath)) {
              return outputImpl.setBuffer(bufOrStreamOrPath);
            }
            if (typeof bufOrStreamOrPath === "string") {
              if (!path.isAbsolute(bufOrStreamOrPath)) {
                throw new Error("Invalid content passed to res.output.update, when content is string it must be an absolute path");
              }
              if (outputImpl instanceof BufferOutput) {
                outputImpl = new StreamOutput(reporter, requestId);
              }
              await reporter.copyFileToTempFile(bufOrStreamOrPath, outputImpl.filePath);
              return;
            }
            if (isNodeReadableStream(bufOrStreamOrPath) || isWebReadableStream(bufOrStreamOrPath)) {
              if (outputImpl instanceof BufferOutput) {
                outputImpl = new StreamOutput(reporter, requestId);
              }
              return outputImpl.setStream(bufOrStreamOrPath);
            }
            throw new Error("Invalid content passed to res.output.update");
          }
        },
        serialize() {
          return {
            meta: extend(true, {}, this.meta),
            output: outputImpl.serialize()
          };
        },
        async parse(res) {
          Object.assign(this.meta, res.meta);
          if (res.output.type === "buffer") {
            outputImpl = await BufferOutput.parse(reporter, res.output);
          } else {
            outputImpl = await StreamOutput.parse(reporter, requestId, res.output);
          }
        }
      };
      return response;
    };
    var BufferOutput = class _BufferOutput {
      constructor(reporter) {
        this.reporter = reporter;
        this.buffer = Buffer.from([]);
        this.getBufferSync = this.getBuffer;
        this.setBufferSync = this.setBuffer;
      }
      getBuffer() {
        return this.buffer;
      }
      setBuffer(buf) {
        this.buffer = Buffer.isBuffer(buf) ? buf : Buffer.from(buf);
      }
      writeToTempFile(tmpNameFn) {
        return this.reporter.writeTempFile(tmpNameFn, this.buffer);
      }
      getSize() {
        return this.buffer.length;
      }
      getStream() {
        return Readable.from(this.buffer);
      }
      serialize() {
        const sharedBuf = new SharedArrayBuffer(this.buffer.byteLength);
        const buf = Buffer.from(sharedBuf);
        this.buffer.copy(buf);
        return {
          type: "buffer",
          content: buf
        };
      }
      static parse(reporter, output) {
        const instance = new _BufferOutput(reporter);
        if (output?.content?.length) {
          instance.setBufferSync(Buffer.from(output?.content));
        }
        return instance;
      }
    };
    var StreamOutput = class _StreamOutput {
      constructor(reporter, requestId) {
        this.reporter = reporter;
        this.filename = `response-${requestId}.raw-content`;
        const { pathToFile } = this.reporter.getTempFilePath(this.filename);
        this.filePath = pathToFile;
      }
      async getBuffer() {
        const { content } = await this.reporter.readTempFile(this.filename);
        return content;
      }
      setBuffer(buf) {
        return this.reporter.writeTempFile(this.filename, buf);
      }
      getBufferSync() {
        const { content } = this.reporter.readTempFileSync(this.filename);
        return content;
      }
      setBufferSync(buf) {
        this.reporter.writeTempFileSync(this.filename, buf);
      }
      writeToTempFile(tmpNameFn) {
        return this.reporter.copyFileToTempFile(this.filePath, tmpNameFn);
      }
      async getSize() {
        const stat = await fs.stat(this.filePath);
        return stat.size;
      }
      getStream() {
        const reporter = this.reporter;
        const filename = this.filename;
        async function* generateResponseContent() {
          const responseFileStream = reporter.readTempFileStream(filename).stream;
          for await (const chunk of responseFileStream) {
            yield chunk;
          }
        }
        return Readable.from(generateResponseContent());
      }
      async setStream(stream) {
        const inputStream = isNodeReadableStream(stream) ? stream : Readable.fromWeb(stream);
        const { stream: responseFileStream } = await this.reporter.writeTempFileStream(this.filename);
        await pipeline(inputStream, responseFileStream);
      }
      serialize() {
        return {
          type: "stream",
          filePath: this.filePath
        };
      }
      static async parse(reporter, requestId, output) {
        const instance = new _StreamOutput(reporter, requestId);
        if (output.filePath !== instance.filePath) {
          await reporter.copyFileToTempFile(output.filePath, instance.filePath);
        }
        return instance;
      }
    };
    function isNodeReadableStream(stream) {
      return stream !== null && typeof stream === "object" && typeof stream.pipe === "function" && typeof stream.read === "function" && typeof stream.readable === "boolean" && typeof stream.readableObjectMode === "boolean" && typeof stream.destroy === "function" && typeof stream.destroyed === "boolean";
    }
    function isWebReadableStream(stream) {
      return stream !== null && typeof stream === "object" && typeof stream.locked === "boolean" && typeof stream.cancel === "function" && typeof stream.getReader === "function" && typeof stream.pipeTo === "function" && typeof stream.pipeThrough === "function";
    }
  }
});

// node_modules/@jsreport/jsreport-core/lib/shared/templates.js
var require_templates2 = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/shared/templates.js"(exports2, module2) {
    module2.exports = (reporter) => {
      return {
        resolveTemplate: (req) => resolveTemplate(reporter, req)
      };
    };
    async function resolveTemplate(reporter, req) {
      let queryResult;
      if (req.template._id) {
        queryResult = {
          query: { _id: req.template._id },
          meta: { field: "_id", value: req.template._id }
        };
      } else if (req.template.shortid) {
        queryResult = {
          query: { shortid: req.template.shortid },
          meta: { field: "shortid", value: req.template.shortid }
        };
      }
      const meta = {};
      let templates = [];
      if (queryResult) {
        meta.field = queryResult.meta.field;
        meta.value = queryResult.meta.value;
        templates = await reporter.documentStore.collection("templates").find(queryResult.query, req);
      } else if (req.template.name) {
        const nameIsPath = req.template.name.indexOf("/") !== -1;
        meta.field = "name";
        meta.value = req.template.name;
        if (!req.template.name.startsWith("/") && nameIsPath && !req.context.currentFolderPath) {
          throw reporter.createError('Invalid template path, path should be absolute and start with "/"', {
            statusCode: 400,
            weak: true
          });
        }
        const pathParts = req.template.name.split("/").filter((p) => p);
        if (pathParts.length === 0) {
          throw reporter.createError("Invalid template path,", {
            statusCode: 400,
            weak: true
          });
        }
        if (!nameIsPath) {
          templates = await reporter.documentStore.collection("templates").find({
            name: req.template.name
          }, req);
        } else {
          const result = await reporter.folders.resolveEntityFromPath(req.template.name, "templates", req);
          if (result) {
            templates = [result.entity];
          }
        }
      }
      let template;
      if (templates.length > 1) {
        throw reporter.createError(`Duplicated templates found for query ${meta.field}: ${meta.value}`, {
          statusCode: 400,
          weak: true
        });
      }
      if (templates.length === 1) {
        template = templates[0];
      }
      return template;
    }
  }
});

// node_modules/@jsreport/jsreport-core/lib/shared/folders/normalizeEntityPath.js
var require_normalizeEntityPath = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/shared/folders/normalizeEntityPath.js"(exports2, module2) {
    var path = require("path");
    module2.exports = function normalizeEntityPath(entityPath, { currentPath }, req) {
      let parentPath = "/";
      if (req && req.context.currentFolderPath) {
        parentPath = req.context.currentFolderPath;
      }
      if (currentPath) {
        parentPath = currentPath;
      }
      return path.posix.resolve(parentPath, entityPath).replace(/\\/g, "/");
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/shared/folders/resolveFolderFromPath.js
var require_resolveFolderFromPath = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/shared/folders/resolveFolderFromPath.js"(exports2, module2) {
    var normalizeEntityPath = require_normalizeEntityPath();
    module2.exports = (reporter) => async (entityPathParam, req) => {
      const entityPath = normalizeEntityPath(entityPathParam, {}, req);
      const fragments = entityPath.split("/").filter((s) => s);
      let found = false;
      let currentFolder = null;
      for (const f of fragments) {
        if (found) {
          currentFolder = null;
          break;
        }
        const query = {
          name: f
        };
        if (currentFolder) {
          query.folder = { shortid: currentFolder.shortid };
        } else {
          query.folder = null;
        }
        const folder = await reporter.documentStore.collection("folders").findOne(query, req);
        if (!folder) {
          found = true;
          continue;
        }
        currentFolder = folder;
      }
      return currentFolder;
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/shared/folders/resolveEntityFromPath.js
var require_resolveEntityFromPath = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/shared/folders/resolveEntityFromPath.js"(exports2, module2) {
    var normalizeEntityPath = require_normalizeEntityPath();
    module2.exports = (reporter) => async (entityPathParam, targetEntitySet, options, req) => {
      if (req == null) {
        req = options;
        options = {};
      }
      const entityPath = normalizeEntityPath(entityPathParam, options, req);
      const fragments = entityPath.split("/").filter((s) => s);
      let currentEntity = null;
      let currentEntitySet = null;
      let currentFolder = null;
      if (targetEntitySet) {
        const entitySet = reporter.documentStore.model.entitySets[targetEntitySet];
        if (!entitySet) {
          throw new Error(`Target entity set "${targetEntitySet}" does not exists`);
        }
        if (!entitySet.entityTypeDef.name) {
          throw new Error(`Entity set "${targetEntitySet}" does not have a name attribute`);
        }
      }
      if (fragments.length === 0) {
        return;
      }
      const lastIndex = fragments.length - 1;
      for (const [index, entityName] of fragments.entries()) {
        if (lastIndex === index) {
          if (!targetEntitySet) {
            for (const c of Object.keys(reporter.documentStore.collections)) {
              if (!reporter.documentStore.model.entitySets[c].entityTypeDef.name) {
                continue;
              }
              const query = getSearchQuery(entityName, currentFolder);
              currentEntitySet = c;
              currentEntity = await reporter.documentStore.collection(c).findOne(query, req);
              if (currentEntity) {
                break;
              }
            }
          } else {
            const query = getSearchQuery(entityName, currentFolder);
            currentEntitySet = targetEntitySet;
            currentEntity = await reporter.documentStore.collection(targetEntitySet).findOne(query, req);
          }
        } else {
          const query = getSearchQuery(entityName, currentFolder);
          const folder = await reporter.documentStore.collection("folders").findOne(query, req);
          if (!folder) {
            break;
          }
          currentFolder = folder;
        }
      }
      if (!currentEntity) {
        return;
      }
      return {
        entitySet: currentEntitySet,
        entity: currentEntity
      };
    };
    function getSearchQuery(name, currentFolder) {
      const query = {
        name
      };
      if (currentFolder) {
        query.folder = { shortid: currentFolder.shortid };
      } else {
        query.folder = null;
      }
      return query;
    }
  }
});

// node_modules/@jsreport/jsreport-core/lib/shared/folders/index.js
var require_folders2 = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/shared/folders/index.js"(exports2, module2) {
    var resolveFolderFromPath = require_resolveFolderFromPath();
    var resolveEntityFromPath = require_resolveEntityFromPath();
    var resolveEntityPath = require_resolveEntityPath();
    module2.exports = (reporter) => {
      return {
        resolveEntityPath: resolveEntityPath(reporter),
        resolveFolderFromPath: resolveFolderFromPath(reporter),
        resolveEntityFromPath: resolveEntityFromPath(reporter)
      };
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/shared/tempFilesHandler.js
var require_tempFilesHandler = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/shared/tempFilesHandler.js"(exports2, module2) {
    var path = require("path");
    var fs = require("fs");
    var fsAsync = require("fs/promises");
    var { v4: uuidv4 } = (init_esm_node(), __toCommonJS(esm_node_exports));
    module2.exports.ensureTempDirectoryExists = async function(tempDirectory) {
      await fsAsync.mkdir(tempDirectory, {
        recursive: true
      });
      return {
        directoryPath: tempDirectory
      };
    };
    module2.exports.getTempFilePath = getTempFilePath;
    module2.exports.readTempFileSync = function readTempFileSync(tempDirectory, filename, opts = {}) {
      const { pathToFile } = getTempFilePath(tempDirectory, filename);
      const content = fs.readFileSync(pathToFile, opts);
      return {
        pathToFile,
        filename,
        content
      };
    };
    module2.exports.openTempFile = async function(tempDirectory, filenameFn, flags) {
      const { pathToFile, filename } = getTempFilePath(tempDirectory, filenameFn);
      const fileHandle = await fsAsync.open(pathToFile, flags);
      return {
        pathToFile,
        filename,
        fileHandle
      };
    };
    module2.exports.readTempFile = async function readTempFile(tempDirectory, filename, opts = {}) {
      const { pathToFile } = getTempFilePath(tempDirectory, filename);
      const content = await fsAsync.readFile(pathToFile, opts);
      return {
        pathToFile,
        filename,
        content
      };
    };
    module2.exports.readTempFileStream = function readTempFileStream(tempDirectory, filename, opts = {}) {
      const { pathToFile } = getTempFilePath(tempDirectory, filename);
      const stream = fs.createReadStream(pathToFile, opts);
      return {
        pathToFile,
        filename,
        stream
      };
    };
    module2.exports.writeTempFileSync = function writeTempFileSync(tempDirectory, filenameOrFn, content, opts = {}) {
      return writeFileSync(tempDirectory, filenameOrFn, content, opts);
    };
    module2.exports.writeTempFile = async function writeTempFile(tempDirectory, filenameOrFn, content, opts = {}) {
      return writeFile(tempDirectory, filenameOrFn, content, opts);
    };
    module2.exports.writeTempFileStream = async function writeTempFileStream(tempDirectory, filenameOrFn, opts = {}) {
      return writeFile(tempDirectory, filenameOrFn, void 0, opts, true);
    };
    module2.exports.copyFileToTempFile = async function copyFileToTempFile(tempDirectory, srcFilePath, destFilenameOrFn, mode) {
      const { pathToFile, filename } = getTempFilePath(tempDirectory, destFilenameOrFn);
      await fsAsync.mkdir(tempDirectory, {
        recursive: true
      });
      await fsAsync.copyFile(srcFilePath, pathToFile, mode);
      return {
        pathToFile,
        filename
      };
    };
    function getTempFilePath(tempDirectory, filenameOrFn) {
      const filenameResult = typeof filenameOrFn === "function" ? filenameOrFn(uuidv4()) : filenameOrFn;
      if (filenameResult == null || filenameResult === "") {
        throw new Error("No valid filename");
      }
      const pathToFile = path.isAbsolute(filenameResult) ? filenameResult : path.join(tempDirectory, filenameResult);
      const filename = path.basename(pathToFile);
      return {
        pathToFile,
        filename
      };
    }
    function writeFileSync(tempDirectory, filenameOrFn, content, opts) {
      const { pathToFile, filename } = getTempFilePath(tempDirectory, filenameOrFn);
      fs.mkdirSync(tempDirectory, {
        recursive: true
      });
      fs.writeFileSync(pathToFile, content, opts);
      return {
        pathToFile,
        filename
      };
    }
    async function writeFile(tempDirectory, filenameOrFn, content, opts, asStream = false) {
      const { pathToFile, filename } = getTempFilePath(tempDirectory, filenameOrFn);
      await fsAsync.mkdir(tempDirectory, {
        recursive: true
      });
      if (asStream === true) {
        const stream = fs.createWriteStream(pathToFile, opts);
        return {
          pathToFile,
          filename,
          stream
        };
      } else {
        await fsAsync.writeFile(pathToFile, content, opts);
        return {
          pathToFile,
          filename
        };
      }
    }
  }
});

// node_modules/@jsreport/jsreport-core/lib/shared/encryption.js
var require_encryption = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/shared/encryption.js"(exports2, module2) {
    var crypto4 = require("crypto");
    module2.exports = (reporter) => {
      const DEFAULT_ENCRYPTION = "aes-128-gcm";
      const DEFAULT_IV_LENGTH = 16;
      const prefix = "jrEncrypt";
      function getEncryptionOpts(opts) {
        let secret = opts.secret;
        let encryption = opts.encryption;
        let ivLength = opts.ivLength;
        if (!secret && reporter.options.encryption) {
          secret = reporter.options.encryption.secretKey;
        }
        if (!encryption) {
          encryption = DEFAULT_ENCRYPTION;
        }
        if (!ivLength) {
          ivLength = DEFAULT_IV_LENGTH;
        }
        return {
          secret,
          encryption,
          ivLength
        };
      }
      async function encrypt(text, opts = {}) {
        if (reporter.options.encryption && reporter.options.encryption.enabled === false) {
          return text;
        }
        const { secret, encryption, ivLength } = getEncryptionOpts(opts);
        if (!secret) {
          throw reporter.createError('using reporter.encryption.encrypt requires to specify a secret, make sure to pass one or to define the "options.encryption.secretKey" option in config', {
            statusCode: 400,
            encryptionNoSecret: true
          });
        }
        const iv = crypto4.randomBytes(ivLength);
        const cipher = crypto4.createCipheriv(encryption, Buffer.from(secret), iv);
        let encrypted = cipher.update(text);
        encrypted = Buffer.concat([encrypted, cipher.final()]);
        const authTag = cipher.getAuthTag();
        return `${prefix}$${authTag.toString("hex")}:${iv.toString("hex")}:${encrypted.toString("hex")}`;
      }
      async function decrypt(rawText, opts = {}) {
        const isTextEncrypted = isEncrypted(rawText);
        if (isTextEncrypted && reporter.options.encryption.enabled === false) {
          throw reporter.createError('using reporter.encryption.decrypt to restore encrypted value requires to enable encryption, make sure to enable it using "options.encryption.enabled" option in config', {
            statusCode: 400,
            encryptionDisabled: true
          });
        }
        if (!isTextEncrypted) {
          return rawText;
        }
        const { secret, encryption } = getEncryptionOpts(opts);
        if (!secret) {
          throw reporter.createError('using reporter.encryption.decrypt requires to specify a secret, make sure to pass one or to define the "options.encryption.secretKey" option in config', {
            statusCode: 400,
            encryptionNoSecret: true
          });
        }
        try {
          const text = rawText.replace(new RegExp("^" + prefix + "\\$"), "");
          const textParts = text.split(":");
          const authTag = Buffer.from(textParts.shift(), "hex");
          const iv = Buffer.from(textParts.shift(), "hex");
          const encryptedText = Buffer.from(textParts.join(":"), "hex");
          const decipher = crypto4.createDecipheriv(encryption, Buffer.from(secret), iv);
          decipher.setAuthTag(authTag);
          let decrypted = decipher.update(encryptedText);
          decrypted = Buffer.concat([decrypted, decipher.final()]);
          return decrypted.toString();
        } catch (e) {
          throw reporter.createError(`reporter.encryption.decrypt failed, make sure "options.encryption.secretKey" was not changed and you are using the same key which was used to encrypt content. ${e.message}`, {
            statusCode: 400,
            encryptionDecryptFail: true
          });
        }
      }
      function isEncrypted(text) {
        if (text == null) {
          return false;
        }
        const regExp = new RegExp("^" + prefix + "\\$[^:\\s]+:[^:\\s]+");
        return regExp.test(text);
      }
      return { encrypt, decrypt, isEncrypted };
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/shared/generateRequestId.js
var require_generateRequestId = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/shared/generateRequestId.js"(exports2, module2) {
    var { customAlphabet } = require_nanoid();
    var nanoid = customAlphabet("0123456789abcdefghijklmnopqrstuvwxyz", 15);
    module2.exports = () => nanoid();
  }
});

// node_modules/@jsreport/jsreport-core/lib/shared/reqStorage.js
var require_reqStorage = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/shared/reqStorage.js"(exports2, module2) {
    module2.exports = (reporter) => {
      const runningReqMap = /* @__PURE__ */ new Map();
      return {
        set: (key, val, req) => {
          const keyValueMap = runningReqMap.get(req.context.rootId);
          keyValueMap.set(key, val);
        },
        get: (key, req) => {
          const keyValueMap = runningReqMap.get(req.context.rootId);
          return keyValueMap.get(key);
        },
        registerReq: (req) => {
          runningReqMap.set(req.context.rootId, /* @__PURE__ */ new Map());
        },
        unregisterReq: (req) => {
          runningReqMap.delete(req.context.rootId);
        }
      };
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/shared/reporter.js
var require_reporter = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/shared/reporter.js"(exports2, module2) {
    var EventEmitter = require("events");
    var createListenerCollection = require_listenerCollection();
    var Request = require_request();
    var Response = require_response();
    var Templates = require_templates2();
    var Folders = require_folders2();
    var createOrExtendError = require_createError();
    var tempFilesHandler = require_tempFilesHandler();
    var encryption = require_encryption();
    var generateRequestId = require_generateRequestId();
    var adminRequest = require_adminRequest();
    var ReqStorage = require_reqStorage();
    var Reporter = class extends EventEmitter {
      constructor(options) {
        super();
        this.options = options || {};
        this.Request = Request;
        this.Response = (...args) => Response(this, ...args);
        this.adminRequest = adminRequest;
        this.reqStorage = ReqStorage(this);
        this.setMaxListeners(Infinity);
        const coreVersion = require_package2().version;
        this.version = coreVersion;
        this.coreVersion = coreVersion;
        this.initializeListeners = this.createListenerCollection("initialize");
        this.afterRenderListeners = this.createListenerCollection("afterRender");
        this.renderErrorListeners = this.createListenerCollection("renderError");
        this.beforeRenderListeners = this.createListenerCollection("beforeRender");
        this.closeListeners = this.createListenerCollection("close");
      }
      createListenerCollection(name) {
        return createListenerCollection(name);
      }
      /**
       *  Creates a custom error or extends an existing one
       *
       * @public
       */
      createError(message, options = {}) {
        return createOrExtendError(message, options);
      }
      generateRequestId() {
        return generateRequestId();
      }
      /**
       * @public Ensures that we get the proper report timeout in case when custom timeout per request was enabled
       */
      getReportTimeout(req) {
        const elapsedTime = req.context.startTimestamp ? (/* @__PURE__ */ new Date()).getTime() - req.context.startTimestamp : 0;
        if (this.options.enableRequestReportTimeout && req.options != null && req.options.timeout != null) {
          return Math.max(0, req.options.timeout - elapsedTime);
        }
        return Math.max(0, this.options.reportTimeout - elapsedTime);
      }
      /**
       * Ensures that the jsreport auto-cleanup temp directory (options.tempAutoCleanupDirectory) exists by doing a mkdir call
       *
       * @public
       */
      async ensureTempDirectoryExists() {
        if (this.options.tempAutoCleanupDirectory == null) {
          throw new Error("Can not use ensureTempDirectoryExists when tempAutoCleanupDirectory option is not initialized, make sure to initialize jsreport first using jsreport.init()");
        }
        return tempFilesHandler.ensureTempDirectoryExists(this.options.tempAutoCleanupDirectory);
      }
      getTempFilePath(filename) {
        if (this.options.tempAutoCleanupDirectory == null) {
          throw new Error("Can not use getTempFilename when tempAutoCleanupDirectory option is not initialized, make sure to initialize jsreport first using jsreport.init()");
        }
        return tempFilesHandler.getTempFilePath(this.options.tempAutoCleanupDirectory, filename);
      }
      /**
       * Synchronously reads a file from the jsreport auto-cleanup temp directory (options.tempAutoCleanupDirectory)
       *
       * @public
       */
      readTempFileSync(filename, opts) {
        if (this.options.tempAutoCleanupDirectory == null) {
          throw new Error("Can not use readTempFileSync when tempAutoCleanupDirectory option is not initialized, make sure to initialize jsreport first using jsreport.init()");
        }
        return tempFilesHandler.readTempFileSync(this.options.tempAutoCleanupDirectory, filename, opts);
      }
      /**
       * Reads a file from the jsreport auto-cleanup temp directory (options.tempAutoCleanupDirectory)
       *
       * @public
       */
      async readTempFile(filename, opts) {
        if (this.options.tempAutoCleanupDirectory == null) {
          throw new Error("Can not use readTempFile when tempAutoCleanupDirectory option is not initialized, make sure to initialize jsreport first using jsreport.init()");
        }
        return tempFilesHandler.readTempFile(this.options.tempAutoCleanupDirectory, filename, opts);
      }
      /**
       * Open temp file in jsreport auto-cleanup temp directory (options.tempAutoCleanupDirectory)
       *
       * @public
       */
      async openTempFile(filename, flags) {
        if (this.options.tempAutoCleanupDirectory == null) {
          throw new Error("Can not use openTempFile when tempAutoCleanupDirectory option is not initialized, make sure to initialize jsreport first using jsreport.init()");
        }
        return tempFilesHandler.openTempFile(this.options.tempAutoCleanupDirectory, filename, flags);
      }
      /**
       * Synchronously creates a file into the jsreport auto-cleanup temp directory (options.tempAutoCleanupDirectory)
       * ensuring that the directory always exists
       *
       * @public
       */
      writeTempFileSync(filenameFn, content, opts) {
        if (this.options.tempAutoCleanupDirectory == null) {
          throw new Error("Can not use writeTempFileSync when tempAutoCleanupDirectory option is not initialized, make sure to initialize jsreport first using jsreport.init()");
        }
        return tempFilesHandler.writeTempFileSync(this.options.tempAutoCleanupDirectory, filenameFn, content, opts);
      }
      /**
       * Creates a file into the jsreport auto-cleanup temp directory (options.tempAutoCleanupDirectory)
       * ensuring that the directory always exists
       *
       * @public
       */
      async writeTempFile(filenameFn, content, opts) {
        if (this.options.tempAutoCleanupDirectory == null) {
          throw new Error("Can not use writeTempFile when tempAutoCleanupDirectory option is not initialized, make sure to initialize jsreport first using jsreport.init()");
        }
        return tempFilesHandler.writeTempFile(this.options.tempAutoCleanupDirectory, filenameFn, content, opts);
      }
      /**
       * Reads a file as stream from the jsreport auto-cleanup temp directory (options.tempAutoCleanupDirectory)
       *
       * @public
       */
      readTempFileStream(filename, opts) {
        if (this.options.tempAutoCleanupDirectory == null) {
          throw new Error("Can not use readTempFileStream when tempAutoCleanupDirectory option is not initialized, make sure to initialize jsreport first using jsreport.init()");
        }
        return tempFilesHandler.readTempFileStream(this.options.tempAutoCleanupDirectory, filename, opts);
      }
      /**
       * Creates a file as stream into the jsreport auto-cleanup temp directory (options.tempAutoCleanupDirectory)
       * ensuring that the directory always exists
       *
       * @public
       */
      async writeTempFileStream(filenameFn, opts) {
        if (this.options.tempAutoCleanupDirectory == null) {
          throw new Error("Can not use writeTempFileStream when tempAutoCleanupDirectory option is not initialized, make sure to initialize jsreport first using jsreport.init()");
        }
        return tempFilesHandler.writeTempFileStream(this.options.tempAutoCleanupDirectory, filenameFn, opts);
      }
      /**
       * Copies a file into the jsreport auto-cleanup temp directory (options.tempAutoCleanupDirectory)
       * ensuring that the directory always exists
       *
       * @public
       */
      async copyFileToTempFile(srcFilePath, destFilenameFn, mode) {
        if (this.options.tempAutoCleanupDirectory == null) {
          throw new Error("Can not use copyToTempFile when tempAutoCleanupDirectory option is not initialized, make sure to initialize jsreport first using jsreport.init()");
        }
        return tempFilesHandler.copyFileToTempFile(this.options.tempAutoCleanupDirectory, srcFilePath, destFilenameFn, mode);
      }
      async init() {
        this.templates = Templates(this);
        this.folders = Folders(this);
        this.encryption = encryption(this);
      }
    };
    module2.exports = Reporter;
  }
});

// node_modules/yieldable-json/yieldable-parser.js
var require_yieldable_parser = __commonJS({
  "node_modules/yieldable-json/yieldable-parser.js"(exports2) {
    "use strict";
    var parseWrapper = (text, reviver, intensity, cb) => {
      let counter = 0;
      let keyN = 0;
      let parseStr = text;
      let at = 0;
      let ch = " ";
      let word = "";
      function ParseError(m) {
        this.name = "ParseError";
        this.message = m;
        this.text = parseStr;
      }
      let seek = () => {
        ch = parseStr.charAt(at);
        at++;
        while (ch && ch <= " ") {
          seek();
        }
        return ch;
      };
      let unseek = () => {
        ch = parseStr.charAt(--at);
      };
      let wordCheck = () => {
        word = "";
        do {
          word += ch;
          seek();
        } while (ch.match(/[a-z]/i));
        parseStr = parseStr.slice(at - 1);
        at = 0;
        return word;
      };
      let normalizeUnicodedString = () => {
        let inQuotes = " ";
        let tempIndex = at;
        let index = 0;
        let slash = 0;
        let c = '"';
        while (c) {
          index = parseStr.indexOf('"', tempIndex + 1);
          tempIndex = index;
          ch = parseStr.charAt(tempIndex - 1);
          while (ch === "\\") {
            slash++;
            ch = parseStr.charAt(tempIndex - (slash + 1));
          }
          if (slash % 2 === 0) {
            inQuotes = parseStr.substring(at, index);
            parseStr = parseStr.slice(++index);
            slash = 0;
            break;
          } else
            slash = 0;
        }
        index = inQuotes.indexOf("\\");
        while (index >= 0) {
          let escapee = {
            '"': '"',
            "'": "'",
            "/": "/",
            "\\": "\\",
            b: "\b",
            f: "\f",
            n: "\n",
            r: "\r",
            t: "	"
          };
          let hex = 0;
          let i = 0;
          let uffff = 0;
          at = index;
          ch = inQuotes.charAt(++at);
          if (ch === "u") {
            uffff = 0;
            for (i = 0; i < 4; i += 1) {
              hex = parseInt(ch = inQuotes.charAt(++at), 16);
              if (!isFinite(hex)) {
                break;
              }
              uffff = uffff * 16 + hex;
            }
            inQuotes = inQuotes.slice(0, index) + String.fromCharCode(uffff) + inQuotes.slice(index + 6);
            at = index;
          } else if (typeof escapee[ch] === "string") {
            inQuotes = inQuotes.slice(0, index) + escapee[ch] + inQuotes.slice(index + 2);
            at = index + 1;
          } else
            break;
          index = inQuotes.indexOf("\\", at);
        }
        at = 0;
        return inQuotes;
      };
      function* parseYield() {
        let key = "";
        let returnObj = {};
        let returnArr = [];
        let v = "";
        let inQuotes = "";
        let num = 0;
        let numHolder = "";
        let addup = () => {
          numHolder += ch;
          seek();
        };
        if (typeof parseStr === "number" || typeof parseStr === "boolean" || parseStr === null) {
          parseStr = "";
          return text;
        } else if (typeof parseStr === "undefined") {
          parseStr = void 0;
          return text;
        } else if (parseStr.charAt(0) === "[" && parseStr.charAt(1) === "]") {
          parseStr = "";
          return [];
        } else if (parseStr.charAt(0) === "{" && parseStr.charAt(1) === "}") {
          parseStr = "";
          return {};
        } else {
          if (++counter > 512 * intensity) {
            counter = 0;
            yield;
          }
          if (keyN !== 1)
            seek();
          switch (ch) {
            case "{":
              seek();
              if (ch === "}") {
                parseStr = parseStr.slice(at);
                at = 0;
                return returnObj;
              }
              do {
                if (ch !== '"')
                  seek();
                keyN = 1;
                key = yield* parseYield();
                keyN = 0;
                seek();
                returnObj[key] = yield* parseYield();
                seek();
                if (ch === "}") {
                  parseStr = parseStr.slice(at);
                  at = 0;
                  return returnObj;
                }
              } while (ch === ",");
              return new ParseError("Bad object");
            case "[":
              seek();
              if (ch === "]") {
                parseStr = parseStr.slice(at);
                at = 0;
                return returnArr;
              }
              unseek();
              do {
                v = yield* parseYield();
                returnArr.push(v);
                seek();
                if (ch === "]") {
                  parseStr = parseStr.slice(at);
                  at = 0;
                  return returnArr;
                }
              } while (ch === ",");
              return new ParseError("Bad array");
            case '"':
              parseStr = parseStr.slice(at - 1);
              at = 0;
              if (parseStr.charAt(0) === '"' && parseStr.charAt(1) === '"') {
                parseStr = parseStr.slice(2);
                at = 0;
                return inQuotes;
              } else {
                seek();
                return normalizeUnicodedString();
              }
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
            case "-":
              if (ch === "-") addup();
              do {
                addup();
                if (ch === "." || ch === "e" || ch === "E" || ch === "-" || ch === "+" || ch >= String.fromCharCode(65) && ch <= String.fromCharCode(70))
                  addup();
              } while (ch === "-" || ch === "+" || isFinite(ch) && ch !== "");
              num = Number(numHolder);
              parseStr = parseStr.slice(at - 1);
              at = 0;
              return num;
            case "t":
              word = wordCheck();
              if (word === "true")
                return true;
              else return new ParseError("Unexpected character");
            case "f":
              word = wordCheck();
              if (word === "false")
                return false;
              else return new ParseError("Unexpected character");
            case "n":
              word = wordCheck();
              if (word === "null")
                return null;
              else return new ParseError("Unexpected character");
            default:
              return new ParseError("Unexpected character");
          }
        }
      }
      let revive = (yieldedObject, key) => {
        let k = "";
        let v = "";
        let val = yieldedObject[key];
        if (val && typeof val === "object") {
          for (k in val) {
            if (Object.prototype.hasOwnProperty.call(val, k)) {
              v = revive(val, k);
              if (v !== void 0)
                val[k] = v;
              else
                delete val[k];
            }
          }
        }
        return reviver.call(yieldedObject, key, val);
      };
      let yielding = "";
      function* yieldBridge() {
        yielding = yield* parseYield();
      }
      let rs = yieldBridge();
      let gen = rs.next();
      let yieldCPU = () => {
        setImmediate(() => {
          gen = rs.next();
          if (gen && gen.done === true) {
            let isEmpty = (value) => {
              if (value.charAt(0) === "}" || value.charAt(0) === "]")
                value = value.substring(1, value.length);
              return typeof value === "string" && !value.trim();
            };
            if (typeof yielding === "undefined")
              return cb(new ParseError("Unexpected Character"), null);
            else if (yielding instanceof ParseError)
              return cb(yielding, null);
            else if (!isEmpty(parseStr))
              return cb(new ParseError("Unexpected Character"), null);
            else {
              if (reviver !== null) {
                if (typeof reviver === "function") {
                  let result = revive({ "": yielding }, "");
                  return cb(null, result);
                }
              } else
                return cb(null, yielding);
            }
          }
          yieldCPU();
        });
      };
      return yieldCPU();
    };
    exports2.parseWrapper = parseWrapper;
  }
});

// node_modules/yieldable-json/yieldable-stringify.js
var require_yieldable_stringify = __commonJS({
  "node_modules/yieldable-json/yieldable-stringify.js"(exports2) {
    "use strict";
    var counter = 0;
    var objStack = [];
    var temp = "";
    var limit = 1e5;
    function StringifyError(m) {
      this.name = "Error";
      this.message = m;
    }
    var normalize = (string, flagN) => {
      let retStr = "";
      let transform = "";
      let uc = "/[\\'\0-\x7F-\x9F\xAD\u0600-\u0604\u070F\u17B4\u17B5\u200C-\u200F\u2028-\u202F\u2060-\u206F\uFEFF\uFFF0-\uFFFF]/g";
      let unicode = new RegExp(uc);
      string = string.replace(/\\/gi, "\\\\");
      let escape = {
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"'
      };
      for (var pattern in escape) {
        var regex = new RegExp(pattern, "gi");
        string = string.replace(regex, escape[pattern]);
      }
      unicode.lastIndex = 0;
      if (unicode.test(string)) {
        transform = string.replace(unicode, (a) => {
          return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        });
        if (flagN === 1) {
          transform += temp;
          transform += transform;
          temp = "";
          return '"' + transform + '"';
        } else if (flagN === 2) {
          return '"' + transform + '"';
        } else {
          temp += transform;
        }
      } else {
        if (flagN === 1) {
          retStr += temp;
          retStr += string;
          temp = "";
          return '"' + retStr + '"';
        } else if (flagN === 2) {
          return '"' + string + '"';
        } else {
          temp += string;
          return;
        }
      }
    };
    function* stringifyYield(field, container, replacer, space, intensity) {
      let itr = 0;
      let key = "";
      let val = "";
      let length = 0;
      let tempVal = "";
      let result = "";
      let value = container[field];
      let flag1 = 0;
      let returnStr = "";
      let subStr = "";
      let len = 0;
      if (++counter > 512 * intensity) {
        counter = 0;
        yield val;
      }
      if (typeof replacer === "function") {
        value = replacer.call(container, field, value);
      }
      switch (typeof value) {
        case "string":
          if (value.length > limit) {
            for (let l = 0; l < value.length; l += limit) {
              flag1 = 0;
              yield value;
              subStr = value.substr(l, limit);
              len += subStr.length;
              if (len === value.length)
                flag1 = 1;
              returnStr = normalize(subStr, flag1);
            }
          } else
            returnStr = normalize(value, 2);
          return returnStr;
        case "number":
          return isFinite(value) ? String(value) : "null";
        case "boolean":
        case "null":
          return String(value);
        case "undefined":
          return;
        case "object":
          if (!value)
            return "null";
          let getResult = (decision) => {
            if (result.length === 0)
              if (decision)
                return "{}";
              else
                return "[]";
            else if (decision)
              if (space)
                return "{\n" + space + result.join(",\n" + space) + "\n}";
              else
                return "{" + result.join(",") + "}";
            else if (space)
              return "[\n" + space + result.join(",\n" + space) + "\n]";
            else
              return "[" + result.join(",") + "]";
          };
          result = [];
          if (value && typeof value.toJSON === "function") {
            result.push('"' + value.toJSON(field) + '"');
            if (result.length === 0)
              return "{}";
            else if (space)
              return space + result.join(",\n" + space) + "\n";
            else
              return result.join(",");
          }
          if (value && value.constructor === Array) {
            length = value.length;
            for (itr = 0; itr < length; itr += 1) {
              tempVal = yield* stringifyYield(itr, value, replacer, space, intensity) || "null";
              if (tempVal !== void 0)
                result.push(tempVal);
            }
            return getResult(false);
          }
          if (replacer && typeof replacer === "object") {
            length = replacer.length;
            for (itr = 0; itr < length; itr += 1) {
              if (typeof replacer[itr] === "string") {
                key = replacer[itr];
                val = yield* stringifyYield(key, value, replacer, space, intensity);
                if (val !== void 0)
                  result.push(normalize(key, 2) + (space ? ": " : ":") + val);
              }
            }
          } else {
            objStack.push(value);
            for (key in value) {
              if (typeof value[key] === "object" && value[key] !== null && value[key] !== void 0) {
                if (objStack.indexOf(value[key]) !== -1) {
                  return new StringifyError("Circular Structure Detected");
                } else
                  objStack.push(value[key]);
              }
              if (Object.hasOwnProperty.call(value, key)) {
                val = yield* stringifyYield(key, value, replacer, space, intensity);
                if (val !== void 0)
                  result.push(normalize(key, 2) + (space ? ": " : ":") + val);
              }
              objStack = objStack.filter((v, i, a) => {
                return v !== value[key];
              });
            }
            objStack = objStack.filter((v, i, a) => {
              return v !== value;
            });
          }
          return getResult(true);
        default:
          return new StringifyError("Unexpected Character");
      }
    }
    var stringifyWrapper = (value, replacer, space, intensity, callback) => {
      let indent = "";
      if (typeof space === "number") {
        indent = " ".repeat(space);
      } else if (typeof space === "string") {
        indent = space;
      }
      let yielding;
      function* yieldBridge() {
        yielding = yield* stringifyYield("", { "": value }, replacer, indent, 1);
      }
      let rs = yieldBridge();
      let g = rs.next();
      let yieldCPU = () => {
        setImmediate(() => {
          g = rs.next();
          if (g && g.done === true) {
            counter = 0;
            temp = "";
            objStack = [];
            if (typeof yielding === "object")
              return callback(yielding, null);
            else
              return callback(null, yielding);
          }
          yieldCPU();
        });
      };
      return yieldCPU();
    };
    exports2.stringifyWrapper = stringifyWrapper;
  }
});

// node_modules/yieldable-json/index.js
var require_yieldable_json = __commonJS({
  "node_modules/yieldable-json/index.js"(exports2, module2) {
    "use strict";
    var pa = require_yieldable_parser();
    var ps = require_yieldable_stringify();
    var validateSpace = (space) => {
      if (typeof space === "number") {
        space = Math.round(space);
        if (space >= 1 && space <= 10)
          return space;
        else if (space < 1)
          return 0;
        else
          return 10;
      } else {
        if (space.length <= 10)
          return space;
        else
          return space.substr(0, 9);
      }
    };
    var validateIntensity = (intensity) => {
      intensity = Math.round(intensity);
      if (intensity > 0 && intensity <= 32)
        return intensity;
      else if (intensity <= 0)
        return 1;
      else
        return 32;
    };
    module2.exports = {
      /**
      * Error checking  and call of appropriate functions for JSON parse
      * @param { primitive data types } data
      * @param { function or array } reviver
      * @param { number } intensity
      * @param { function } callback
      * @return { function } parseWrapper
      */
      parseAsync(data, reviver, intensity, callback) {
        const argv = arguments;
        if (Buffer.isBuffer(data))
          data = data.toString();
        if (argv.length < 2)
          throw new Error("Missing Callback");
        if (typeof argv[argv.length - 1] === "function") {
          callback = argv[argv.length - 1];
          reviver = null;
          intensity = 1;
        } else
          throw new TypeError("Callback is not a function");
        if (argv.length > 2) {
          let i = 1;
          if (typeof argv[i] === "function")
            reviver = argv[i++];
          if (typeof argv[i] === "number")
            intensity = validateIntensity(argv[i]);
        }
        return pa.parseWrapper(data, reviver, intensity, callback);
      },
      /**
      * Error checking  and call of appropriate functions for JSON stringify API
      * @param { primitive data types } data
      * @param { function or array } replacer
      * @param { number or string } space
      * @param { number } intensity
      * @param { function } callback
      * @return { function } stringifyWrapper
      */
      stringifyAsync(data, replacer, space, intensity, callback) {
        const argv = arguments;
        if (typeof argv[argv.length - 1] === "function") {
          callback = argv[argv.length - 1];
          replacer = null;
          intensity = 1;
        } else
          throw new TypeError("Callback is not a function");
        if (argv.length > 2) {
          let i = 1;
          if (typeof argv[i] === "function" || typeof argv[i] === "object")
            replacer = argv[i++];
          if ((typeof argv[i] === "number" || typeof argv[i] === "string") && typeof argv[i++] === "number")
            space = validateSpace(argv[i++]);
          if (typeof argv[i] === "number")
            intensity = validateIntensity(argv[i]);
        }
        return ps.stringifyWrapper(data, replacer, space, intensity, callback);
      }
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/profiler.js
var require_profiler2 = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/profiler.js"(exports2, module2) {
    var EventEmitter = require("events");
    var Transport = require_winston_transport();
    var extend = require_node_extend_without();
    var generateRequestId = require_generateRequestId();
    var fs = require("fs/promises");
    var { SPLAT } = require_triple_beam();
    var promisify = require("util").promisify;
    var stringifyAsync = promisify(require_yieldable_json().stringifyAsync);
    module2.exports = (reporter) => {
      reporter.documentStore.registerEntityType("ProfileType", {
        templateShortid: { type: "Edm.String", referenceTo: "templates" },
        timestamp: { type: "Edm.DateTimeOffset", schema: { type: "null" } },
        finishedOn: { type: "Edm.DateTimeOffset", schema: { type: "null" } },
        state: { type: "Edm.String" },
        error: { type: "Edm.String" },
        mode: { type: "Edm.String", schema: { enum: ["full", "standard", "disabled"] } },
        blobName: { type: "Edm.String" },
        timeout: { type: "Edm.Int32" }
      });
      reporter.documentStore.registerEntitySet("profiles", {
        entityType: "jsreport.ProfileType",
        exportable: false
      });
      const profilersMap = /* @__PURE__ */ new Map();
      const profilerOperationsChainsMap = /* @__PURE__ */ new Map();
      const profilerRequestMap = /* @__PURE__ */ new Map();
      function runInProfilerChain(fnOrOptions, req) {
        if (req.context.profiling == null || req.context.profiling.mode === "disabled") {
          return;
        }
        let fn;
        let cleanFn;
        if (typeof fnOrOptions === "function") {
          fn = fnOrOptions;
        } else {
          fn = fnOrOptions.fn;
          cleanFn = fnOrOptions.cleanFn;
        }
        if (!profilerOperationsChainsMap.has(req.context.rootId)) {
          return;
        }
        profilerOperationsChainsMap.set(req.context.rootId, profilerOperationsChainsMap.get(req.context.rootId).then(async () => {
          if (cleanFn) {
            cleanFn();
          }
          if (req.context.profiling.chainFailed) {
            return;
          }
          try {
            if (fn) {
              await fn();
            }
          } catch (e) {
            reporter.logger.warn("Failed persist profile", e);
            req.context.profiling.chainFailed = true;
          }
        }));
      }
      function createProfileMessage(m, req) {
        m.timestamp = (/* @__PURE__ */ new Date()).getTime();
        m.id = generateRequestId();
        m.previousOperationId = m.previousOperationId || null;
        if (m.type !== "log") {
          m.operationId = m.operationId || generateRequestId();
          req.context.profiling.lastOperationId = m.operationId;
          req.context.profiling.lastEventId = m.id;
        }
        return m;
      }
      function emitProfiles({ events, log = true }, req) {
        if (events.length === 0) {
          return;
        }
        let lastOperation;
        for (const m of events) {
          if (m.type === "log") {
            if (log) {
              reporter.logger[m.level](m.message, { ...req, ...m.meta, timestamp: m.timestamp, logged: true });
            }
          } else {
            lastOperation = m;
          }
          if (profilersMap.has(req.context.rootId)) {
            profilersMap.get(req.context.rootId).emit("profile", m);
          }
        }
        if (lastOperation != null) {
          req.context.profiling.lastOperation = lastOperation;
        }
        runInProfilerChain(async () => {
          const stringifiedMessages = req.context.mode === "full" ? await Promise.all(events.map((m) => stringifyAsync(m))) : events.map((m) => JSON.stringify(m));
          await fs.appendFile(req.context.profiling.logFilePath, Buffer.from(stringifiedMessages.join("\n") + "\n"));
        }, req);
      }
      reporter.registerMainAction("profile", async (eventsOrOptions, _req) => {
        let req = _req;
        if (profilerRequestMap.has(req.context.rootId) && req.__isJsreportRequest__ == null) {
          req = profilerRequestMap.get(req.context.rootId);
        }
        let events;
        let log;
        if (Array.isArray(eventsOrOptions)) {
          events = eventsOrOptions;
        } else {
          events = eventsOrOptions.events;
          log = eventsOrOptions.log;
        }
        const params = { events };
        if (log != null) {
          params.log = log;
        }
        return emitProfiles(params, req);
      });
      reporter.attachProfiler = (req, profileMode) => {
        req.context = req.context || {};
        req.context.rootId = reporter.generateRequestId();
        req.context.profiling = {
          mode: profileMode == null ? "full" : profileMode
        };
        const profiler = new EventEmitter();
        profilersMap.set(req.context.rootId, profiler);
        return profiler;
      };
      reporter.beforeRenderWorkerAllocatedListeners.add("profiler", async (req) => {
        req.context.profiling = req.context.profiling || {};
        if (req.context.profiling.enabled === false) {
          return;
        }
        if (req.context.profiling.mode == null) {
          const profilerSettings = await reporter.settings.findValue("profiler", req);
          const defaultMode = reporter.options.profiler.defaultMode || "standard";
          req.context.profiling.mode = profilerSettings != null && profilerSettings.mode != null ? profilerSettings.mode : defaultMode;
        }
        profilerOperationsChainsMap.set(req.context.rootId, Promise.resolve());
        req.context.profiling.lastOperation = null;
        const profile = {
          _id: reporter.documentStore.generateId(),
          timestamp: /* @__PURE__ */ new Date(),
          state: "queued",
          mode: req.context.profiling.mode
        };
        const { pathToFile } = await reporter.writeTempFile((uuid) => `${uuid}.log`, "");
        req.context.profiling.logFilePath = pathToFile;
        runInProfilerChain(async () => {
          req.context.skipValidationFor = profile;
          await reporter.documentStore.collection("profiles").insert(profile, req);
        }, req);
        req.context.profiling.entity = profile;
        const profileStartOperation = createProfileMessage({
          type: "operationStart",
          subtype: "profile",
          data: profile,
          doDiffs: false
        }, req);
        req.context.profiling.profileStartOperationId = profileStartOperation.operationId;
        emitProfiles({ events: [profileStartOperation] }, req);
        emitProfiles({
          events: [createProfileMessage({
            type: "log",
            level: "info",
            message: `Render request ${req.context.reportCounter} queued for execution and waiting for available worker`,
            previousOperationId: profileStartOperation.operationId
          }, req)]
        }, req);
      });
      reporter.beforeRenderListeners.add("profiler", async (req, res) => {
        const update = {
          state: "running",
          // the timeout needs to be calculated later here, because the req.options.timeout isnt yet parsed in beforeRenderWorkerAllocatedListeners
          timeout: reporter.options.enableRequestReportTimeout && req.options.timeout ? req.options.timeout : reporter.options.reportTimeout
        };
        profilerRequestMap.set(req.context.rootId, req);
        const template = await reporter.templates.resolveTemplate(req);
        if (template && template._id) {
          req.context.resolvedTemplate = extend(true, {}, template);
          update.templateShortid = template.shortid;
        }
        runInProfilerChain(() => {
          req.context.skipValidationFor = update;
          return reporter.documentStore.collection("profiles").update({
            _id: req.context.profiling.entity._id
          }, {
            $set: update
          }, req);
        }, req);
        Object.assign(req.context.profiling.entity, update);
      });
      reporter.afterRenderListeners.add("profiler", async (req, res) => {
        emitProfiles({
          events: [createProfileMessage({
            type: "operationEnd",
            doDiffs: false,
            previousEventId: req.context.profiling.lastEventId,
            previousOperationId: req.context.profiling.lastOperationId,
            operationId: req.context.profiling.profileStartOperationId
          }, req)]
        }, req);
        res.meta.profileId = req.context.profiling?.entity?._id;
        runInProfilerChain(async () => {
          let blobName = `profiles/${req.context.rootId}.log`;
          if (req.context.resolvedTemplate) {
            const templatePath = await reporter.folders.resolveEntityPath(req.context.resolvedTemplate, "templates", req);
            blobName = `profiles/${templatePath.substring(1)}/${req.context.rootId}.log`;
          }
          const content = await fs.readFile(req.context.profiling.logFilePath);
          blobName = await reporter.blobStorage.write(blobName, content, req);
          await fs.unlink(req.context.profiling.logFilePath);
          const update = {
            state: "success",
            finishedOn: /* @__PURE__ */ new Date(),
            blobName
          };
          req.context.skipValidationFor = update;
          await reporter.documentStore.collection("profiles").update({
            _id: req.context.profiling.entity._id
          }, {
            $set: update
          }, req);
        }, req);
      });
      reporter.renderErrorListeners.add("profiler", async (req, res, e) => {
        res.meta.profileId = req.context.profiling?.entity?._id;
        if (req.context.profiling?.entity != null) {
          emitProfiles({
            events: [{
              type: "error",
              timestamp: (/* @__PURE__ */ new Date()).getTime(),
              ...e,
              id: generateRequestId(),
              stack: e.stack,
              message: e.message
            }]
          }, req);
          runInProfilerChain(async () => {
            const update = {
              state: "error",
              finishedOn: /* @__PURE__ */ new Date(),
              error: e.toString()
            };
            if (req.context.profiling.logFilePath != null) {
              let blobName = `profiles/${req.context.rootId}.log`;
              if (req.context.resolvedTemplate) {
                const templatePath = await reporter.folders.resolveEntityPath(req.context.resolvedTemplate, "templates", req);
                blobName = `profiles/${templatePath.substring(1)}/${req.context.rootId}.log`;
              }
              const content = await fs.readFile(req.context.profiling.logFilePath);
              blobName = await reporter.blobStorage.write(blobName, content, req);
              await fs.unlink(req.context.profiling.logFilePath);
              update.blobName = blobName;
            }
            req.context.skipValidationFor = update;
            await reporter.documentStore.collection("profiles").update({
              _id: req.context.profiling.entity._id
            }, {
              $set: update
            }, req);
          }, req);
        }
      });
      const configuredPreviously = reporter.logger.__profilerConfigured__ === true;
      if (!configuredPreviously) {
        class EmittingProfilesTransport extends Transport {
          log(info, callback) {
            setImmediate(() => {
              this.emit("logged", info);
            });
            if (info[SPLAT]) {
              const [req] = info[SPLAT];
              if (req && req.context && req.logged !== true) {
                emitProfiles({
                  events: [createProfileMessage({
                    type: "log",
                    level: info.level,
                    message: info.message,
                    previousOperationId: req.context.profiling?.lastOperationId
                  }, req)],
                  log: false
                }, req);
              }
            }
            callback();
          }
        }
        reporter.logger.add(new EmittingProfilesTransport({
          format: reporter.logger.format,
          level: "debug"
        }));
        reporter.logger.__profilerConfigured__ = true;
      }
      let profilesCleanupInterval;
      let fullModeDurationCheckInterval;
      reporter.initializeListeners.add("profiler", async () => {
        reporter.documentStore.collection("profiles").beforeRemoveListeners.add("profiles", async (query, req) => {
          const profiles = await reporter.documentStore.collection("profiles").find(query, req);
          for (const profile of profiles) {
            if (profile.blobName != null) {
              await reporter.blobStorage.remove(profile.blobName);
            }
          }
        });
        function profilesCleanupExec() {
          return reporter._profilesCleanup();
        }
        function fullModeDurationCheckExec() {
          return reporter._profilesFullModeDurationCheck();
        }
        profilesCleanupInterval = setInterval(profilesCleanupExec, reporter.options.profiler.cleanupInterval);
        profilesCleanupInterval.unref();
        fullModeDurationCheckInterval = setInterval(fullModeDurationCheckExec, reporter.options.profiler.fullModeDurationCheckInterval);
        fullModeDurationCheckInterval.unref();
        await reporter._profilesCleanup();
      });
      reporter.closeListeners.add("profiler", async () => {
        if (profilesCleanupInterval) {
          clearInterval(profilesCleanupInterval);
        }
        if (fullModeDurationCheckInterval) {
          clearInterval(fullModeDurationCheckInterval);
        }
        for (const key of profilerOperationsChainsMap.keys()) {
          const profileAppendPromise = profilerOperationsChainsMap.get(key);
          if (profileAppendPromise) {
            await profileAppendPromise;
          }
        }
        profilersMap.clear();
        profilerOperationsChainsMap.clear();
        profilerRequestMap.clear();
      });
      let profilesCleanupRunning = false;
      reporter._profilesCleanup = async function profilesCleanup() {
        if (profilesCleanupRunning) {
          return;
        }
        profilesCleanupRunning = true;
        let lastError;
        try {
          const profilesToRemove = await reporter.documentStore.collection("profiles").find({}, { _id: 1 }).sort({ timestamp: -1 }).skip(reporter.options.profiler.maxProfilesHistory).toArray();
          for (const profile of profilesToRemove) {
            if (reporter.closed || reporter.closing) {
              return;
            }
            try {
              await reporter.documentStore.collection("profiles").remove({
                _id: profile._id
              });
            } catch (e) {
              lastError = e;
            }
          }
          const notFinishedProfiles = await reporter.documentStore.collection("profiles").find({ $or: [{ state: "running" }, { state: "queued" }] }, { _id: 1, timeout: 1, timestamp: 1 }).toArray();
          for (const profile of notFinishedProfiles) {
            if (reporter.closed || reporter.closing) {
              return;
            }
            if (!profile.timeout) {
              if (profile.timestamp.getTime() + reporter.options.profiler.maxUnallocatedProfileAge < (/* @__PURE__ */ new Date()).getTime()) {
                try {
                  await reporter.documentStore.collection("profiles").update({
                    _id: profile._id
                  }, {
                    $set: {
                      state: "error",
                      finishedOn: /* @__PURE__ */ new Date(),
                      error: `The request wasn't parsed before ${reporter.options.profiler.maxUnallocatedProfileAge}ms. This can happen when the server is unexpectedly stopped.`
                    }
                  });
                } catch (e) {
                  lastError = e;
                }
              }
              continue;
            }
            const whenShouldBeFinished = profile.timestamp.getTime() + profile.timeout + reporter.options.reportTimeoutMargin * 2;
            if (whenShouldBeFinished > (/* @__PURE__ */ new Date()).getTime()) {
              continue;
            }
            try {
              await reporter.documentStore.collection("profiles").update({
                _id: profile._id
              }, {
                $set: {
                  state: "error",
                  finishedOn: /* @__PURE__ */ new Date(),
                  error: "The server did not update the report profile before its timeout. This can happen when the server is unexpectedly stopped."
                }
              });
            } catch (e) {
              lastError = e;
            }
          }
        } catch (e) {
          reporter.logger.warn("Profile cleanup failed", e);
        } finally {
          profilesCleanupRunning = false;
        }
        if (lastError) {
          reporter.logger.warn("Profile cleanup failed for some entities, last error:", lastError);
        }
      };
      reporter._profilesFullModeDurationCheck = async function() {
        try {
          if (reporter.options.profiler.defaultMode === "full") {
            return;
          }
          const profiler = await reporter.documentStore.collection("settings").findOne({ key: "profiler" });
          if (profiler == null || profiler.modificationDate.getTime() + reporter.options.profiler.fullModeDuration > (/* @__PURE__ */ new Date()).getTime()) {
            return;
          }
          const profilerValue = JSON.parse(profiler.value);
          if (profilerValue.mode !== "full") {
            return;
          }
          reporter.logger.info("Switching full mode profiling back to standard to avoid performance degradation.");
          await reporter.settings.addOrSet("profiler", { mode: "standard" });
        } catch (e) {
          reporter.logger.warn("Failed to change profiling mode", e);
        }
      };
      return function cleanProfileInRequest(req) {
        if (req.context.profiling?.entity == null || req.context.profiling?.mode === "disabled") {
          profilersMap.delete(req.context.rootId);
          profilerOperationsChainsMap.delete(req.context.rootId);
          profilerRequestMap.delete(req.context.rootId);
          return;
        }
        runInProfilerChain({
          cleanFn: () => {
            profilersMap.delete(req.context.rootId);
            profilerOperationsChainsMap.delete(req.context.rootId);
            profilerRequestMap.delete(req.context.rootId);
          }
        }, req);
      };
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/blobStorage/inMemoryProvider.js
var require_inMemoryProvider = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/blobStorage/inMemoryProvider.js"(exports2, module2) {
    module2.exports = (options) => {
      const storage = {};
      return {
        write(blobName, buffer) {
          storage[blobName] = buffer;
          return blobName;
        },
        read(blobName) {
          return storage[blobName];
        },
        remove(blobName) {
          delete storage[blobName];
        },
        append(blobName, buffer) {
          storage[blobName] = storage[blobName] || Buffer.from("");
          storage[blobName] = Buffer.concat([storage[blobName], buffer]);
        },
        init() {
        }
      };
    };
  }
});

// node_modules/@jsreport/jsreport-core/lib/main/reporter.js
var require_reporter2 = __commonJS({
  "node_modules/@jsreport/jsreport-core/lib/main/reporter.js"(exports2, module2) {
    var path = require("path");
    var Reaper = require_reap();
    var pkg = require_package2();
    var optionsLoad = require_optionsLoad();
    var { createLogger, configureLogger, silentLogs } = require_logger2();
    var checkEntityName = require_validateEntityName();
    var DocumentStore = require_documentStore();
    var BlobStorage = require_blobStorage();
    var ExtensionsManager = require_extensionsManager();
    var Settings = require_settings();
    var SchemaValidator = require_schemaValidator();
    var { getRootSchemaOptions, extendRootSchemaOptions } = require_optionsSchema();
    var Templates = require_templates();
    var Folders = require_folders();
    var WorkersManager = require_advanced_workers();
    var { validateDuplicatedName } = require_validateDuplicatedName();
    var { validateReservedName } = require_validateReservedName();
    var setupValidateId = require_setupValidateId();
    var setupValidateShortid = require_setupValidateShortid();
    var documentStoreActions = require_mainActions();
    var blobStorageActions = require_mainActions2();
    var Reporter = require_reporter();
    var Request = require_request2();
    var Response = require_response();
    var Profiler = require_profiler2();
    var semver = require_semver2();
    var reportCounter = 0;
    var MainReporter = class extends Reporter {
      constructor(options, defaults) {
        super(options);
        if (!semver.satisfies(process.versions.node, pkg.engines.node)) {
          throw this.createError(`jsreport needs at least node ${pkg.engines.node} to run.`);
        }
        this.defaults = defaults || {};
        this._fnAfterConfigLoaded = () => {
        };
        this._reaperTimerRef = null;
        this._extraPathsToCleanupCollection = /* @__PURE__ */ new Set();
        this._initialized = false;
        this._initializing = false;
        this._initExecution = {};
        this._initExecution.promise = new Promise((resolve, reject) => {
          this._initExecution.resolve = resolve;
          this._initExecution.reject = resolve;
        });
        this._mainActions = /* @__PURE__ */ new Map();
        this.settings = new Settings();
        this.extensionsManager = ExtensionsManager(this);
        this.optionsValidator = new SchemaValidator({
          rootSchema: getRootSchemaOptions()
        });
        this.entityTypeValidator = new SchemaValidator();
        this.logger = createLogger();
        this.beforeMainActionListeners = this.createListenerCollection("beforeMainAction");
        this.beforeRenderWorkerAllocatedListeners = this.createListenerCollection("beforeRenderWorkerAllocated");
      }
      discover() {
        this.options.discover = true;
        return this;
      }
      /**
       * Manual registration of the extension. Once calling `use` the auto discovery of extensions is turned off if not explicitly
       * turned on.
       * jsreport.use(require('@jsreport/jsreport-jsrender')())
       * @param {Object || Function} extensions
       * @return {Reporter} for chaining
       * @public
       */
      use(extension) {
        this.extensionsManager.use(extension);
        return this;
      }
      async extensionsLoad(_opts = {}) {
        const [explicitOptions, appliedConfigFile] = await optionsLoad({
          defaults: this.defaults,
          options: this.options,
          validator: this.optionsValidator,
          onConfigLoaded: async () => {
            await this._fnAfterConfigLoaded(this);
          }
        });
        configureLogger(this.logger, this.options.logger);
        if (this.options.logger && this.options.logger.silent === true) {
          silentLogs(this.logger);
        }
        const { onConfigDetails, ...opts } = _opts;
        this.logger.info(`Initializing jsreport (version: ${this.version}, configuration file: ${appliedConfigFile || "none"}, nodejs: ${process.versions.node})`);
        await this.extensionsManager.load(opts);
        const newRootSchema = extendRootSchemaOptions(
          getRootSchemaOptions(),
          this.extensionsManager.availableExtensions.map((ex) => ({
            name: ex.name,
            schema: ex.optionsSchema
          }))
        );
        this.optionsValidator.setRootSchema(newRootSchema);
        const rootOptionsValidation = this.optionsValidator.validateRoot(this.options, {
          rootPrefix: "rootOptions",
          // extensions was validated already in extensions load
          ignore: ["properties.extensions"]
        });
        if (!rootOptionsValidation.valid) {
          throw new Error(`options contain values that does not match the defined full root schema. ${rootOptionsValidation.fullErrorMessage}`);
        }
        if (typeof onConfigDetails === "function") {
          onConfigDetails(explicitOptions);
        }
        return this;
      }
      /**
       * Hook to alter configuration after it was loaded and merged
       * jsreport.afterConfigLoaded(function(reporter) { .. do your stuff ..})
       *
       *
       * @public
       */
      afterConfigLoaded(fn) {
        this._fnAfterConfigLoaded = fn;
        return this;
      }
      async waitForInit() {
        await this._initExecution.promise;
      }
      /**
       * Required async method to be called before rendering.
       *
       * @return {Promise} initialization is done, promise value is Reporter instance for chaining
       * @public
       */
      async init() {
        this.closing = this.closed = false;
        if (this._initialized || this._initializing) {
          throw new Error("jsreport already initialized or just initializing. Make sure init is called only once");
        }
        super.init();
        this._initializing = true;
        try {
          this._registerLogMainAction();
          let explicitOptions;
          await this.extensionsLoad({
            onConfigDetails: (_explicitOptions) => {
              explicitOptions = _explicitOptions;
            }
          });
          this.documentStore = DocumentStore(Object.assign({}, this.options, { logger: this.logger }), this.entityTypeValidator, this.encryption);
          documentStoreActions(this);
          this.blobStorage = BlobStorage(this, this.options);
          blobStorageActions(this);
          Templates(this);
          this._cleanProfileInRequest = Profiler(this);
          this.folders = Object.assign(this.folders, Folders(this));
          this.settings.registerEntity(this.documentStore);
          this.options.blobStorage = this.options.blobStorage || {};
          if (this.options.blobStorage.provider == null) {
            this.options.blobStorage.provider = this.options.store.provider;
          }
          if (this.options.blobStorage.provider === "memory") {
            this.blobStorage.registerProvider(require_inMemoryProvider()(this.options));
          }
          await this.extensionsManager.init();
          if (this.options.trustUserCode) {
            this.logger.info("Code sandboxing is disabled, users can potentially penetrate the local system if you allow code from external users to be part of your reports");
          }
          if (!this.options.sandbox.isolateModules) {
            this.logger.info("Modules isolation is disabled, require of modules during rendering will be shared across all renders");
          }
          if (explicitOptions.trustUserCode == null && explicitOptions.allowLocalFilesAccess != null) {
            this.logger.warn("options.allowLocalFilesAccess is deprecated, use options.trustUserCode instead");
          }
          this.logger.info(`Using general timeout for rendering (reportTimeout: ${this.options.reportTimeout})`);
          if (this.options.store.provider === "memory") {
            this.logger.info(`Using ${this.options.store.provider} provider for template store. The saved templates will be lost after restart`);
          } else {
            this.logger.info(`Using ${this.options.store.provider} provider for template store.`);
          }
          await this.documentStore.init();
          await this.blobStorage.init();
          await this.settings.init(this.documentStore, {
            authentication: this.authentication,
            authorization: this.authorization
          });
          const extensionsForWorkers = this.extensionsManager.extensions.filter((e) => e.worker);
          const workersManagerOptions = {
            ...this.options.sandbox,
            options: { ...this.options },
            // we do map and copy to unproxy the value
            extensionsDefs: extensionsForWorkers.map((e) => Object.assign({}, e)),
            documentStore: {
              // we do copy to unproxy the value of entityTypes
              model: {
                ...this.documentStore.model,
                entityTypes: { ...this.documentStore.model.entityTypes }
              },
              collections: Object.keys(this.documentStore.collections)
            }
          };
          const workersManagerSystemOptions = {
            initTimeout: this.options.workers.initTimeout,
            numberOfWorkers: this.options.workers.numberOfWorkers,
            workerModule: path.join(__dirname, "../worker", "workerHandler.js"),
            resourceLimits: this.options.workers.resourceLimits
          };
          setupValidateId(this);
          setupValidateShortid(this);
          await this.initializeListeners.fire();
          this._workersManager = this._workersManagerFactory ? this._workersManagerFactory(workersManagerOptions, workersManagerSystemOptions) : WorkersManager(workersManagerOptions, workersManagerSystemOptions);
          const workersStart = (/* @__PURE__ */ new Date()).getTime();
          this.logger.info("Initializing worker threads");
          this.logger.debug(`Extensions in workers: ${extensionsForWorkers.map((e) => e.name).join(", ")}`);
          await this._workersManager.init(workersManagerOptions);
          this.logger.info(`${this.options.workers.numberOfWorkers} worker threads initialized in ${(/* @__PURE__ */ new Date()).getTime() - workersStart}ms`);
          this._startReaper(this.getPathsToWatchForAutoCleanup());
          this.extensionsManager.recipes.push({
            name: "html"
          });
          this.extensionsManager.engines.push({
            name: "none"
          });
          this.logger.info("reporter initialized");
          this._initialized = true;
          this._initExecution.resolve();
          return this;
        } catch (e) {
          this.logger.error(`Error occurred during reporter init: ${e.stack}`);
          this._initExecution.reject(new Error(`Reporter initialization failed. ${e.message}`));
          throw e;
        }
      }
      /**
       * @public
       */
      addPathToWatchForAutoCleanup(customPath) {
        this._extraPathsToCleanupCollection.add(customPath);
      }
      /**
       * @public
       */
      getPathsToWatchForAutoCleanup() {
        return [this.options.tempAutoCleanupDirectory].concat(Array.from(this._extraPathsToCleanupCollection.values()));
      }
      async checkValidEntityName(c, doc, req) {
        if (!this.documentStore.model.entitySets[c].entityTypeDef.name) {
          return;
        }
        checkEntityName(doc.name);
        await validateDuplicatedName(this, c, doc, void 0, req);
        await validateReservedName(this, c, doc);
      }
      async _handleRenderError(req, res, err) {
        if (err.code === "WORKER_TIMEOUT") {
          err.message = "Report timeout";
          if (req.context.profiling?.lastOperation != null && req.context.profiling?.entity != null) {
            err.message += `. Last profiler operation: (${req.context.profiling.lastOperation.subtype}) ${req.context.profiling.lastOperation.name}`;
          }
          if (req.context.http != null) {
            const profileUrl = `${req.context.http.baseUrl}/studio/profiles/${req.context.profiling.entity._id}`;
            err.message += `. You can inspect and find more details here: ${profileUrl}`;
          }
          err.weak = true;
        }
        if (err.code === "WORKER_ABORTED") {
          err.message = "Report cancelled by the client or closed network";
          err.weak = true;
        }
        if (!err.logged) {
          const logFn = err.weak ? this.logger.warn : this.logger.error;
          const errorMessage = this.createError("Report render failed", { original: err }).message;
          logFn(`${errorMessage}${err.stack != null ? "\n" + err.stack : ""}`, req);
        }
        await this.renderErrorListeners.fire(req, res, err);
        throw err;
      }
      /**
       * Main method for invoking rendering
       * render({ template: { content: 'foo', engine: 'none', recipe: 'html' }, data: { foo: 'hello' } })
       *
       * @request {Object}
       * @return {Promise} response.content is output buffer, response.stream is output stream, response.headers contains http applicable headers
       *
       * @public
       */
      async render(req, options = {}) {
        if (!this._initialized) {
          throw new Error("Not initialized, you need to call jsreport.init().then before rendering");
        }
        req = Object.assign({}, req);
        req.context = Object.assign({}, req.context);
        req.context.rootId = req.context.rootId || this.generateRequestId();
        req.context.id = req.context.rootId;
        req.context.reportCounter = ++reportCounter;
        req.context.startTimestamp = (/* @__PURE__ */ new Date()).getTime();
        req.options = Object.assign({}, req.options);
        let worker;
        let workerAborted;
        let dontCloseProcessing;
        const res = Response(this, req.context.id);
        try {
          await this.beforeRenderWorkerAllocatedListeners.fire(req, res);
          if (req.context.clientNotification) {
            const r = req.context.clientNotification;
            delete req.context.clientNotification;
            return r;
          }
          worker = await this._workersManager.allocate(req, {
            timeout: this.getReportTimeout(req)
          });
          if (options.abortEmitter) {
            options.abortEmitter.once("abort", () => {
              if (workerAborted) {
                return;
              }
              workerAborted = true;
              worker.release(req).catch((e) => this.logger.error("Failed to release worker " + e));
            });
          }
          if (workerAborted) {
            throw this.createError("Request aborted by client");
          }
          if (req.rawContent) {
            const result = await worker.execute({
              actionName: "parse",
              req,
              data: {}
            }, {
              timeout: this.getReportTimeout(req)
            });
            req = result;
          }
          req = Request(req);
          options.onReqReady?.(req);
          if (this.entityTypeValidator.getSchema("TemplateType") != null) {
            const templateValidationResult = this.entityTypeValidator.validate("TemplateType", req.template, { rootPrefix: "template" });
            if (!templateValidationResult.valid) {
              throw this.createError(`template input in request contain values that does not match the defined schema. ${templateValidationResult.fullErrorMessage}`, {
                statusCode: 400
              });
            }
          }
          const reportTimeout = this.getReportTimeout(req);
          await this.beforeRenderListeners.fire(req, res, { worker });
          if (workerAborted) {
            throw this.createError("Request aborted by client");
          }
          if (req.context.clientNotification) {
            process.nextTick(async () => {
              try {
                const responseResult2 = await this.executeWorkerAction("render", {}, {
                  timeout: reportTimeout + this.options.reportTimeoutMargin,
                  worker
                }, req);
                await res.parse(responseResult2);
                await this.afterRenderListeners.fire(req, res);
              } catch (err) {
                await this._handleRenderError(req, res, err).catch((e) => {
                });
              } finally {
                this._cleanProfileInRequest(req);
                if (!workerAborted) {
                  await worker.release(req);
                }
              }
            });
            dontCloseProcessing = true;
            const r = req.context.clientNotification;
            delete req.context.clientNotification;
            return r;
          }
          if (workerAborted) {
            throw this.createError("Request aborted by client");
          }
          const responseResult = await this.executeWorkerAction("render", {}, {
            timeout: reportTimeout + this.options.reportTimeoutMargin,
            worker
          }, req);
          await res.parse(responseResult);
          await this.afterRenderListeners.fire(req, res);
          this._cleanProfileInRequest(req);
          return res;
        } catch (err) {
          await this._handleRenderError(req, res, err);
          this._cleanProfileInRequest(req);
          throw err;
        } finally {
          if (worker && !workerAborted && !dontCloseProcessing) {
            await worker.release(req);
          }
        }
      }
      registerWorkersManagerFactory(workersManagerFactory) {
        this._workersManagerFactory = workersManagerFactory;
      }
      /**
       *
       * @public
       */
      async close() {
        this.closing = true;
        this.logger.info("Closing jsreport instance");
        if (this.monitoring) {
          await this.monitoring.close();
        }
        if (this._reaperTimerRef) {
          clearInterval(this._reaperTimerRef);
        }
        await this.closeListeners.fire();
        if (this._workersManager) {
          await this._workersManager.close();
        }
        if (this.documentStore) {
          await this.documentStore.close();
        }
        this.logger.info("jsreport instance has been closed");
        this.closed = true;
        return this;
      }
      registerMainAction(actionName, fn) {
        this._mainActions.set(actionName, fn);
      }
      async _invokeMainAction(data, req) {
        await this.beforeMainActionListeners.fire(data.actionName, data.data, req);
        if (!this._mainActions.has(data.actionName)) {
          throw this.createError(`Main process action ${data.actionName} wasn't registered`);
        }
        return this._mainActions.get(data.actionName)(data.data, req);
      }
      _registerLogMainAction() {
        this.registerMainAction("log", (log, req) => {
          this.logger[log.level](log.message, { ...req, ...log.meta, timestamp: log.timestamp });
        });
      }
      async executeWorkerAction(actionName, data, options = {}, req) {
        req.context.rootId = req.context.rootId || this.generateRequestId();
        const timeout = options.timeout || 6e4;
        const worker = options.worker ? options.worker : await this._workersManager.allocate(req, {
          timeout
        });
        const handleAbortSignal = () => {
          if (worker) {
            worker.release(req).catch((e) => this.logger.error("Failed to release worker " + e));
          }
        };
        if (options.signal && !options.worker) {
          options.signal.addEventListener("abort", handleAbortSignal, { once: true });
        }
        try {
          const result = await worker.execute({
            actionName,
            data,
            // we set just known props, to avoid cloning failures on express req properties
            req: {
              context: req.context,
              template: req.template,
              data: req.data,
              options: req.options
            }
          }, {
            timeout,
            timeoutErrorMessage: options.timeoutErrorMessage || "Timeout during worker action " + actionName,
            executeMain: async (data2) => {
              return this._invokeMainAction(data2, req);
            }
          });
          this._workersManager.convertUint8ArrayToBuffer(result);
          return result;
        } finally {
          if (!options.worker) {
            let shouldRelease = true;
            if (options.signal) {
              options.signal.removeEventListener("abort", handleAbortSignal);
              shouldRelease = options.signal.aborted !== true;
            }
            if (shouldRelease) {
              await worker.release(req);
            }
          }
        }
      }
      /**
       * Periodical cleaning of folders where recipes are storing files like source html for pdf rendering
       *
       * @private
       */
      _startReaper(dir) {
        const dirsToWatch = !Array.isArray(dir) ? [dir] : dir;
        if (this.options.autoTempCleanup === false) {
          return;
        }
        const threshold = this.options.reportTimeout > 18e4 ? this.options.reportTimeout : 18e4;
        this.logger.info(`Starting temp files cleanup with ${threshold}ms threshold`);
        const reaper = new Reaper({ threshold });
        dirsToWatch.forEach((d) => reaper.watch(d));
        reaper.start((err, files) => {
          if (err) {
            this.logger.error(`Failed to start auto cleanup: ${err.stack}`);
          }
        });
        this._reaperTimerRef = setInterval(
          () => {
            try {
              reaper.start((err, files) => {
                if (err) {
                }
              });
            } catch (e) {
            }
          },
          3e4
          /* check every 30s for old files */
        );
        this._reaperTimerRef.unref();
      }
    };
    module2.exports = MainReporter;
  }
});

// node_modules/should-type/cjs/should-type.js
var require_should_type = __commonJS({
  "node_modules/should-type/cjs/should-type.js"(exports2, module2) {
    "use strict";
    var types = {
      NUMBER: "number",
      UNDEFINED: "undefined",
      STRING: "string",
      BOOLEAN: "boolean",
      OBJECT: "object",
      FUNCTION: "function",
      NULL: "null",
      ARRAY: "array",
      REGEXP: "regexp",
      DATE: "date",
      ERROR: "error",
      ARGUMENTS: "arguments",
      SYMBOL: "symbol",
      ARRAY_BUFFER: "array-buffer",
      TYPED_ARRAY: "typed-array",
      DATA_VIEW: "data-view",
      MAP: "map",
      SET: "set",
      WEAK_SET: "weak-set",
      WEAK_MAP: "weak-map",
      PROMISE: "promise",
      // node buffer
      BUFFER: "buffer",
      // dom html element
      HTML_ELEMENT: "html-element",
      HTML_ELEMENT_TEXT: "html-element-text",
      DOCUMENT: "document",
      WINDOW: "window",
      FILE: "file",
      FILE_LIST: "file-list",
      BLOB: "blob",
      HOST: "host",
      XHR: "xhr",
      // simd
      SIMD: "simd"
    };
    function Type(type, cls, sub) {
      if (!type) {
        throw new Error("Type class must be initialized at least with `type` information");
      }
      this.type = type;
      this.cls = cls;
      this.sub = sub;
    }
    Type.prototype = {
      toString: function(sep) {
        sep = sep || ";";
        var str = [this.type];
        if (this.cls) {
          str.push(this.cls);
        }
        if (this.sub) {
          str.push(this.sub);
        }
        return str.join(sep);
      },
      toTryTypes: function() {
        var _types = [];
        if (this.sub) {
          _types.push(new Type(this.type, this.cls, this.sub));
        }
        if (this.cls) {
          _types.push(new Type(this.type, this.cls));
        }
        _types.push(new Type(this.type));
        return _types;
      }
    };
    var toString = Object.prototype.toString;
    function TypeChecker() {
      this.checks = [];
    }
    TypeChecker.prototype = {
      add: function(func) {
        this.checks.push(func);
        return this;
      },
      addBeforeFirstMatch: function(obj, func) {
        var match = this.getFirstMatch(obj);
        if (match) {
          this.checks.splice(match.index, 0, func);
        } else {
          this.add(func);
        }
      },
      addTypeOf: function(type, res) {
        return this.add(function(obj, tpeOf) {
          if (tpeOf === type) {
            return new Type(res);
          }
        });
      },
      addClass: function(cls, res, sub) {
        return this.add(function(obj, tpeOf, objCls) {
          if (objCls === cls) {
            return new Type(types.OBJECT, res, sub);
          }
        });
      },
      getFirstMatch: function(obj) {
        var typeOf = typeof obj;
        var cls = toString.call(obj);
        for (var i = 0, l = this.checks.length; i < l; i++) {
          var res = this.checks[i].call(this, obj, typeOf, cls);
          if (typeof res !== "undefined") {
            return { result: res, func: this.checks[i], index: i };
          }
        }
      },
      getType: function(obj) {
        var match = this.getFirstMatch(obj);
        return match && match.result;
      }
    };
    var main = new TypeChecker();
    main.addTypeOf(types.NUMBER, types.NUMBER).addTypeOf(types.UNDEFINED, types.UNDEFINED).addTypeOf(types.STRING, types.STRING).addTypeOf(types.BOOLEAN, types.BOOLEAN).addTypeOf(types.FUNCTION, types.FUNCTION).addTypeOf(types.SYMBOL, types.SYMBOL).add(function(obj) {
      if (obj === null) {
        return new Type(types.NULL);
      }
    }).addClass("[object String]", types.STRING).addClass("[object Boolean]", types.BOOLEAN).addClass("[object Number]", types.NUMBER).addClass("[object Array]", types.ARRAY).addClass("[object RegExp]", types.REGEXP).addClass("[object Error]", types.ERROR).addClass("[object Date]", types.DATE).addClass("[object Arguments]", types.ARGUMENTS).addClass("[object ArrayBuffer]", types.ARRAY_BUFFER).addClass("[object Int8Array]", types.TYPED_ARRAY, "int8").addClass("[object Uint8Array]", types.TYPED_ARRAY, "uint8").addClass("[object Uint8ClampedArray]", types.TYPED_ARRAY, "uint8clamped").addClass("[object Int16Array]", types.TYPED_ARRAY, "int16").addClass("[object Uint16Array]", types.TYPED_ARRAY, "uint16").addClass("[object Int32Array]", types.TYPED_ARRAY, "int32").addClass("[object Uint32Array]", types.TYPED_ARRAY, "uint32").addClass("[object Float32Array]", types.TYPED_ARRAY, "float32").addClass("[object Float64Array]", types.TYPED_ARRAY, "float64").addClass("[object Bool16x8]", types.SIMD, "bool16x8").addClass("[object Bool32x4]", types.SIMD, "bool32x4").addClass("[object Bool8x16]", types.SIMD, "bool8x16").addClass("[object Float32x4]", types.SIMD, "float32x4").addClass("[object Int16x8]", types.SIMD, "int16x8").addClass("[object Int32x4]", types.SIMD, "int32x4").addClass("[object Int8x16]", types.SIMD, "int8x16").addClass("[object Uint16x8]", types.SIMD, "uint16x8").addClass("[object Uint32x4]", types.SIMD, "uint32x4").addClass("[object Uint8x16]", types.SIMD, "uint8x16").addClass("[object DataView]", types.DATA_VIEW).addClass("[object Map]", types.MAP).addClass("[object WeakMap]", types.WEAK_MAP).addClass("[object Set]", types.SET).addClass("[object WeakSet]", types.WEAK_SET).addClass("[object Promise]", types.PROMISE).addClass("[object Blob]", types.BLOB).addClass("[object File]", types.FILE).addClass("[object FileList]", types.FILE_LIST).addClass("[object XMLHttpRequest]", types.XHR).add(function(obj) {
      if (typeof Promise === types.FUNCTION && obj instanceof Promise || typeof obj.then === types.FUNCTION) {
        return new Type(types.OBJECT, types.PROMISE);
      }
    }).add(function(obj) {
      if (typeof Buffer !== "undefined" && obj instanceof Buffer) {
        return new Type(types.OBJECT, types.BUFFER);
      }
    }).add(function(obj) {
      if (typeof Node !== "undefined" && obj instanceof Node) {
        return new Type(types.OBJECT, types.HTML_ELEMENT, obj.nodeName);
      }
    }).add(function(obj) {
      if (obj.Boolean === Boolean && obj.Number === Number && obj.String === String && obj.Date === Date) {
        return new Type(types.OBJECT, types.HOST);
      }
    }).add(function() {
      return new Type(types.OBJECT);
    });
    function getGlobalType(obj) {
      return main.getType(obj);
    }
    getGlobalType.checker = main;
    getGlobalType.TypeChecker = TypeChecker;
    getGlobalType.Type = Type;
    Object.keys(types).forEach(function(typeName) {
      getGlobalType[typeName] = types[typeName];
    });
    module2.exports = getGlobalType;
  }
});

// node_modules/should-equal/cjs/should-equal.js
var require_should_equal = __commonJS({
  "node_modules/should-equal/cjs/should-equal.js"(exports2, module2) {
    "use strict";
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var t = _interopDefault(require_should_type());
    function format(msg) {
      var args = arguments;
      for (var i = 1, l = args.length; i < l; i++) {
        msg = msg.replace(/%s/, args[i]);
      }
      return msg;
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function EqualityFail(a, b, reason, path) {
      this.a = a;
      this.b = b;
      this.reason = reason;
      this.path = path;
    }
    function typeToString(tp) {
      return tp.type + (tp.cls ? "(" + tp.cls + (tp.sub ? " " + tp.sub : "") + ")" : "");
    }
    var PLUS_0_AND_MINUS_0 = "+0 is not equal to -0";
    var DIFFERENT_TYPES = "A has type %s and B has type %s";
    var EQUALITY = "A is not equal to B";
    var EQUALITY_PROTOTYPE = "A and B have different prototypes";
    var WRAPPED_VALUE = "A wrapped value is not equal to B wrapped value";
    var FUNCTION_SOURCES = "function A is not equal to B by source code value (via .toString call)";
    var MISSING_KEY = "%s has no key %s";
    var SET_MAP_MISSING_KEY = "Set/Map missing key %s";
    var DEFAULT_OPTIONS = {
      checkProtoEql: true,
      checkSubType: true,
      plusZeroAndMinusZeroEqual: true,
      collectAllFails: false
    };
    function setBooleanDefault(property, obj, opts, defaults) {
      obj[property] = typeof opts[property] !== "boolean" ? defaults[property] : opts[property];
    }
    var METHOD_PREFIX = "_check_";
    function EQ(opts, a, b, path) {
      opts = opts || {};
      setBooleanDefault("checkProtoEql", this, opts, DEFAULT_OPTIONS);
      setBooleanDefault("plusZeroAndMinusZeroEqual", this, opts, DEFAULT_OPTIONS);
      setBooleanDefault("checkSubType", this, opts, DEFAULT_OPTIONS);
      setBooleanDefault("collectAllFails", this, opts, DEFAULT_OPTIONS);
      this.a = a;
      this.b = b;
      this._meet = opts._meet || [];
      this.fails = opts.fails || [];
      this.path = path || [];
    }
    function ShortcutError(fail) {
      this.name = "ShortcutError";
      this.message = "fail fast";
      this.fail = fail;
    }
    ShortcutError.prototype = Object.create(Error.prototype);
    EQ.checkStrictEquality = function(a, b) {
      this.collectFail(a !== b, EQUALITY);
    };
    EQ.add = function add(type, cls, sub, f) {
      var args = Array.prototype.slice.call(arguments);
      f = args.pop();
      EQ.prototype[METHOD_PREFIX + args.join("_")] = f;
    };
    EQ.prototype = {
      check: function() {
        try {
          this.check0();
        } catch (e) {
          if (e instanceof ShortcutError) {
            return [e.fail];
          }
          throw e;
        }
        return this.fails;
      },
      check0: function() {
        var a = this.a;
        var b = this.b;
        if (a === b) {
          return this.collectFail(a === 0 && 1 / a !== 1 / b && !this.plusZeroAndMinusZeroEqual, PLUS_0_AND_MINUS_0);
        }
        var typeA = t(a);
        var typeB = t(b);
        if (typeA.type !== typeB.type || typeA.cls !== typeB.cls || typeA.sub !== typeB.sub) {
          return this.collectFail(true, format(DIFFERENT_TYPES, typeToString(typeA), typeToString(typeB)));
        }
        var name1 = typeA.type, name2 = typeA.type;
        if (typeA.cls) {
          name1 += "_" + typeA.cls;
          name2 += "_" + typeA.cls;
        }
        if (typeA.sub) {
          name2 += "_" + typeA.sub;
        }
        var f = this[METHOD_PREFIX + name2] || this[METHOD_PREFIX + name1] || this[METHOD_PREFIX + typeA.type] || this.defaultCheck;
        f.call(this, this.a, this.b);
      },
      collectFail: function(comparison, reason, showReason) {
        if (comparison) {
          var res = new EqualityFail(this.a, this.b, reason, this.path);
          res.showReason = !!showReason;
          this.fails.push(res);
          if (!this.collectAllFails) {
            throw new ShortcutError(res);
          }
        }
      },
      checkPlainObjectsEquality: function(a, b) {
        var meet = this._meet;
        var m = this._meet.length;
        while (m--) {
          var st = meet[m];
          if (st[0] === a && st[1] === b) {
            return;
          }
        }
        meet.push([a, b]);
        var key;
        for (key in b) {
          if (hasOwnProperty.call(b, key)) {
            if (hasOwnProperty.call(a, key)) {
              this.checkPropertyEquality(key);
            } else {
              this.collectFail(true, format(MISSING_KEY, "A", key));
            }
          }
        }
        for (key in a) {
          if (hasOwnProperty.call(a, key)) {
            this.collectFail(!hasOwnProperty.call(b, key), format(MISSING_KEY, "B", key));
          }
        }
        meet.pop();
        if (this.checkProtoEql) {
          this.collectFail(Object.getPrototypeOf(a) !== Object.getPrototypeOf(b), EQUALITY_PROTOTYPE, true);
        }
      },
      checkPropertyEquality: function(propertyName) {
        var _eq = new EQ(this, this.a[propertyName], this.b[propertyName], this.path.concat([propertyName]));
        _eq.check0();
      },
      defaultCheck: EQ.checkStrictEquality
    };
    EQ.add(t.NUMBER, function(a, b) {
      this.collectFail(a !== a && b === b || b !== b && a === a || a !== b && a === a && b === b, EQUALITY);
    });
    [t.SYMBOL, t.BOOLEAN, t.STRING].forEach(function(tp) {
      EQ.add(tp, EQ.checkStrictEquality);
    });
    EQ.add(t.FUNCTION, function(a, b) {
      this.collectFail(a.toString() !== b.toString(), FUNCTION_SOURCES);
      this.checkPlainObjectsEquality(a, b);
    });
    EQ.add(t.OBJECT, t.REGEXP, function(a, b) {
      var flags = ["source", "global", "multiline", "lastIndex", "ignoreCase", "sticky", "unicode"];
      while (flags.length) {
        this.checkPropertyEquality(flags.shift());
      }
      this.checkPlainObjectsEquality(a, b);
    });
    EQ.add(t.OBJECT, t.DATE, function(a, b) {
      this.collectFail(+a !== +b, EQUALITY);
      this.checkPlainObjectsEquality(a, b);
    });
    [t.NUMBER, t.BOOLEAN, t.STRING].forEach(function(tp) {
      EQ.add(t.OBJECT, tp, function(a, b) {
        this.collectFail(a.valueOf() !== b.valueOf(), WRAPPED_VALUE);
        this.checkPlainObjectsEquality(a, b);
      });
    });
    EQ.add(t.OBJECT, function(a, b) {
      this.checkPlainObjectsEquality(a, b);
    });
    [t.ARRAY, t.ARGUMENTS, t.TYPED_ARRAY].forEach(function(tp) {
      EQ.add(t.OBJECT, tp, function(a, b) {
        this.checkPropertyEquality("length");
        this.checkPlainObjectsEquality(a, b);
      });
    });
    EQ.add(t.OBJECT, t.ARRAY_BUFFER, function(a, b) {
      this.checkPropertyEquality("byteLength");
      this.checkPlainObjectsEquality(a, b);
    });
    EQ.add(t.OBJECT, t.ERROR, function(a, b) {
      this.checkPropertyEquality("name");
      this.checkPropertyEquality("message");
      this.checkPlainObjectsEquality(a, b);
    });
    EQ.add(t.OBJECT, t.BUFFER, function(a) {
      this.checkPropertyEquality("length");
      var l = a.length;
      while (l--) {
        this.checkPropertyEquality(l);
      }
    });
    function checkMapByKeys(a, b) {
      var iteratorA = a.keys();
      for (var nextA = iteratorA.next(); !nextA.done; nextA = iteratorA.next()) {
        var key = nextA.value;
        var hasKey = b.has(key);
        this.collectFail(!hasKey, format(SET_MAP_MISSING_KEY, key));
        if (hasKey) {
          var valueB = b.get(key);
          var valueA = a.get(key);
          eq(valueA, valueB, this);
        }
      }
    }
    function checkSetByKeys(a, b) {
      var iteratorA = a.keys();
      for (var nextA = iteratorA.next(); !nextA.done; nextA = iteratorA.next()) {
        var key = nextA.value;
        var hasKey = b.has(key);
        this.collectFail(!hasKey, format(SET_MAP_MISSING_KEY, key));
      }
    }
    EQ.add(t.OBJECT, t.MAP, function(a, b) {
      this._meet.push([a, b]);
      checkMapByKeys.call(this, a, b);
      checkMapByKeys.call(this, b, a);
      this._meet.pop();
      this.checkPlainObjectsEquality(a, b);
    });
    EQ.add(t.OBJECT, t.SET, function(a, b) {
      this._meet.push([a, b]);
      checkSetByKeys.call(this, a, b);
      checkSetByKeys.call(this, b, a);
      this._meet.pop();
      this.checkPlainObjectsEquality(a, b);
    });
    function eq(a, b, opts) {
      return new EQ(opts, a, b).check();
    }
    eq.EQ = EQ;
    module2.exports = eq;
  }
});

// node_modules/should-util/cjs/should-util.js
var require_should_util = __commonJS({
  "node_modules/should-util/cjs/should-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
    function hasOwnProperty(obj, key) {
      return _hasOwnProperty.call(obj, key);
    }
    function propertyIsEnumerable(obj, key) {
      return _propertyIsEnumerable.call(obj, key);
    }
    function merge(a, b) {
      if (a && b) {
        for (var key in b) {
          a[key] = b[key];
        }
      }
      return a;
    }
    function isIterator(obj) {
      if (!obj) {
        return false;
      }
      if (obj.__shouldIterator__) {
        return true;
      }
      return typeof obj.next === "function" && typeof Symbol === "function" && typeof Symbol.iterator === "symbol" && typeof obj[Symbol.iterator] === "function" && obj[Symbol.iterator]() === obj;
    }
    function isGeneratorFunction(f) {
      return typeof f === "function" && /^function\s*\*\s*/.test(f.toString());
    }
    exports2.hasOwnProperty = hasOwnProperty;
    exports2.propertyIsEnumerable = propertyIsEnumerable;
    exports2.merge = merge;
    exports2.isIterator = isIterator;
    exports2.isGeneratorFunction = isGeneratorFunction;
  }
});

// node_modules/should-type-adaptors/cjs/should-type-adaptors.js
var require_should_type_adaptors = __commonJS({
  "node_modules/should-type-adaptors/cjs/should-type-adaptors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var shouldUtil = require_should_util();
    var t = _interopDefault(require_should_type());
    function ObjectIterator(obj) {
      this._obj = obj;
    }
    ObjectIterator.prototype = {
      __shouldIterator__: true,
      // special marker
      next: function() {
        if (this._done) {
          throw new Error("Iterator already reached the end");
        }
        if (!this._keys) {
          this._keys = Object.keys(this._obj);
          this._index = 0;
        }
        var key = this._keys[this._index];
        this._done = this._index === this._keys.length;
        this._index += 1;
        return {
          value: this._done ? void 0 : [key, this._obj[key]],
          done: this._done
        };
      }
    };
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      ObjectIterator.prototype[Symbol.iterator] = function() {
        return this;
      };
    }
    function TypeAdaptorStorage() {
      this._typeAdaptors = [];
      this._iterableTypes = {};
    }
    TypeAdaptorStorage.prototype = {
      add: function(type, cls, sub, adaptor) {
        return this.addType(new t.Type(type, cls, sub), adaptor);
      },
      addType: function(type, adaptor) {
        this._typeAdaptors[type.toString()] = adaptor;
      },
      getAdaptor: function(tp, funcName) {
        var tries = tp.toTryTypes();
        while (tries.length) {
          var toTry = tries.shift();
          var ad = this._typeAdaptors[toTry];
          if (ad && ad[funcName]) {
            return ad[funcName];
          }
        }
      },
      requireAdaptor: function(tp, funcName) {
        var a = this.getAdaptor(tp, funcName);
        if (!a) {
          throw new Error("There is no type adaptor `" + funcName + "` for " + tp.toString());
        }
        return a;
      },
      addIterableType: function(tp) {
        this._iterableTypes[tp.toString()] = true;
      },
      isIterableType: function(tp) {
        return !!this._iterableTypes[tp.toString()];
      }
    };
    var defaultTypeAdaptorStorage = new TypeAdaptorStorage();
    var objectAdaptor = {
      forEach: function(obj, f, context) {
        for (var prop in obj) {
          if (shouldUtil.hasOwnProperty(obj, prop) && shouldUtil.propertyIsEnumerable(obj, prop)) {
            if (f.call(context, obj[prop], prop, obj) === false) {
              return;
            }
          }
        }
      },
      has: function(obj, prop) {
        return shouldUtil.hasOwnProperty(obj, prop);
      },
      get: function(obj, prop) {
        return obj[prop];
      },
      iterator: function(obj) {
        return new ObjectIterator(obj);
      }
    };
    defaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT), objectAdaptor);
    defaultTypeAdaptorStorage.addType(new t.Type(t.FUNCTION), objectAdaptor);
    var mapAdaptor = {
      has: function(obj, key) {
        return obj.has(key);
      },
      get: function(obj, key) {
        return obj.get(key);
      },
      forEach: function(obj, f, context) {
        var iter = obj.entries();
        forEach(iter, function(value) {
          return f.call(context, value[1], value[0], obj);
        });
      },
      size: function(obj) {
        return obj.size;
      },
      isEmpty: function(obj) {
        return obj.size === 0;
      },
      iterator: function(obj) {
        return obj.entries();
      }
    };
    var setAdaptor = shouldUtil.merge({}, mapAdaptor);
    setAdaptor.get = function(obj, key) {
      if (obj.has(key)) {
        return key;
      }
    };
    setAdaptor.iterator = function(obj) {
      return obj.values();
    };
    defaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.MAP), mapAdaptor);
    defaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.SET), setAdaptor);
    defaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.WEAK_SET), setAdaptor);
    defaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.WEAK_MAP), mapAdaptor);
    defaultTypeAdaptorStorage.addType(new t.Type(t.STRING), {
      isEmpty: function(obj) {
        return obj === "";
      },
      size: function(obj) {
        return obj.length;
      }
    });
    defaultTypeAdaptorStorage.addIterableType(new t.Type(t.OBJECT, t.ARRAY));
    defaultTypeAdaptorStorage.addIterableType(new t.Type(t.OBJECT, t.ARGUMENTS));
    defaultTypeAdaptorStorage.addIterableType(new t.Type(t.OBJECT, t.SET));
    function forEach(obj, f, context) {
      if (shouldUtil.isGeneratorFunction(obj)) {
        return forEach(obj(), f, context);
      } else if (shouldUtil.isIterator(obj)) {
        var value = obj.next();
        while (!value.done) {
          if (f.call(context, value.value, "value", obj) === false) {
            return;
          }
          value = obj.next();
        }
      } else {
        var type = t(obj);
        var func = defaultTypeAdaptorStorage.requireAdaptor(type, "forEach");
        func(obj, f, context);
      }
    }
    function size(obj) {
      var type = t(obj);
      var func = defaultTypeAdaptorStorage.getAdaptor(type, "size");
      if (func) {
        return func(obj);
      } else {
        var len = 0;
        forEach(obj, function() {
          len += 1;
        });
        return len;
      }
    }
    function isEmpty(obj) {
      var type = t(obj);
      var func = defaultTypeAdaptorStorage.getAdaptor(type, "isEmpty");
      if (func) {
        return func(obj);
      } else {
        var res = true;
        forEach(obj, function() {
          res = false;
          return false;
        });
        return res;
      }
    }
    function has(obj, key) {
      var type = t(obj);
      var func = defaultTypeAdaptorStorage.requireAdaptor(type, "has");
      return func(obj, key);
    }
    function get(obj, key) {
      var type = t(obj);
      var func = defaultTypeAdaptorStorage.requireAdaptor(type, "get");
      return func(obj, key);
    }
    function reduce(obj, f, initialValue) {
      var res = initialValue;
      forEach(obj, function(value, key) {
        res = f(res, value, key, obj);
      });
      return res;
    }
    function some(obj, f, context) {
      var res = false;
      forEach(obj, function(value, key) {
        if (f.call(context, value, key, obj)) {
          res = true;
          return false;
        }
      }, context);
      return res;
    }
    function every(obj, f, context) {
      var res = true;
      forEach(obj, function(value, key) {
        if (!f.call(context, value, key, obj)) {
          res = false;
          return false;
        }
      }, context);
      return res;
    }
    function isIterable(obj) {
      return defaultTypeAdaptorStorage.isIterableType(t(obj));
    }
    function iterator(obj) {
      return defaultTypeAdaptorStorage.requireAdaptor(t(obj), "iterator")(obj);
    }
    exports2.defaultTypeAdaptorStorage = defaultTypeAdaptorStorage;
    exports2.forEach = forEach;
    exports2.size = size;
    exports2.isEmpty = isEmpty;
    exports2.has = has;
    exports2.get = get;
    exports2.reduce = reduce;
    exports2.some = some;
    exports2.every = every;
    exports2.isIterable = isIterable;
    exports2.iterator = iterator;
  }
});

// node_modules/should-format/cjs/should-format.js
var require_should_format = __commonJS({
  "node_modules/should-format/cjs/should-format.js"(exports2, module2) {
    "use strict";
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var t = _interopDefault(require_should_type());
    var shouldTypeAdaptors = require_should_type_adaptors();
    function looksLikeANumber(n) {
      return !!n.match(/\d+/);
    }
    function keyCompare(a, b) {
      var aNum = looksLikeANumber(a);
      var bNum = looksLikeANumber(b);
      if (aNum && bNum) {
        return 1 * a - 1 * b;
      } else if (aNum && !bNum) {
        return -1;
      } else if (!aNum && bNum) {
        return 1;
      } else {
        return a.localeCompare(b);
      }
    }
    function genKeysFunc(f) {
      return function(value) {
        var k = f(value);
        k.sort(keyCompare);
        return k;
      };
    }
    function Formatter(opts) {
      opts = opts || {};
      this.seen = [];
      var keysFunc;
      if (typeof opts.keysFunc === "function") {
        keysFunc = opts.keysFunc;
      } else if (opts.keys === false) {
        keysFunc = Object.getOwnPropertyNames;
      } else {
        keysFunc = Object.keys;
      }
      this.getKeys = genKeysFunc(keysFunc);
      this.maxLineLength = typeof opts.maxLineLength === "number" ? opts.maxLineLength : 60;
      this.propSep = opts.propSep || ",";
      this.isUTCdate = !!opts.isUTCdate;
    }
    Formatter.prototype = {
      constructor: Formatter,
      format: function(value) {
        var tp = t(value);
        if (this.alreadySeen(value)) {
          return "[Circular]";
        }
        var tries = tp.toTryTypes();
        var f = this.defaultFormat;
        while (tries.length) {
          var toTry = tries.shift();
          var name = Formatter.formatterFunctionName(toTry);
          if (this[name]) {
            f = this[name];
            break;
          }
        }
        return f.call(this, value).trim();
      },
      defaultFormat: function(obj) {
        return String(obj);
      },
      alreadySeen: function(value) {
        return this.seen.indexOf(value) >= 0;
      }
    };
    Formatter.addType = function addType(tp, f) {
      Formatter.prototype[Formatter.formatterFunctionName(tp)] = f;
    };
    Formatter.formatterFunctionName = function formatterFunctionName(tp) {
      return "_format_" + tp.toString("_");
    };
    var EOL = "\n";
    function indent(v, indentation) {
      return v.split(EOL).map(function(vv) {
        return indentation + vv;
      }).join(EOL);
    }
    function pad(str, value, filler) {
      str = String(str);
      var isRight = false;
      if (value < 0) {
        isRight = true;
        value = -value;
      }
      if (str.length < value) {
        var padding = new Array(value - str.length + 1).join(filler);
        return isRight ? str + padding : padding + str;
      } else {
        return str;
      }
    }
    function pad0(str, value) {
      return pad(str, value, "0");
    }
    var functionNameRE = /^\s*function\s*(\S*)\s*\(/;
    function functionName(f) {
      if (f.name) {
        return f.name;
      }
      var matches = f.toString().match(functionNameRE);
      if (matches === null) {
        return "";
      }
      var name = matches[1];
      return name;
    }
    function constructorName(obj) {
      while (obj) {
        var descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
        if (descriptor !== void 0 && typeof descriptor.value === "function") {
          var name = functionName(descriptor.value);
          if (name !== "") {
            return name;
          }
        }
        obj = Object.getPrototypeOf(obj);
      }
    }
    var INDENT = "  ";
    function addSpaces(str) {
      return indent(str, INDENT);
    }
    function typeAdaptorForEachFormat(obj, opts) {
      opts = opts || {};
      var filterKey = opts.filterKey || function() {
        return true;
      };
      var formatKey = opts.formatKey || this.format;
      var formatValue = opts.formatValue || this.format;
      var keyValueSep = typeof opts.keyValueSep !== "undefined" ? opts.keyValueSep : ": ";
      this.seen.push(obj);
      var formatLength = 0;
      var pairs = [];
      shouldTypeAdaptors.forEach(obj, function(value, key) {
        if (!filterKey(key)) {
          return;
        }
        var formattedKey = formatKey.call(this, key);
        var formattedValue = formatValue.call(this, value, key);
        var pair = formattedKey ? formattedKey + keyValueSep + formattedValue : formattedValue;
        formatLength += pair.length;
        pairs.push(pair);
      }, this);
      this.seen.pop();
      (opts.additionalKeys || []).forEach(function(keyValue) {
        var pair = keyValue[0] + keyValueSep + this.format(keyValue[1]);
        formatLength += pair.length;
        pairs.push(pair);
      }, this);
      var prefix = opts.prefix || constructorName(obj) || "";
      if (prefix.length > 0) {
        prefix += " ";
      }
      var lbracket, rbracket;
      if (Array.isArray(opts.brackets)) {
        lbracket = opts.brackets[0];
        rbracket = opts.brackets[1];
      } else {
        lbracket = "{";
        rbracket = "}";
      }
      var rootValue = opts.value || "";
      if (pairs.length === 0) {
        return rootValue || prefix + lbracket + rbracket;
      }
      if (formatLength <= this.maxLineLength) {
        return prefix + lbracket + " " + (rootValue ? rootValue + " " : "") + pairs.join(this.propSep + " ") + " " + rbracket;
      } else {
        return prefix + lbracket + "\n" + (rootValue ? "  " + rootValue + "\n" : "") + pairs.map(addSpaces).join(this.propSep + "\n") + "\n" + rbracket;
      }
    }
    function formatPlainObjectKey(key) {
      return typeof key === "string" && key.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*$/) ? key : this.format(key);
    }
    function getPropertyDescriptor(obj, key) {
      var desc;
      try {
        desc = Object.getOwnPropertyDescriptor(obj, key) || { value: obj[key] };
      } catch (e) {
        desc = { value: e };
      }
      return desc;
    }
    function formatPlainObjectValue(obj, key) {
      var desc = getPropertyDescriptor(obj, key);
      if (desc.get && desc.set) {
        return "[Getter/Setter]";
      }
      if (desc.get) {
        return "[Getter]";
      }
      if (desc.set) {
        return "[Setter]";
      }
      return this.format(desc.value);
    }
    function formatPlainObject(obj, opts) {
      opts = opts || {};
      opts.keyValueSep = ": ";
      opts.formatKey = opts.formatKey || formatPlainObjectKey;
      opts.formatValue = opts.formatValue || function(value, key) {
        return formatPlainObjectValue.call(this, obj, key);
      };
      return typeAdaptorForEachFormat.call(this, obj, opts);
    }
    function formatWrapper1(value) {
      return formatPlainObject.call(this, value, {
        additionalKeys: [["[[PrimitiveValue]]", value.valueOf()]]
      });
    }
    function formatWrapper2(value) {
      var realValue = value.valueOf();
      return formatPlainObject.call(this, value, {
        filterKey: function(key) {
          return !(key.match(/\d+/) && parseInt(key, 10) < realValue.length);
        },
        additionalKeys: [["[[PrimitiveValue]]", realValue]]
      });
    }
    function formatRegExp(value) {
      return formatPlainObject.call(this, value, {
        value: String(value)
      });
    }
    function formatFunction(value) {
      return formatPlainObject.call(this, value, {
        prefix: "Function",
        additionalKeys: [["name", functionName(value)]]
      });
    }
    function formatArray(value) {
      return formatPlainObject.call(this, value, {
        formatKey: function(key) {
          if (!key.match(/\d+/)) {
            return formatPlainObjectKey.call(this, key);
          }
        },
        brackets: ["[", "]"]
      });
    }
    function formatArguments(value) {
      return formatPlainObject.call(this, value, {
        formatKey: function(key) {
          if (!key.match(/\d+/)) {
            return formatPlainObjectKey.call(this, key);
          }
        },
        brackets: ["[", "]"],
        prefix: "Arguments"
      });
    }
    function _formatDate(value, isUTC) {
      var prefix = isUTC ? "UTC" : "";
      var date = value["get" + prefix + "FullYear"]() + "-" + pad0(value["get" + prefix + "Month"]() + 1, 2) + "-" + pad0(value["get" + prefix + "Date"](), 2);
      var time = pad0(value["get" + prefix + "Hours"](), 2) + ":" + pad0(value["get" + prefix + "Minutes"](), 2) + ":" + pad0(value["get" + prefix + "Seconds"](), 2) + "." + pad0(value["get" + prefix + "Milliseconds"](), 3);
      var to = value.getTimezoneOffset();
      var absTo = Math.abs(to);
      var hours = Math.floor(absTo / 60);
      var minutes = absTo - hours * 60;
      var tzFormat = (to < 0 ? "+" : "-") + pad0(hours, 2) + pad0(minutes, 2);
      return date + " " + time + (isUTC ? "" : " " + tzFormat);
    }
    function formatDate(value) {
      return formatPlainObject.call(this, value, { value: _formatDate(value, this.isUTCdate) });
    }
    function formatError(value) {
      return formatPlainObject.call(this, value, {
        prefix: value.name,
        additionalKeys: [["message", value.message]]
      });
    }
    function generateFormatForNumberArray(lengthProp, name, padding) {
      return function(value) {
        var max = this.byteArrayMaxLength || 50;
        var length = value[lengthProp];
        var formattedValues = [];
        var len = 0;
        for (var i = 0; i < max && i < length; i++) {
          var b = value[i] || 0;
          var v = pad0(b.toString(16), padding);
          len += v.length;
          formattedValues.push(v);
        }
        var prefix = value.constructor.name || name || "";
        if (prefix) {
          prefix += " ";
        }
        if (formattedValues.length === 0) {
          return prefix + "[]";
        }
        if (len <= this.maxLineLength) {
          return prefix + "[ " + formattedValues.join(this.propSep + " ") + " ]";
        } else {
          return prefix + "[\n" + formattedValues.map(addSpaces).join(this.propSep + "\n") + "\n]";
        }
      };
    }
    function formatMap(obj) {
      return typeAdaptorForEachFormat.call(this, obj, {
        keyValueSep: " => "
      });
    }
    function formatSet(obj) {
      return typeAdaptorForEachFormat.call(this, obj, {
        keyValueSep: "",
        formatKey: function() {
          return "";
        }
      });
    }
    function genSimdVectorFormat(constructorName2, length) {
      return function(value) {
        var Constructor = value.constructor;
        var extractLane = Constructor.extractLane;
        var len = 0;
        var props = [];
        for (var i = 0; i < length; i++) {
          var key = this.format(extractLane(value, i));
          len += key.length;
          props.push(key);
        }
        if (len <= this.maxLineLength) {
          return constructorName2 + " [ " + props.join(this.propSep + " ") + " ]";
        } else {
          return constructorName2 + " [\n" + props.map(addSpaces).join(this.propSep + "\n") + "\n]";
        }
      };
    }
    function defaultFormat(value, opts) {
      return new Formatter(opts).format(value);
    }
    defaultFormat.Formatter = Formatter;
    defaultFormat.addSpaces = addSpaces;
    defaultFormat.pad0 = pad0;
    defaultFormat.functionName = functionName;
    defaultFormat.constructorName = constructorName;
    defaultFormat.formatPlainObjectKey = formatPlainObjectKey;
    defaultFormat.formatPlainObject = formatPlainObject;
    defaultFormat.typeAdaptorForEachFormat = typeAdaptorForEachFormat;
    Formatter.addType(new t.Type(t.UNDEFINED), function() {
      return "undefined";
    });
    Formatter.addType(new t.Type(t.NULL), function() {
      return "null";
    });
    Formatter.addType(new t.Type(t.BOOLEAN), function(value) {
      return value ? "true" : "false";
    });
    Formatter.addType(new t.Type(t.SYMBOL), function(value) {
      return value.toString();
    });
    Formatter.addType(new t.Type(t.NUMBER), function(value) {
      if (value === 0 && 1 / value < 0) {
        return "-0";
      }
      return String(value);
    });
    Formatter.addType(new t.Type(t.STRING), function(value) {
      return "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    });
    Formatter.addType(new t.Type(t.FUNCTION), formatFunction);
    Formatter.addType(new t.Type(t.OBJECT), formatPlainObject);
    Formatter.addType(new t.Type(t.OBJECT, t.NUMBER), formatWrapper1);
    Formatter.addType(new t.Type(t.OBJECT, t.BOOLEAN), formatWrapper1);
    Formatter.addType(new t.Type(t.OBJECT, t.STRING), formatWrapper2);
    Formatter.addType(new t.Type(t.OBJECT, t.REGEXP), formatRegExp);
    Formatter.addType(new t.Type(t.OBJECT, t.ARRAY), formatArray);
    Formatter.addType(new t.Type(t.OBJECT, t.ARGUMENTS), formatArguments);
    Formatter.addType(new t.Type(t.OBJECT, t.DATE), formatDate);
    Formatter.addType(new t.Type(t.OBJECT, t.ERROR), formatError);
    Formatter.addType(new t.Type(t.OBJECT, t.SET), formatSet);
    Formatter.addType(new t.Type(t.OBJECT, t.MAP), formatMap);
    Formatter.addType(new t.Type(t.OBJECT, t.WEAK_MAP), formatMap);
    Formatter.addType(new t.Type(t.OBJECT, t.WEAK_SET), formatSet);
    Formatter.addType(new t.Type(t.OBJECT, t.BUFFER), generateFormatForNumberArray("length", "Buffer", 2));
    Formatter.addType(new t.Type(t.OBJECT, t.ARRAY_BUFFER), generateFormatForNumberArray("byteLength", "ArrayBuffer", 2));
    Formatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, "int8"), generateFormatForNumberArray("length", "Int8Array", 2));
    Formatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, "uint8"), generateFormatForNumberArray("length", "Uint8Array", 2));
    Formatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, "uint8clamped"), generateFormatForNumberArray("length", "Uint8ClampedArray", 2));
    Formatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, "int16"), generateFormatForNumberArray("length", "Int16Array", 4));
    Formatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, "uint16"), generateFormatForNumberArray("length", "Uint16Array", 4));
    Formatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, "int32"), generateFormatForNumberArray("length", "Int32Array", 8));
    Formatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, "uint32"), generateFormatForNumberArray("length", "Uint32Array", 8));
    Formatter.addType(new t.Type(t.OBJECT, t.SIMD, "bool16x8"), genSimdVectorFormat("Bool16x8", 8));
    Formatter.addType(new t.Type(t.OBJECT, t.SIMD, "bool32x4"), genSimdVectorFormat("Bool32x4", 4));
    Formatter.addType(new t.Type(t.OBJECT, t.SIMD, "bool8x16"), genSimdVectorFormat("Bool8x16", 16));
    Formatter.addType(new t.Type(t.OBJECT, t.SIMD, "float32x4"), genSimdVectorFormat("Float32x4", 4));
    Formatter.addType(new t.Type(t.OBJECT, t.SIMD, "int16x8"), genSimdVectorFormat("Int16x8", 8));
    Formatter.addType(new t.Type(t.OBJECT, t.SIMD, "int32x4"), genSimdVectorFormat("Int32x4", 4));
    Formatter.addType(new t.Type(t.OBJECT, t.SIMD, "int8x16"), genSimdVectorFormat("Int8x16", 16));
    Formatter.addType(new t.Type(t.OBJECT, t.SIMD, "uint16x8"), genSimdVectorFormat("Uint16x8", 8));
    Formatter.addType(new t.Type(t.OBJECT, t.SIMD, "uint32x4"), genSimdVectorFormat("Uint32x4", 4));
    Formatter.addType(new t.Type(t.OBJECT, t.SIMD, "uint8x16"), genSimdVectorFormat("Uint8x16", 16));
    Formatter.addType(new t.Type(t.OBJECT, t.PROMISE), function() {
      return "[Promise]";
    });
    Formatter.addType(new t.Type(t.OBJECT, t.XHR), function() {
      return "[XMLHttpRequest]";
    });
    Formatter.addType(new t.Type(t.OBJECT, t.HTML_ELEMENT), function(value) {
      return value.outerHTML;
    });
    Formatter.addType(new t.Type(t.OBJECT, t.HTML_ELEMENT, "#text"), function(value) {
      return value.nodeValue;
    });
    Formatter.addType(new t.Type(t.OBJECT, t.HTML_ELEMENT, "#document"), function(value) {
      return value.documentElement.outerHTML;
    });
    Formatter.addType(new t.Type(t.OBJECT, t.HOST), function() {
      return "[Host]";
    });
    module2.exports = defaultFormat;
  }
});

// node_modules/should/cjs/should.js
var require_should = __commonJS({
  "node_modules/should/cjs/should.js"(exports2, module2) {
    "use strict";
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var getType = _interopDefault(require_should_type());
    var eql = _interopDefault(require_should_equal());
    var sformat = _interopDefault(require_should_format());
    var shouldTypeAdaptors = require_should_type_adaptors();
    var shouldUtil = require_should_util();
    function isWrapperType(obj) {
      return obj instanceof Number || obj instanceof String || obj instanceof Boolean;
    }
    function convertPropertyName(name) {
      return typeof name === "symbol" ? name : String(name);
    }
    var functionName = sformat.functionName;
    function isPlainObject(obj) {
      if (typeof obj == "object" && obj !== null) {
        var proto = Object.getPrototypeOf(obj);
        return proto === Object.prototype || proto === null;
      }
      return false;
    }
    var config = {
      typeAdaptors: shouldTypeAdaptors.defaultTypeAdaptorStorage,
      getFormatter: function(opts) {
        return new sformat.Formatter(opts || config);
      }
    };
    function format(value, opts) {
      return config.getFormatter(opts).format(value);
    }
    function formatProp(value) {
      var formatter = config.getFormatter();
      return sformat.formatPlainObjectKey.call(formatter, value);
    }
    function AssertionError(options) {
      shouldUtil.merge(this, options);
      if (!options.message) {
        Object.defineProperty(this, "message", {
          get: function() {
            if (!this._message) {
              this._message = this.generateMessage();
              this.generatedMessage = true;
            }
            return this._message;
          },
          configurable: true,
          enumerable: false
        });
      }
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.stackStartFunction);
      } else {
        var err = new Error();
        if (err.stack) {
          var out = err.stack;
          if (this.stackStartFunction) {
            var fn_name = functionName(this.stackStartFunction);
            var idx = out.indexOf("\n" + fn_name);
            if (idx >= 0) {
              var next_line = out.indexOf("\n", idx + 1);
              out = out.substring(next_line + 1);
            }
          }
          this.stack = out;
        }
      }
    }
    var indent = "    ";
    function prependIndent(line) {
      return indent + line;
    }
    function indentLines(text) {
      return text.split("\n").map(prependIndent).join("\n");
    }
    AssertionError.prototype = Object.create(Error.prototype, {
      name: {
        value: "AssertionError"
      },
      generateMessage: {
        value: function() {
          if (!this.operator && this.previous) {
            return this.previous.message;
          }
          var actual = format(this.actual);
          var expected = "expected" in this ? " " + format(this.expected) : "";
          var details = "details" in this && this.details ? " (" + this.details + ")" : "";
          var previous = this.previous ? "\n" + indentLines(this.previous.message) : "";
          return "expected " + actual + (this.negate ? " not " : " ") + this.operator + expected + details + previous;
        }
      }
    });
    function LightAssertionError(options) {
      shouldUtil.merge(this, options);
      if (!options.message) {
        Object.defineProperty(this, "message", {
          get: function() {
            if (!this._message) {
              this._message = this.generateMessage();
              this.generatedMessage = true;
            }
            return this._message;
          }
        });
      }
    }
    LightAssertionError.prototype = {
      generateMessage: AssertionError.prototype.generateMessage
    };
    function Assertion(obj) {
      this.obj = obj;
      this.anyOne = false;
      this.negate = false;
      this.params = { actual: obj };
    }
    Assertion.prototype = {
      constructor: Assertion,
      /**
       * Base method for assertions.
       *
       * Before calling this method need to fill Assertion#params object. This method usually called from other assertion methods.
       * `Assertion#params` can contain such properties:
       * * `operator` - required string containing description of this assertion
       * * `obj` - optional replacement for this.obj, it is useful if you prepare more clear object then given
       * * `message` - if this property filled with string any others will be ignored and this one used as assertion message
       * * `expected` - any object used when you need to assert relation between given object and expected. Like given == expected (== is a relation)
       * * `details` - additional string with details to generated message
       *
       * @memberOf Assertion
       * @category assertion
       * @param {*} expr Any expression that will be used as a condition for asserting.
       * @example
       *
       * var a = new should.Assertion(42);
       *
       * a.params = {
       *  operator: 'to be magic number',
       * }
       *
       * a.assert(false);
       * //throws AssertionError: expected 42 to be magic number
       */
      assert: function(expr) {
        if (expr) {
          return this;
        }
        var params = this.params;
        if ("obj" in params && !("actual" in params)) {
          params.actual = params.obj;
        } else if (!("obj" in params) && !("actual" in params)) {
          params.actual = this.obj;
        }
        params.stackStartFunction = params.stackStartFunction || this.assert;
        params.negate = this.negate;
        params.assertion = this;
        if (this.light) {
          throw new LightAssertionError(params);
        } else {
          throw new AssertionError(params);
        }
      },
      /**
       * Shortcut for `Assertion#assert(false)`.
       *
       * @memberOf Assertion
       * @category assertion
       * @example
       *
       * var a = new should.Assertion(42);
       *
       * a.params = {
       *  operator: 'to be magic number',
       * }
       *
       * a.fail();
       * //throws AssertionError: expected 42 to be magic number
       */
      fail: function() {
        return this.assert(false);
      },
      assertZeroArguments: function(args) {
        if (args.length !== 0) {
          throw new TypeError("This assertion does not expect any arguments. You may need to check your code");
        }
      }
    };
    function PromisedAssertion() {
      Assertion.apply(this, arguments);
    }
    PromisedAssertion.prototype.then = function(resolve, reject) {
      return this.obj.then(resolve, reject);
    };
    Assertion.add = function(name, func) {
      Object.defineProperty(Assertion.prototype, name, {
        enumerable: true,
        configurable: true,
        value: function() {
          var context = new Assertion(this.obj, this, name);
          context.anyOne = this.anyOne;
          context.onlyThis = this.onlyThis;
          context.light = true;
          try {
            func.apply(context, arguments);
          } catch (e) {
            if (e instanceof AssertionError || e instanceof LightAssertionError) {
              if (this.negate) {
                this.obj = context.obj;
                this.negate = false;
                return this;
              }
              if (context !== e.assertion) {
                context.params.previous = e;
              }
              context.negate = false;
              context.light = false;
              context.fail();
            }
            throw e;
          }
          if (this.negate) {
            context.negate = true;
            context.params.details = "false negative fail";
            context.light = false;
            context.fail();
          }
          if (!this.params.operator) {
            this.params = context.params;
          }
          this.obj = context.obj;
          this.negate = false;
          return this;
        }
      });
      Object.defineProperty(PromisedAssertion.prototype, name, {
        enumerable: true,
        configurable: true,
        value: function() {
          var args = arguments;
          this.obj = this.obj.then(function(a) {
            return a[name].apply(a, args);
          });
          return this;
        }
      });
    };
    Assertion.addChain = function(name, onCall) {
      onCall = onCall || function() {
      };
      Object.defineProperty(Assertion.prototype, name, {
        get: function() {
          onCall.call(this);
          return this;
        },
        enumerable: true
      });
      Object.defineProperty(PromisedAssertion.prototype, name, {
        enumerable: true,
        configurable: true,
        get: function() {
          this.obj = this.obj.then(function(a) {
            return a[name];
          });
          return this;
        }
      });
    };
    Assertion.alias = function(from, to) {
      var desc = Object.getOwnPropertyDescriptor(Assertion.prototype, from);
      if (!desc) {
        throw new Error("Alias " + from + " -> " + to + " could not be created as " + from + " not defined");
      }
      Object.defineProperty(Assertion.prototype, to, desc);
      var desc2 = Object.getOwnPropertyDescriptor(PromisedAssertion.prototype, from);
      if (desc2) {
        Object.defineProperty(PromisedAssertion.prototype, to, desc2);
      }
    };
    Assertion.addChain("not", function() {
      this.negate = !this.negate;
    });
    Assertion.addChain("any", function() {
      this.anyOne = true;
    });
    Assertion.addChain("only", function() {
      this.onlyThis = true;
    });
    var pSlice = Array.prototype.slice;
    var assert = ok;
    function fail(actual, expected, message, operator, stackStartFunction) {
      var a = new Assertion(actual);
      a.params = {
        operator,
        expected,
        message,
        stackStartFunction: stackStartFunction || fail
      };
      a.fail();
    }
    assert.fail = fail;
    function ok(value, message) {
      if (!value) {
        fail(value, true, message, "==", assert.ok);
      }
    }
    assert.ok = ok;
    assert.equal = function equal(actual, expected, message) {
      if (actual != expected) {
        fail(actual, expected, message, "==", assert.equal);
      }
    };
    assert.notEqual = function notEqual(actual, expected, message) {
      if (actual == expected) {
        fail(actual, expected, message, "!=", assert.notEqual);
      }
    };
    assert.deepEqual = function deepEqual(actual, expected, message) {
      if (eql(actual, expected).length !== 0) {
        fail(actual, expected, message, "deepEqual", assert.deepEqual);
      }
    };
    assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
      if (eql(actual, expected).result) {
        fail(actual, expected, message, "notDeepEqual", assert.notDeepEqual);
      }
    };
    assert.strictEqual = function strictEqual(actual, expected, message) {
      if (actual !== expected) {
        fail(actual, expected, message, "===", assert.strictEqual);
      }
    };
    assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
      if (actual === expected) {
        fail(actual, expected, message, "!==", assert.notStrictEqual);
      }
    };
    function expectedException(actual, expected) {
      if (!actual || !expected) {
        return false;
      }
      if (Object.prototype.toString.call(expected) == "[object RegExp]") {
        return expected.test(actual);
      } else if (actual instanceof expected) {
        return true;
      } else if (expected.call({}, actual) === true) {
        return true;
      }
      return false;
    }
    function _throws(shouldThrow, block, expected, message) {
      var actual;
      if (typeof expected == "string") {
        message = expected;
        expected = null;
      }
      try {
        block();
      } catch (e) {
        actual = e;
      }
      message = (expected && expected.name ? " (" + expected.name + ")" : ".") + (message ? " " + message : ".");
      if (shouldThrow && !actual) {
        fail(actual, expected, "Missing expected exception" + message);
      }
      if (!shouldThrow && expectedException(actual, expected)) {
        fail(actual, expected, "Got unwanted exception" + message);
      }
      if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
        throw actual;
      }
    }
    assert.throws = function() {
      _throws.apply(this, [true].concat(pSlice.call(arguments)));
    };
    assert.doesNotThrow = function() {
      _throws.apply(this, [false].concat(pSlice.call(arguments)));
    };
    assert.ifError = function(err) {
      if (err) {
        throw err;
      }
    };
    function assertExtensions(should) {
      var i = should.format;
      shouldUtil.merge(should, assert);
      should.exist = should.exists = function(obj, msg) {
        if (null == obj) {
          throw new AssertionError({
            message: msg || "expected " + i(obj) + " to exist",
            stackStartFunction: should.exist
          });
        }
      };
      should.not = {};
      should.not.exist = should.not.exists = function(obj, msg) {
        if (null != obj) {
          throw new AssertionError({
            message: msg || "expected " + i(obj) + " to not exist",
            stackStartFunction: should.not.exist
          });
        }
      };
    }
    function chainAssertions(should, Assertion2) {
      [
        "an",
        "of",
        "a",
        "and",
        "be",
        "been",
        "has",
        "have",
        "with",
        "is",
        "which",
        "the",
        "it"
      ].forEach(function(name) {
        Assertion2.addChain(name);
      });
    }
    function booleanAssertions(should, Assertion2) {
      Assertion2.add("true", function(message) {
        this.is.exactly(true, message);
      });
      Assertion2.alias("true", "True");
      Assertion2.add("false", function(message) {
        this.is.exactly(false, message);
      });
      Assertion2.alias("false", "False");
      Assertion2.add("ok", function() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be truthy" };
        this.assert(this.obj);
      });
    }
    function numberAssertions(should, Assertion2) {
      Assertion2.add("NaN", function() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be NaN" };
        this.assert(this.obj !== this.obj);
      });
      Assertion2.add("Infinity", function() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be Infinity" };
        this.is.a.Number().and.not.a.NaN().and.assert(!isFinite(this.obj));
      });
      Assertion2.add("within", function(start, finish, description) {
        this.params = {
          operator: "to be within " + start + ".." + finish,
          message: description
        };
        this.assert(this.obj >= start && this.obj <= finish);
      });
      Assertion2.add("approximately", function(value, delta, description) {
        this.params = {
          operator: "to be approximately " + value + " \xB1" + delta,
          message: description
        };
        this.assert(Math.abs(this.obj - value) <= delta);
      });
      Assertion2.add("above", function(n, description) {
        this.params = { operator: "to be above " + n, message: description };
        this.assert(this.obj > n);
      });
      Assertion2.add("below", function(n, description) {
        this.params = { operator: "to be below " + n, message: description };
        this.assert(this.obj < n);
      });
      Assertion2.alias("above", "greaterThan");
      Assertion2.alias("below", "lessThan");
      Assertion2.add("aboveOrEqual", function(n, description) {
        this.params = {
          operator: "to be above or equal " + n,
          message: description
        };
        this.assert(this.obj >= n);
      });
      Assertion2.add("belowOrEqual", function(n, description) {
        this.params = {
          operator: "to be below or equal " + n,
          message: description
        };
        this.assert(this.obj <= n);
      });
      Assertion2.alias("aboveOrEqual", "greaterThanOrEqual");
      Assertion2.alias("belowOrEqual", "lessThanOrEqual");
    }
    function typeAssertions(should, Assertion2) {
      Assertion2.add("Number", function() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be a number" };
        this.have.type("number");
      });
      Assertion2.add("arguments", function() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be arguments" };
        this.have.class("Arguments");
      });
      Assertion2.alias("arguments", "Arguments");
      Assertion2.add("type", function(type, description) {
        this.params = { operator: "to have type " + type, message: description };
        should(typeof this.obj).be.exactly(type);
      });
      Assertion2.add("instanceof", function(constructor, description) {
        this.params = {
          operator: "to be an instance of " + functionName(constructor),
          message: description
        };
        this.assert(Object(this.obj) instanceof constructor);
      });
      Assertion2.alias("instanceof", "instanceOf");
      Assertion2.add("Function", function() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be a function" };
        this.have.type("function");
      });
      Assertion2.add("Object", function() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be an object" };
        this.is.not.null().and.have.type("object");
      });
      Assertion2.add("String", function() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be a string" };
        this.have.type("string");
      });
      Assertion2.add("Array", function() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be an array" };
        this.have.class("Array");
      });
      Assertion2.add("Boolean", function() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be a boolean" };
        this.have.type("boolean");
      });
      Assertion2.add("Error", function() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be an error" };
        this.have.instanceOf(Error);
      });
      Assertion2.add("Date", function() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be a date" };
        this.have.instanceOf(Date);
      });
      Assertion2.add("null", function() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be null" };
        this.assert(this.obj === null);
      });
      Assertion2.alias("null", "Null");
      Assertion2.add("class", function(cls) {
        this.params = { operator: "to have [[Class]] " + cls };
        this.assert(Object.prototype.toString.call(this.obj) === "[object " + cls + "]");
      });
      Assertion2.alias("class", "Class");
      Assertion2.add("undefined", function() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be undefined" };
        this.assert(this.obj === void 0);
      });
      Assertion2.alias("undefined", "Undefined");
      Assertion2.add("iterable", function() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be iterable" };
        should(this.obj).have.property(Symbol.iterator).which.is.a.Function();
      });
      Assertion2.add("iterator", function() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be iterator" };
        should(this.obj).have.property("next").which.is.a.Function();
      });
      Assertion2.add("generator", function() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be generator" };
        should(this.obj).be.iterable.and.iterator.and.it.is.equal(this.obj[Symbol.iterator]());
      });
    }
    function formatEqlResult(r, a, b) {
      return ((r.path.length > 0 ? "at " + r.path.map(formatProp).join(" -> ") : "") + (r.a === a ? "" : ", A has " + format(r.a)) + (r.b === b ? "" : " and B has " + format(r.b)) + (r.showReason ? " because " + r.reason : "")).trim();
    }
    function equalityAssertions(should, Assertion2) {
      Assertion2.add("eql", function(val, description) {
        this.params = { operator: "to equal", expected: val, message: description };
        var obj = this.obj;
        var fails = eql(this.obj, val, should.config);
        this.params.details = fails.map(function(fail2) {
          return formatEqlResult(fail2, obj, val);
        }).join(", ");
        this.params.showDiff = eql(getType(obj), getType(val)).length === 0;
        this.assert(fails.length === 0);
      });
      Assertion2.add("equal", function(val, description) {
        this.params = { operator: "to be", expected: val, message: description };
        this.params.showDiff = eql(getType(this.obj), getType(val)).length === 0;
        this.assert(val === this.obj);
      });
      Assertion2.alias("equal", "equals");
      Assertion2.alias("equal", "exactly");
      Assertion2.alias("eql", "eqls");
      Assertion2.alias("eql", "deepEqual");
      function addOneOf(name, message, method) {
        Assertion2.add(name, function(vals) {
          if (arguments.length !== 1) {
            vals = Array.prototype.slice.call(arguments);
          } else {
            should(vals).be.Array();
          }
          this.params = { operator: message, expected: vals };
          var obj = this.obj;
          var found = false;
          shouldTypeAdaptors.forEach(vals, function(val) {
            try {
              should(val)[method](obj);
              found = true;
              return false;
            } catch (e) {
              if (e instanceof should.AssertionError) {
                return;
              }
              throw e;
            }
          });
          this.assert(found);
        });
      }
      addOneOf("equalOneOf", "to be equals one of", "equal");
      addOneOf("oneOf", "to be one of", "eql");
    }
    function promiseAssertions(should, Assertion$$1) {
      Assertion$$1.add("Promise", function() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be promise" };
        var obj = this.obj;
        should(obj).have.property("then").which.is.a.Function();
      });
      Assertion$$1.prototype.fulfilled = function Assertion$fulfilled() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be fulfilled" };
        should(this.obj).be.a.Promise();
        var that = this;
        return this.obj.then(
          function next$onResolve(value) {
            if (that.negate) {
              that.fail();
            }
            return value;
          },
          function next$onReject(err) {
            if (!that.negate) {
              that.params.operator += ", but it was rejected with " + should.format(err);
              that.fail();
            }
            return err;
          }
        );
      };
      Assertion$$1.prototype.resolved = Assertion$$1.prototype.fulfilled;
      Assertion$$1.prototype.rejected = function() {
        this.assertZeroArguments(arguments);
        this.params = { operator: "to be rejected" };
        should(this.obj).be.a.Promise();
        var that = this;
        return this.obj.then(
          function(value) {
            if (!that.negate) {
              that.params.operator += ", but it was fulfilled";
              if (arguments.length != 0) {
                that.params.operator += " with " + should.format(value);
              }
              that.fail();
            }
            return value;
          },
          function next$onError(err) {
            if (that.negate) {
              that.fail();
            }
            return err;
          }
        );
      };
      Assertion$$1.prototype.fulfilledWith = function(expectedValue) {
        this.params = {
          operator: "to be fulfilled with " + should.format(expectedValue)
        };
        should(this.obj).be.a.Promise();
        var that = this;
        return this.obj.then(
          function(value) {
            if (that.negate) {
              that.fail();
            }
            should(value).eql(expectedValue);
            return value;
          },
          function next$onError(err) {
            if (!that.negate) {
              that.params.operator += ", but it was rejected with " + should.format(err);
              that.fail();
            }
            return err;
          }
        );
      };
      Assertion$$1.prototype.resolvedWith = Assertion$$1.prototype.fulfilledWith;
      Assertion$$1.prototype.rejectedWith = function(message, properties) {
        this.params = { operator: "to be rejected" };
        should(this.obj).be.a.Promise();
        var that = this;
        return this.obj.then(
          function(value) {
            if (!that.negate) {
              that.fail();
            }
            return value;
          },
          function next$onError(err) {
            if (that.negate) {
              that.fail();
            }
            var errorMatched = true;
            var errorInfo = "";
            if ("string" === typeof message) {
              errorMatched = message === err.message;
            } else if (message instanceof RegExp) {
              errorMatched = message.test(err.message);
            } else if ("function" === typeof message) {
              errorMatched = err instanceof message;
            } else if (message !== null && typeof message === "object") {
              try {
                should(err).match(message);
              } catch (e) {
                if (e instanceof should.AssertionError) {
                  errorInfo = ": " + e.message;
                  errorMatched = false;
                } else {
                  throw e;
                }
              }
            }
            if (!errorMatched) {
              if (typeof message === "string" || message instanceof RegExp) {
                errorInfo = " with a message matching " + should.format(message) + ", but got '" + err.message + "'";
              } else if ("function" === typeof message) {
                errorInfo = " of type " + functionName(message) + ", but got " + functionName(err.constructor);
              }
            } else if ("function" === typeof message && properties) {
              try {
                should(err).match(properties);
              } catch (e) {
                if (e instanceof should.AssertionError) {
                  errorInfo = ": " + e.message;
                  errorMatched = false;
                } else {
                  throw e;
                }
              }
            }
            that.params.operator += errorInfo;
            that.assert(errorMatched);
            return err;
          }
        );
      };
      Object.defineProperty(Assertion$$1.prototype, "finally", {
        get: function() {
          should(this.obj).be.a.Promise();
          var that = this;
          return new PromisedAssertion(
            this.obj.then(function(obj) {
              var a = should(obj);
              a.negate = that.negate;
              a.anyOne = that.anyOne;
              return a;
            })
          );
        }
      });
      Assertion$$1.alias("finally", "eventually");
    }
    function stringAssertions(should, Assertion2) {
      Assertion2.add("startWith", function(str, description) {
        this.params = {
          operator: "to start with " + should.format(str),
          message: description
        };
        this.assert(0 === this.obj.indexOf(str));
      });
      Assertion2.add("endWith", function(str, description) {
        this.params = {
          operator: "to end with " + should.format(str),
          message: description
        };
        this.assert(this.obj.indexOf(str, this.obj.length - str.length) >= 0);
      });
    }
    function containAssertions(should, Assertion2) {
      var i = should.format;
      Assertion2.add("containEql", function(other) {
        this.params = { operator: "to contain " + i(other) };
        this.is.not.null().and.not.undefined();
        var obj = this.obj;
        if (typeof obj == "string") {
          this.assert(obj.indexOf(String(other)) >= 0);
        } else if (shouldTypeAdaptors.isIterable(obj)) {
          this.assert(
            shouldTypeAdaptors.some(obj, function(v) {
              return eql(v, other).length === 0;
            })
          );
        } else {
          shouldTypeAdaptors.forEach(
            other,
            function(value, key) {
              should(obj).have.value(key, value);
            },
            this
          );
        }
      });
      Assertion2.add("containDeepOrdered", function(other) {
        this.params = { operator: "to contain " + i(other) };
        var obj = this.obj;
        if (typeof obj == "string") {
          this.is.equal(String(other));
        } else if (shouldTypeAdaptors.isIterable(obj) && shouldTypeAdaptors.isIterable(other)) {
          var objIterator = shouldTypeAdaptors.iterator(obj);
          var otherIterator = shouldTypeAdaptors.iterator(other);
          var nextObj = objIterator.next();
          var nextOther = otherIterator.next();
          while (!nextObj.done && !nextOther.done) {
            try {
              should(nextObj.value[1]).containDeepOrdered(nextOther.value[1]);
              nextOther = otherIterator.next();
            } catch (e) {
              if (!(e instanceof should.AssertionError)) {
                throw e;
              }
            }
            nextObj = objIterator.next();
          }
          this.assert(nextOther.done);
        } else if (obj != null && typeof obj == "object" && other != null && typeof other == "object") {
          shouldTypeAdaptors.forEach(other, function(value, key) {
            should(obj[key]).containDeepOrdered(value);
          });
          if (shouldTypeAdaptors.isEmpty(other)) {
            this.eql(other);
          }
        } else {
          this.eql(other);
        }
      });
      Assertion2.add("containDeep", function(other) {
        this.params = { operator: "to contain " + i(other) };
        var obj = this.obj;
        if (typeof obj === "string" && typeof other === "string") {
          this.is.equal(String(other));
        } else if (shouldTypeAdaptors.isIterable(obj) && shouldTypeAdaptors.isIterable(other)) {
          var usedKeys = {};
          shouldTypeAdaptors.forEach(
            other,
            function(otherItem) {
              this.assert(
                shouldTypeAdaptors.some(obj, function(item, index) {
                  if (index in usedKeys) {
                    return false;
                  }
                  try {
                    should(item).containDeep(otherItem);
                    usedKeys[index] = true;
                    return true;
                  } catch (e) {
                    if (e instanceof should.AssertionError) {
                      return false;
                    }
                    throw e;
                  }
                })
              );
            },
            this
          );
        } else if (obj != null && other != null && typeof obj == "object" && typeof other == "object") {
          shouldTypeAdaptors.forEach(other, function(value, key) {
            should(obj[key]).containDeep(value);
          });
          if (shouldTypeAdaptors.isEmpty(other)) {
            this.eql(other);
          }
        } else {
          this.eql(other);
        }
      });
    }
    var aSlice = Array.prototype.slice;
    function propertyAssertions(should, Assertion2) {
      var i = should.format;
      Assertion2.add("propertyWithDescriptor", function(name, desc) {
        this.params = {
          actual: this.obj,
          operator: "to have own property with descriptor " + i(desc)
        };
        var obj = this.obj;
        this.have.ownProperty(name);
        should(Object.getOwnPropertyDescriptor(Object(obj), name)).have.properties(desc);
      });
      Assertion2.add("property", function(name, val) {
        name = convertPropertyName(name);
        if (arguments.length > 1) {
          var p = {};
          p[name] = val;
          this.have.properties(p);
        } else {
          this.have.properties(name);
        }
        this.obj = this.obj[name];
      });
      Assertion2.add("properties", function(names) {
        var values = {};
        if (arguments.length > 1) {
          names = aSlice.call(arguments);
        } else if (!Array.isArray(names)) {
          if (typeof names == "string" || typeof names == "symbol") {
            names = [names];
          } else {
            values = names;
            names = Object.keys(names);
          }
        }
        var obj = Object(this.obj), missingProperties = [];
        names.forEach(function(name) {
          if (!(name in obj)) {
            missingProperties.push(formatProp(name));
          }
        });
        var props = missingProperties;
        if (props.length === 0) {
          props = names.map(formatProp);
        } else if (this.anyOne) {
          props = names.filter(function(name) {
            return missingProperties.indexOf(formatProp(name)) < 0;
          }).map(formatProp);
        }
        var operator = (props.length === 1 ? "to have property " : "to have " + (this.anyOne ? "any of " : "") + "properties ") + props.join(", ");
        this.params = { obj: this.obj, operator };
        this.assert(
          missingProperties.length === 0 || this.anyOne && missingProperties.length != names.length
        );
        var valueCheckNames = Object.keys(values);
        if (valueCheckNames.length) {
          var wrongValues = [];
          props = [];
          valueCheckNames.forEach(function(name) {
            var value = values[name];
            if (eql(obj[name], value).length !== 0) {
              wrongValues.push(formatProp(name) + " of " + i(value) + " (got " + i(obj[name]) + ")");
            } else {
              props.push(formatProp(name) + " of " + i(value));
            }
          });
          if (wrongValues.length !== 0 && !this.anyOne || this.anyOne && props.length === 0) {
            props = wrongValues;
          }
          operator = (props.length === 1 ? "to have property " : "to have " + (this.anyOne ? "any of " : "") + "properties ") + props.join(", ");
          this.params = { obj: this.obj, operator };
          this.assert(
            wrongValues.length === 0 || this.anyOne && wrongValues.length != valueCheckNames.length
          );
        }
      });
      Assertion2.add("length", function(n, description) {
        this.have.property("length", n, description);
      });
      Assertion2.alias("length", "lengthOf");
      Assertion2.add("ownProperty", function(name, description) {
        name = convertPropertyName(name);
        this.params = {
          actual: this.obj,
          operator: "to have own property " + formatProp(name),
          message: description
        };
        this.assert(shouldUtil.hasOwnProperty(this.obj, name));
        this.obj = this.obj[name];
      });
      Assertion2.alias("ownProperty", "hasOwnProperty");
      Assertion2.add(
        "empty",
        function() {
          this.params = { operator: "to be empty" };
          this.assert(shouldTypeAdaptors.isEmpty(this.obj));
        },
        true
      );
      Assertion2.add("keys", function(keys) {
        keys = aSlice.call(arguments);
        var obj = Object(this.obj);
        var missingKeys = keys.filter(function(key) {
          return !shouldTypeAdaptors.has(obj, key);
        });
        var verb = "to have " + (this.onlyThis ? "only " : "") + (keys.length === 1 ? "key " : "keys ");
        this.params = { operator: verb + keys.join(", ") };
        if (missingKeys.length > 0) {
          this.params.operator += "\n	missing keys: " + missingKeys.join(", ");
        }
        this.assert(missingKeys.length === 0);
        if (this.onlyThis) {
          should(obj).have.size(keys.length);
        }
      });
      Assertion2.add("key", function(key) {
        this.have.keys(key);
        this.obj = shouldTypeAdaptors.get(this.obj, key);
      });
      Assertion2.add("value", function(key, value) {
        this.have.key(key).which.is.eql(value);
      });
      Assertion2.add("size", function(s) {
        this.params = { operator: "to have size " + s };
        should(shouldTypeAdaptors.size(this.obj)).be.exactly(s);
      });
      Assertion2.add("propertyByPath", function(properties) {
        properties = aSlice.call(arguments);
        var allProps = properties.map(formatProp);
        properties = properties.map(convertPropertyName);
        var obj = should(Object(this.obj));
        var foundProperties = [];
        var currentProperty;
        while (properties.length) {
          currentProperty = properties.shift();
          this.params = {
            operator: "to have property by path " + allProps.join(", ") + " - failed on " + formatProp(currentProperty)
          };
          obj = obj.have.property(currentProperty);
          foundProperties.push(currentProperty);
        }
        this.params = {
          obj: this.obj,
          operator: "to have property by path " + allProps.join(", ")
        };
        this.obj = obj.obj;
      });
    }
    function errorAssertions(should, Assertion2) {
      var i = should.format;
      Assertion2.add("throw", function(message, properties) {
        var fn = this.obj;
        var err = {};
        var errorInfo = "";
        var thrown = false;
        if (shouldUtil.isGeneratorFunction(fn)) {
          return should(fn()).throw(message, properties);
        } else if (shouldUtil.isIterator(fn)) {
          return should(fn.next.bind(fn)).throw(message, properties);
        }
        this.is.a.Function();
        var errorMatched = true;
        try {
          fn();
        } catch (e) {
          thrown = true;
          err = e;
        }
        if (thrown) {
          if (message) {
            if ("string" == typeof message) {
              errorMatched = message == err.message;
            } else if (message instanceof RegExp) {
              errorMatched = message.test(err.message);
            } else if ("function" == typeof message) {
              errorMatched = err instanceof message;
            } else if (null != message) {
              try {
                should(err).match(message);
              } catch (e) {
                if (e instanceof should.AssertionError) {
                  errorInfo = ": " + e.message;
                  errorMatched = false;
                } else {
                  throw e;
                }
              }
            }
            if (!errorMatched) {
              if ("string" == typeof message || message instanceof RegExp) {
                errorInfo = " with a message matching " + i(message) + ", but got '" + err.message + "'";
              } else if ("function" == typeof message) {
                errorInfo = " of type " + functionName(message) + ", but got " + functionName(err.constructor);
              }
            } else if ("function" == typeof message && properties) {
              try {
                should(err).match(properties);
              } catch (e) {
                if (e instanceof should.AssertionError) {
                  errorInfo = ": " + e.message;
                  errorMatched = false;
                } else {
                  throw e;
                }
              }
            }
          } else {
            errorInfo = " (got " + i(err) + ")";
          }
        }
        this.params = { operator: "to throw exception" + errorInfo };
        this.assert(thrown);
        this.assert(errorMatched);
      });
      Assertion2.alias("throw", "throwError");
    }
    function matchingAssertions(should, Assertion2) {
      var i = should.format;
      Assertion2.add("match", function(other, description) {
        this.params = { operator: "to match " + i(other), message: description };
        if (eql(this.obj, other).length !== 0) {
          if (other instanceof RegExp) {
            if (typeof this.obj == "string") {
              this.assert(other.exec(this.obj));
            } else if (null != this.obj && typeof this.obj == "object") {
              var notMatchedProps = [], matchedProps = [];
              shouldTypeAdaptors.forEach(
                this.obj,
                function(value, name) {
                  if (other.exec(value)) {
                    matchedProps.push(formatProp(name));
                  } else {
                    notMatchedProps.push(formatProp(name) + " (" + i(value) + ")");
                  }
                },
                this
              );
              if (notMatchedProps.length) {
                this.params.operator += "\n    not matched properties: " + notMatchedProps.join(", ");
              }
              if (matchedProps.length) {
                this.params.operator += "\n    matched properties: " + matchedProps.join(", ");
              }
              this.assert(notMatchedProps.length === 0);
            } else {
              this.assert(false);
            }
          } else if (typeof other == "function") {
            var res;
            res = other(this.obj);
            if (typeof res == "boolean") {
              this.assert(res);
            }
          } else if (typeof this.obj == "object" && this.obj != null && (isPlainObject(other) || Array.isArray(other))) {
            notMatchedProps = [];
            matchedProps = [];
            shouldTypeAdaptors.forEach(
              other,
              function(value, key) {
                try {
                  should(this.obj).have.property(key).which.match(value);
                  matchedProps.push(formatProp(key));
                } catch (e) {
                  if (e instanceof should.AssertionError) {
                    notMatchedProps.push(formatProp(key) + " (" + i(this.obj[key]) + ")");
                  } else {
                    throw e;
                  }
                }
              },
              this
            );
            if (notMatchedProps.length) {
              this.params.operator += "\n    not matched properties: " + notMatchedProps.join(", ");
            }
            if (matchedProps.length) {
              this.params.operator += "\n    matched properties: " + matchedProps.join(", ");
            }
            this.assert(notMatchedProps.length === 0);
          } else {
            this.assert(false);
          }
        }
      });
      Assertion2.add("matchEach", function(other, description) {
        this.params = {
          operator: "to match each " + i(other),
          message: description
        };
        shouldTypeAdaptors.forEach(
          this.obj,
          function(value) {
            should(value).match(other);
          },
          this
        );
      });
      Assertion2.add("matchAny", function(other, description) {
        this.params = {
          operator: "to match any " + i(other),
          message: description
        };
        this.assert(
          shouldTypeAdaptors.some(this.obj, function(value) {
            try {
              should(value).match(other);
              return true;
            } catch (e) {
              if (e instanceof should.AssertionError) {
                return false;
              }
              throw e;
            }
          })
        );
      });
      Assertion2.alias("matchAny", "matchSome");
      Assertion2.alias("matchEach", "matchEvery");
    }
    function should$1(obj) {
      return new Assertion(obj);
    }
    should$1.AssertionError = AssertionError;
    should$1.Assertion = Assertion;
    should$1.modules = {
      format: sformat,
      type: getType,
      equal: eql
    };
    should$1.format = format;
    should$1.config = config;
    should$1.extend = function(propertyName, proto) {
      propertyName = propertyName || "should";
      proto = proto || Object.prototype;
      var prevDescriptor = Object.getOwnPropertyDescriptor(proto, propertyName);
      Object.defineProperty(proto, propertyName, {
        set: function() {
        },
        get: function() {
          return should$1(isWrapperType(this) ? this.valueOf() : this);
        },
        configurable: true
      });
      return { name: propertyName, descriptor: prevDescriptor, proto };
    };
    should$1.noConflict = function(desc) {
      desc = desc || should$1._prevShould;
      if (desc) {
        delete desc.proto[desc.name];
        if (desc.descriptor) {
          Object.defineProperty(desc.proto, desc.name, desc.descriptor);
        }
      }
      return should$1;
    };
    should$1.use = function(f) {
      f(should$1, should$1.Assertion);
      return this;
    };
    should$1.use(assertExtensions).use(chainAssertions).use(booleanAssertions).use(numberAssertions).use(equalityAssertions).use(typeAssertions).use(stringAssertions).use(propertyAssertions).use(errorAssertions).use(matchingAssertions).use(containAssertions).use(promiseAssertions);
    var defaultProto = Object.prototype;
    var defaultProperty = "should";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    try {
      prevShould = should$1.extend(defaultProperty, defaultProto);
      should$1._prevShould = prevShould;
      Object.defineProperty(root, "should", {
        enumerable: false,
        configurable: true,
        value: should$1
      });
    } catch (e) {
    }
    var prevShould;
    module2.exports = should$1;
  }
});

// node_modules/@jsreport/jsreport-core/test/store/common.js
var require_common4 = __commonJS({
  "node_modules/@jsreport/jsreport-core/test/store/common.js"(exports2, module2) {
    var should = require_should();
    var Request = require_request();
    module2.exports = (store, runTransactions = true) => {
      describe("public collection", () => {
        collectionTests(store, void 0, runTransactions);
      });
      describe("internal collection", () => {
        collectionTests(store, true, runTransactions);
      });
    };
    function collectionTests(store, isInternal, runTransactions) {
      function getCollection(name) {
        if (!isInternal) {
          return store().collection(name);
        } else {
          return store().internalCollection(name);
        }
      }
      it("insert and query", async () => {
        const colName = !isInternal ? "templates" : "internalTemplates";
        await getCollection(colName).insert({
          name: "test",
          engine: "none",
          recipe: "html"
        });
        const res = await getCollection(colName).find({ name: "test" });
        res.length.should.be.eql(1);
      });
      it("insert and query with condition", async () => {
        const colName = !isInternal ? "templates" : "internalTemplates";
        await getCollection(colName).insert({
          name: "test",
          engine: "none",
          recipe: "html"
        });
        const res = await getCollection(colName).find({ name: "diferent" });
        res.length.should.be.eql(0);
      });
      it("insert, update, query", async () => {
        const colName = !isInternal ? "templates" : "internalTemplates";
        await getCollection(colName).insert({
          name: "test",
          engine: "none",
          recipe: "html"
        });
        await getCollection(colName).update({ name: "test" }, { $set: { recipe: "foo" } });
        const res = await getCollection(colName).find({ name: "test" });
        res.length.should.be.eql(1);
        res[0].recipe.should.be.eql("foo");
      });
      it("insert remove query", async () => {
        const colName = !isInternal ? "templates" : "internalTemplates";
        await getCollection(colName).insert({
          name: "test",
          engine: "none",
          recipe: "html"
        });
        await getCollection(colName).remove({ name: "test" });
        const res = await getCollection(colName).find({ name: "test" });
        res.length.should.be.eql(0);
      });
      it("insert should return an object with _id set", async () => {
        const colName = !isInternal ? "templates" : "internalTemplates";
        const doc = await getCollection(colName).insert({
          name: "test",
          engine: "none",
          recipe: "html"
        });
        doc.should.have.property("_id");
        doc._id.should.be.ok();
      });
      it("update with upsert", async () => {
        const colName = !isInternal ? "templates" : "internalTemplates";
        await getCollection(colName).update({ name: "test" }, {
          $set: {
            name: "test2",
            engine: "none",
            recipe: "html"
          }
        }, { upsert: true });
        const res = await getCollection(colName).find({ name: "test2" });
        res.length.should.be.eql(1);
      });
      it("find should return clones", async () => {
        const colName = !isInternal ? "templates" : "internalTemplates";
        await getCollection(colName).insert({
          name: "test",
          engine: "none",
          recipe: "html",
          content: "original",
          phantom: { header: "original" }
        });
        const res = await getCollection(colName).find({});
        res[0].content = "modified";
        res[0].phantom.header = "modified";
        const res2 = await getCollection(colName).find({});
        res2[0].content.should.be.eql("original");
        res2[0].phantom.header.should.be.eql("original");
      });
      it("insert should use clones", async () => {
        const colName = !isInternal ? "templates" : "internalTemplates";
        const doc = {
          name: "test",
          engine: "none",
          recipe: "html",
          content: "original",
          phantom: { header: "original" }
        };
        await getCollection(colName).insert(doc);
        doc.content = "modified";
        doc.phantom.header = "modified";
        const res = await getCollection(colName).find({});
        res[0].content.should.be.eql("original");
        res[0].phantom.header.should.be.eql("original");
      });
      it("update should use clones", async () => {
        const colName = !isInternal ? "templates" : "internalTemplates";
        await store().collection("folders").insert({
          name: "f1",
          shortid: "f1"
        });
        await getCollection(colName).insert({
          name: "test",
          engine: "none",
          recipe: "html",
          content: "original"
        });
        const set = {
          folder: {
            shortid: "f1"
          }
        };
        await getCollection(colName).update({ name: "test" }, { $set: set });
        set.folder.shortid = "changing";
        const res = await getCollection(colName).findOne({});
        res.folder.shortid.should.be.eql("f1");
      });
      it("skip and limit", async () => {
        const colName = !isInternal ? "templates" : "internalTemplates";
        await getCollection(colName).insert({
          name: "1",
          engine: "none",
          recipe: "html"
        });
        await getCollection(colName).insert({
          name: "3",
          engine: "none",
          recipe: "html"
        });
        await getCollection(colName).insert({
          name: "2",
          engine: "none",
          recipe: "html"
        });
        const res = await getCollection(colName).find({}).sort({ name: 1 }).skip(1).limit(1).toArray();
        res.length.should.be.eql(1);
        res[0].name.should.be.eql("2");
      });
      it("$and", async () => {
        const colName = !isInternal ? "templates" : "internalTemplates";
        await getCollection(colName).insert({ name: "1", engine: "none", recipe: "a" });
        await getCollection(colName).insert({ name: "2", engine: "none", recipe: "b" });
        await getCollection(colName).insert({ name: "3", engine: "none", recipe: "b" });
        const res = await getCollection(colName).find({ $and: [{ name: "2" }, { recipe: "b" }] }).toArray();
        res.length.should.be.eql(1);
        res[0].name.should.be.eql("2");
        res[0].recipe.should.be.eql("b");
      });
      it("projection", async () => {
        const colName = !isInternal ? "templates" : "internalTemplates";
        await getCollection(colName).insert({ name: "1", engine: "none", recipe: "a" });
        const res = await getCollection(colName).find({}, { recipe: 1 });
        res.length.should.be.eql(1);
        res[0].should.not.have.property("name");
        res[0].recipe.should.be.eql("a");
      });
      it("count", async () => {
        const colName = !isInternal ? "templates" : "internalTemplates";
        await getCollection(colName).insert({ name: "1", engine: "none", recipe: "a" });
        const res = await getCollection(colName).find({}).count();
        res.should.be.eql(1);
      });
      it("count without cursor", async () => {
        const colName = !isInternal ? "templates" : "internalTemplates";
        await getCollection(colName).insert({ name: "1", engine: "none", recipe: "a" });
        const res = await getCollection(colName).count({});
        res.should.be.eql(1);
      });
      it("projection should not be applied when second param is request", async () => {
        const colName = !isInternal ? "templates" : "internalTemplates";
        await getCollection(colName).insert({ name: "test", engine: "none", recipe: "html" });
        const res = await getCollection(colName).find({ name: "test" }, Request({ template: {} }));
        res[0].name.should.be.eql("test");
      });
      it("update should return 1 if upsert", async () => {
        const colName = !isInternal ? "templates" : "internalTemplates";
        const res = await getCollection(colName).update({ name: "test" }, { $set: { name: "test2", engine: "none", recipe: "html" } }, { upsert: true });
        res.should.be.eql(1);
      });
      it("update should return number of updated items", async () => {
        const colName = !isInternal ? "templates" : "internalTemplates";
        await getCollection(colName).insert({ name: "1", engine: "none", recipe: "a" });
        await getCollection(colName).insert({ name: "2", engine: "test2", recipe: "a" });
        const res = await getCollection(colName).update({ recipe: "a" }, { $set: { engine: "test2" } });
        res.should.be.eql(2);
      });
      it("should validate duplicated _id on insert", async () => {
        const newEntity = await store().collection("templates").insert({
          name: "a",
          content: "x",
          engine: "none",
          recipe: "html"
        });
        return should(store().collection("templates").insert({
          _id: newEntity._id,
          name: "b",
          content: "x",
          engine: "none",
          recipe: "html"
        })).be.rejected();
      });
      it("should validate duplicated _id on update", async () => {
        const a = await store().collection("templates").insert({
          name: "a",
          engine: "none",
          recipe: "html"
        });
        const b = await store().collection("templates").insert({
          name: "b",
          engine: "none",
          recipe: "html"
        });
        return should(store().collection("templates").update({
          _id: a._id
        }, {
          $set: {
            _id: b._id
          }
        })).be.rejected();
      });
      it("should validate duplicated shortid on upsert", async () => {
        const a = await store().collection("templates").insert({
          name: "a",
          engine: "none",
          recipe: "html"
        });
        return should(store().collection("templates").update({
          name: "b"
        }, {
          $set: {
            _id: a._id,
            name: "b"
          }
        }, { upsert: true })).be.rejected();
      });
      it("should validate duplicated shortid on insert", async () => {
        await store().collection("templates").insert({
          name: "a",
          shortid: "a",
          engine: "none",
          recipe: "html"
        });
        return should(store().collection("templates").insert({
          name: "b",
          shortid: "a",
          engine: "none",
          recipe: "html"
        })).be.rejected();
      });
      it("should validate duplicated shortid on update", async () => {
        const a = await store().collection("templates").insert({
          name: "a",
          shortid: "a",
          engine: "none",
          recipe: "html"
        });
        await store().collection("templates").insert({
          name: "b",
          shortid: "b",
          engine: "none",
          recipe: "html"
        });
        return should(store().collection("templates").update({
          _id: a._id
        }, {
          $set: {
            shortid: "b"
          }
        })).be.rejected();
      });
      it("should validate duplicated shortid on upsert", async () => {
        await store().collection("templates").insert({
          name: "a",
          shortid: "a",
          engine: "none",
          recipe: "html"
        });
        return should(store().collection("templates").update({
          name: "b"
        }, {
          $set: {
            name: "b",
            shortid: "a"
          }
        }, { upsert: true })).be.rejected();
      });
      if (runTransactions) {
        describe("transactions", () => {
          it("should be able to start", async () => {
            const req = Request({});
            await store().beginTransaction(req);
            req.context.storeTransaction.should.be.not.empty();
            await store().commitTransaction(req);
          });
          it("should fail when trying to start more than once", async () => {
            const req = Request({});
            await store().beginTransaction(req);
            try {
              await store().beginTransaction(req);
              throw new Error("it should have failed calling beginTransaction twice");
            } catch (e) {
              e.message.should.containEql("active transaction already exists");
            }
            await store().commitTransaction(req);
          });
          it("should fail when commit without start", async () => {
            const req = Request({});
            return should(store().commitTransaction(req)).be.rejectedWith(/without an active transaction/);
          });
          it("should fail when rollback without start", async () => {
            const req = Request({});
            return should(store().rollbackTransaction(req)).be.rejectedWith(/without an active transaction/);
          });
          it("should fail when commit more than once", async () => {
            const req = Request({});
            await store().beginTransaction(req);
            await store().commitTransaction(req);
            return should(store().commitTransaction(req)).be.rejectedWith(/without an active transaction/);
          });
          it("should fail when rollback more than once", async () => {
            const req = Request({});
            await store().beginTransaction(req);
            await store().rollbackTransaction(req);
            return should(store().rollbackTransaction(req)).be.rejectedWith(/without an active transaction/);
          });
          it("should fail when rollback after commit", async () => {
            const req = Request({});
            await store().beginTransaction(req);
            await store().commitTransaction(req);
            return should(store().rollbackTransaction(req)).rejectedWith(/without an active transaction/);
          });
          it("should fail when commit after rollback", async () => {
            const req = Request({});
            await store().beginTransaction(req);
            await store().rollbackTransaction(req);
            return should(store().commitTransaction(req)).rejectedWith(/without an active transaction/);
          });
          it("should be able to commit (insert)", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            await store().beginTransaction(req);
            try {
              const t1 = {
                name: "t1",
                engine: "none",
                recipe: "html"
              };
              await getCollection(colName).insert(t1, req);
              await store().commitTransaction(req);
            } catch (e) {
              await store().rollbackTransaction(req);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found != null).be.True();
          });
          it("insert with transaction should use clones", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            await store().beginTransaction(req);
            try {
              const t1 = {
                name: "t1",
                engine: "none",
                recipe: "html"
              };
              const newT1 = await getCollection(colName).insert(t1, req);
              newT1.name = "fake-t1";
              await store().commitTransaction(req);
            } catch (e) {
              await store().rollbackTransaction(req);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found).not.be.null();
          });
          it("should be able to rollback (insert)", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            await store().beginTransaction(req);
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await getCollection(colName).insert(t1, req);
            await store().rollbackTransaction(req);
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found == null).be.True();
          });
          it("should be able to commit (update)", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const t1 = {
              name: "t1",
              content: "t1",
              engine: "none",
              recipe: "html"
            };
            await getCollection(colName).insert(t1);
            await store().beginTransaction(req);
            try {
              await getCollection(colName).update({
                name: "t1"
              }, {
                $set: {
                  content: "t1-new",
                  engine: "handlebars"
                }
              }, req);
              await store().commitTransaction(req);
            } catch (e) {
              await store().rollbackTransaction(req);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found.engine).be.eql("handlebars");
            should(found.content).be.eql("t1-new");
          });
          it("should be able to rollback (update)", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await getCollection(colName).insert(t1);
            await store().beginTransaction(req);
            await getCollection(colName).update({
              name: "t1"
            }, {
              $set: {
                engine: "handlebars"
              }
            }, req);
            await store().rollbackTransaction(req);
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found.engine).be.eql("none");
          });
          it("should be able to commit (upsert)", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await store().beginTransaction(req);
            try {
              await getCollection(colName).insert(t1, req);
              await getCollection(colName).update({
                name: "t1"
              }, {
                $set: {
                  engine: "handlebars"
                }
              }, req);
              await store().commitTransaction(req);
            } catch (e) {
              await store().rollbackTransaction(req);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found != null).be.True();
          });
          it("should be able to rollback (upsert)", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await store().beginTransaction(req);
            await getCollection(colName).insert(t1, req);
            await getCollection(colName).update({
              name: "t1"
            }, {
              $set: {
                engine: "handlebars"
              }
            }, req);
            await store().rollbackTransaction(req);
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found == null).be.True();
          });
          it("should be able to commit (remove)", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await getCollection(colName).insert(t1);
            await store().beginTransaction(req);
            try {
              await getCollection(colName).remove({
                name: "t1"
              }, req);
              await store().commitTransaction(req);
            } catch (e) {
              await store().rollbackTransaction(req);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found == null).be.True();
          });
          it("should be able to rollback (remove)", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await getCollection(colName).insert(t1);
            await store().beginTransaction(req);
            await getCollection(colName).remove({
              name: "t1"
            }, req);
            await store().rollbackTransaction(req);
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found != null).be.True();
          });
          it("should be able to commit across collections", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const colName2 = !isInternal ? "templates2" : "internalTemplates2";
            const req = Request({});
            await store().beginTransaction(req);
            try {
              const t1 = {
                name: "t1",
                engine: "none",
                recipe: "html"
              };
              const t2 = {
                name: "t2",
                engine: "none",
                recipe: "html"
              };
              await getCollection(colName).insert(t1, req);
              await getCollection(colName2).insert(t2, req);
              await store().commitTransaction(req);
            } catch (e) {
              await store().rollbackTransaction(req);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            const found2 = await getCollection(colName2).findOne({ name: "t2" });
            should(found != null).be.True();
            should(found2 != null).be.True();
          });
          it("should be able to rollback across collections", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const colName2 = !isInternal ? "templates2" : "internalTemplates2";
            const req = Request({});
            await store().beginTransaction(req);
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            const t2 = {
              name: "t2",
              engine: "none",
              recipe: "html"
            };
            await getCollection(colName).insert(t1, req);
            await getCollection(colName).insert(t2, req);
            await store().rollbackTransaction(req);
            const found = await getCollection(colName).findOne({ name: "t1" });
            const found2 = await getCollection(colName2).findOne({ name: "t1" });
            should(found == null).be.True();
            should(found2 == null).be.True();
          });
          it("should be able to see entity created inside transaction", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            await store().beginTransaction(req);
            try {
              const t1 = {
                name: "t1",
                engine: "none",
                recipe: "html"
              };
              await getCollection(colName).insert(t1, req);
              const found2 = await getCollection(colName).findOne({ name: "t1" }, req);
              should(found2 != null).be.True();
              await store().commitTransaction(req);
            } catch (e) {
              await store().rollbackTransaction(req);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found != null).be.True();
          });
          it("should be able to see entity updated inside transaction", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await getCollection(colName).insert(t1);
            await store().beginTransaction(req);
            try {
              await getCollection(colName).update({
                name: "t1"
              }, {
                $set: {
                  engine: "handlebars"
                }
              }, req);
              const found2 = await getCollection(colName).findOne({ name: "t1" }, req);
              should(found2 != null).be.True();
              await store().commitTransaction(req);
            } catch (e) {
              await store().rollbackTransaction(req);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found != null).be.True();
          });
          it("should be able to see entity updated properties inside transaction", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await getCollection(colName).insert(t1);
            await store().beginTransaction(req);
            try {
              await getCollection(colName).update({
                name: "t1"
              }, {
                $set: {
                  engine: "handlebars"
                }
              }, req);
              const found2 = await getCollection(colName).findOne({ name: "t1" }, req);
              should(found2.engine).be.eql("handlebars");
              await store().commitTransaction(req);
            } catch (e) {
              await store().rollbackTransaction(req);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found.engine).be.eql("handlebars");
          });
          it("should be able to see entity upsert inside transaction", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await store().beginTransaction(req);
            try {
              await getCollection(colName).insert(t1, req);
              await getCollection(colName).update({
                name: "t1"
              }, {
                $set: {
                  engine: "handlebars"
                }
              }, req);
              const found2 = await getCollection(colName).findOne({ name: "t1" }, req);
              should(found2 != null).be.True();
              await store().commitTransaction(req);
            } catch (e) {
              await store().rollbackTransaction(req);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found != null).be.True();
          });
          it("should not be able to see entity removed inside transaction", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await getCollection(colName).insert(t1);
            await store().beginTransaction(req);
            try {
              await getCollection(colName).remove({
                name: "t1"
              }, req);
              const found2 = await getCollection(colName).findOne({ name: "t1" }, req);
              should(found2 == null).be.True();
              await store().commitTransaction(req);
            } catch (e) {
              await store().rollbackTransaction(req);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found == null).be.True();
          });
          it("should not be able to see entity created in transaction from outside", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            await store().beginTransaction(req);
            try {
              const t1 = {
                name: "t1",
                engine: "none",
                recipe: "html"
              };
              await getCollection(colName).insert(t1, req);
              const found2 = await getCollection(colName).findOne({ name: "t1" });
              should(found2 == null).be.True();
              await store().commitTransaction(req);
            } catch (e) {
              await store().rollbackTransaction(req);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found != null).be.True();
          });
          it("should be able to see entity updated in transaction from outside", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await getCollection(colName).insert(t1);
            await store().beginTransaction(req);
            try {
              await getCollection(colName).update({
                name: "t1"
              }, {
                $set: {
                  engine: "handlebars"
                }
              }, req);
              const found2 = await getCollection(colName).findOne({ name: "t1" });
              should(found2 != null).be.True();
              await store().commitTransaction(req);
            } catch (e) {
              await store().rollbackTransaction(req);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found != null).be.True();
          });
          it("should not be able to see entity updated properties from outside", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await getCollection(colName).insert(t1);
            await store().beginTransaction(req);
            try {
              await getCollection(colName).update({
                name: "t1"
              }, {
                $set: {
                  engine: "handlebars"
                }
              }, req);
              const found2 = await getCollection(colName).findOne({ name: "t1" });
              should(found2.engine).be.eql("none");
              await store().commitTransaction(req);
            } catch (e) {
              await store().rollbackTransaction(req);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found.engine).be.eql("handlebars");
          });
          it("should not be able to see entity upsert in transaction from outside", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await store().beginTransaction(req);
            try {
              await getCollection(colName).insert(t1, req);
              await getCollection(colName).update({
                name: "t1"
              }, {
                $set: {
                  engine: "handlebars"
                }
              }, req);
              const found2 = await getCollection(colName).findOne({ name: "t1" });
              should(found2 == null).be.True();
              await store().commitTransaction(req);
            } catch (e) {
              await store().rollbackTransaction(req);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found != null).be.True();
          });
          it("should be able to see entity removed in transaction from outside", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await getCollection(colName).insert(t1);
            await store().beginTransaction(req);
            try {
              await getCollection(colName).remove({
                name: "t1"
              }, req);
              const found2 = await getCollection(colName).findOne({ name: "t1" });
              should(found2 != null).be.True();
              await store().commitTransaction(req);
            } catch (e) {
              await store().rollbackTransaction(req);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found == null).be.True();
          });
          it("should not be able to see entity created in transaction from another transaction", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const req2 = Request({});
            await store().beginTransaction(req);
            await store().beginTransaction(req2);
            try {
              const t1 = {
                name: "t1",
                engine: "none",
                recipe: "html"
              };
              await getCollection(colName).insert(t1, req);
              const found2 = await getCollection(colName).findOne({ name: "t1" }, req2);
              should(found2 == null).be.True();
              await store().commitTransaction(req);
              await store().commitTransaction(req2);
            } catch (e) {
              await store().rollbackTransaction(req);
              await store().rollbackTransaction(req2);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found != null).be.True();
          });
          it("should be able to see entity updated in transaction from another transaction", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const req2 = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await getCollection(colName).insert(t1);
            await store().beginTransaction(req);
            await store().beginTransaction(req2);
            try {
              await getCollection(colName).update({
                name: "t1"
              }, {
                $set: {
                  engine: "handlebars"
                }
              }, req);
              const found2 = await getCollection(colName).findOne({ name: "t1" }, req2);
              should(found2 != null).be.True();
              await store().commitTransaction(req);
              await store().commitTransaction(req2);
            } catch (e) {
              await store().rollbackTransaction(req);
              await store().rollbackTransaction(req2);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found != null).be.True();
          });
          it("should not be able to see entity updated properties from another transaction", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const req2 = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await getCollection(colName).insert(t1);
            await store().beginTransaction(req);
            await store().beginTransaction(req2);
            try {
              await getCollection(colName).update({
                name: "t1"
              }, {
                $set: {
                  engine: "handlebars"
                }
              }, req);
              const found2 = await getCollection(colName).findOne({ name: "t1" }, req2);
              should(found2.engine).be.eql("none");
              await store().commitTransaction(req);
              await store().commitTransaction(req2);
            } catch (e) {
              await store().rollbackTransaction(req);
              await store().rollbackTransaction(req2);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found.engine).be.eql("handlebars");
          });
          it("should not be able to see entity upsert in transaction from another transaction", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const req2 = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await store().beginTransaction(req);
            await store().beginTransaction(req2);
            try {
              await getCollection(colName).insert(t1, req);
              await getCollection(colName).update({
                name: "t1"
              }, {
                $set: {
                  engine: "handlebars"
                }
              }, req);
              const found2 = await getCollection(colName).findOne({ name: "t1" }, req2);
              should(found2 == null).be.True();
              await store().commitTransaction(req);
              await store().commitTransaction(req2);
            } catch (e) {
              await store().rollbackTransaction(req);
              await store().rollbackTransaction(req2);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found != null).be.True();
          });
          it("should be able to see entity removed in transaction from another transaction", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const req2 = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await getCollection(colName).insert(t1);
            await store().beginTransaction(req);
            await store().beginTransaction(req2);
            try {
              await getCollection(colName).remove({
                name: "t1"
              }, req);
              const found2 = await getCollection(colName).findOne({ name: "t1" }, req2);
              should(found2 != null).be.True();
              await store().commitTransaction(req);
              await store().commitTransaction(req2);
            } catch (e) {
              await store().rollbackTransaction(req);
              await store().rollbackTransaction(req2);
              throw e;
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found == null).be.True();
          });
          it("should not be able to commit changes of transaction from another transaction (insert)", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const req2 = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await store().beginTransaction(req);
            await store().beginTransaction(req2);
            try {
              await getCollection(colName).insert(t1, req);
              await store().commitTransaction(req2);
              let found2 = await getCollection(colName).findOne({ name: "t1" }, req2);
              should(found2 == null).be.True();
              await store().commitTransaction(req);
              found2 = await getCollection(colName).findOne({ name: "t1" }, req);
              should(found2 != null).be.True();
            } catch (e) {
              await store().rollbackTransaction(req);
              await store().rollbackTransaction(req2);
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found != null).be.True();
          });
          it("should not be able to commit changes of transaction from another transaction (update)", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const req2 = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await getCollection(colName).insert(t1);
            await store().beginTransaction(req);
            await store().beginTransaction(req2);
            try {
              await getCollection(colName).update({
                name: "t1"
              }, {
                $set: {
                  engine: "handlebars"
                }
              }, req);
              await store().commitTransaction(req2);
              let found2 = await getCollection(colName).findOne({ name: "t1" }, req2);
              should(found2.engine).be.eql("none");
              await store().commitTransaction(req);
              found2 = await getCollection(colName).findOne({ name: "t1" }, req);
              should(found2.engine).be.eql("handlebars");
            } catch (e) {
              await store().rollbackTransaction(req);
              await store().rollbackTransaction(req2);
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found.engine).be.eql("handlebars");
          });
          it("should not be able to commit changes of transaction from another transaction (remove)", async () => {
            const colName = !isInternal ? "templates" : "internalTemplates";
            const req = Request({});
            const req2 = Request({});
            const t1 = {
              name: "t1",
              engine: "none",
              recipe: "html"
            };
            await getCollection(colName).insert(t1);
            await store().beginTransaction(req);
            await store().beginTransaction(req2);
            try {
              await getCollection(colName).remove({
                name: "t1"
              }, req);
              await store().commitTransaction(req2);
              let found2 = await getCollection(colName).findOne({ name: "t1" }, req2);
              should(found2 != null).be.True();
              await store().commitTransaction(req);
              found2 = await getCollection(colName).findOne({ name: "t1" }, req);
              should(found2 == null).be.True();
            } catch (e) {
              await store().rollbackTransaction(req);
              await store().rollbackTransaction(req2);
            }
            const found = await getCollection(colName).findOne({ name: "t1" });
            should(found == null).be.True();
          });
        });
      }
    }
    function init(store) {
      store().registerComplexType("CommonPhantomType", {
        header: { type: "Edm.String", document: { extension: "html", engine: true } }
      });
      const templateType = {
        name: { type: "Edm.String" },
        content: { type: "Edm.String", document: { extension: "html", engine: true } },
        recipe: { type: "Edm.String" },
        engine: { type: "Edm.String" },
        phantom: { type: "jsreport.CommonPhantomType", schema: { type: "null" } }
      };
      store().registerEntityType("CommonTemplateType", { ...templateType });
      store().registerEntityType("CommonTemplateType2", { ...templateType });
      store().registerEntitySet("templates", {
        entityType: "jsreport.CommonTemplateType",
        splitIntoDirectories: true
      });
      store().registerEntitySet("templates2", {
        entityType: "jsreport.CommonTemplateType2",
        splitIntoDirectories: true
      });
      store().registerEntitySet("internalTemplates", {
        entityType: "jsreport.CommonTemplateType",
        internal: true,
        splitIntoDirectories: true
      });
      store().registerEntitySet("internalTemplates2", {
        entityType: "jsreport.CommonTemplateType2",
        internal: true,
        splitIntoDirectories: true
      });
    }
    async function clean(store) {
      await Promise.all(Object.keys(store().collections).map(async (collectionName) => {
        const all = await store().collection(collectionName).find({});
        return Promise.all(all.map((e) => store().collection(collectionName).remove({ _id: e._id })));
      }));
      await Promise.all(Object.keys(store().internalCollections).map(async (collectionName) => {
        const all = await store().internalCollection(collectionName).find({});
        return Promise.all(all.map((e) => store().internalCollection(collectionName).remove({ _id: e._id })));
      }));
    }
    module2.exports.init = init;
    module2.exports.clean = clean;
  }
});

// node_modules/@jsreport/jsreport-core/test/blobStorage/common.js
var require_common5 = __commonJS({
  "node_modules/@jsreport/jsreport-core/test/blobStorage/common.js"(exports2, module2) {
    module2.exports = (storage) => {
      it("write and read", async () => {
        await storage().write("foo", Buffer.from("hula"));
        const content = await storage().read("foo");
        content.toString().should.be.eql("hula");
      });
      it("write remove read should fail", async () => {
        await storage().write("foo", Buffer.from("hula"));
        await storage().remove("foo");
        return storage().read("foo").should.be.rejected();
      });
      it("should work with folders and paths", async () => {
        await storage().write("foldera/folderb/myblob.txt", Buffer.from("hula"));
        const buf = await storage().read("foldera/folderb/myblob.txt");
        buf.toString().should.be.eql("hula");
      });
      it("remove shouldnt fail for missing blob", async () => {
        await storage().remove("foo");
      });
    };
  }
});

// node_modules/@jsreport/jsreport-core/test/extensions/validExtensions/listeners/jsreport.dontdiscover.config.js
var require_jsreport_dontdiscover_config = __commonJS({
  "node_modules/@jsreport/jsreport-core/test/extensions/validExtensions/listeners/jsreport.dontdiscover.config.js"(exports2, module2) {
    module2.exports = {
      name: "listeners",
      main: "main.js",
      worker: "worker.js",
      dependencies: ["a", "b", "c", "d", "e", "f"],
      requires: {},
      hasPublicPart: false,
      directory: __dirname
    };
  }
});

// node_modules/@jsreport/jsreport-core/index.js
var require_jsreport_core = __commonJS({
  "node_modules/@jsreport/jsreport-core/index.js"(exports2, module2) {
    var path = require("path");
    var winston = require_winston();
    var MainReporter = require_reporter2();
    var createDefaultLoggerFormat = require_createDefaultLoggerFormat();
    var createListenerCollection = require_listenerCollection();
    var Request = require_request();
    module2.exports = function(options, defaults) {
      options = options || {};
      if (options.parentModuleDirectory == null && module2.parent) {
        options.parentModuleDirectory = path.dirname(module2.parent.filename);
      }
      return new MainReporter(options, defaults);
    };
    module2.exports.Reporter = MainReporter;
    module2.exports.Request = Request;
    module2.exports.createListenerCollection = createListenerCollection;
    module2.exports.loggerFormat = winston.format;
    module2.exports.createDefaultLoggerFormat = createDefaultLoggerFormat;
    module2.exports.tests = {
      documentStore: () => require_common4(),
      blobStorage: () => require_common5(),
      listeners: () => require_jsreport_dontdiscover_config()
    };
  }
});

// index.js
var jsreport = require_jsreport_core()();
console.log(jsreport);
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

is/index.js:
  (**!
   * is
   * the definitive JavaScript type testing library
   *
   * @copyright 2013-2014 Enrico Marino / Jordan Harband
   * @license MIT
   *)

xregexp/lib/xregexp.js:
  (*!
   * XRegExp 4.0.0
   * <xregexp.com>
   * Steven Levithan (c) 2007-2017 MIT License
   *)

xregexp/lib/addons/build.js:
  (*!
   * XRegExp.build 4.0.0
   * <xregexp.com>
   * Steven Levithan (c) 2012-2017 MIT License
   *)

xregexp/lib/addons/matchrecursive.js:
  (*!
   * XRegExp.matchRecursive 4.0.0
   * <xregexp.com>
   * Steven Levithan (c) 2009-2017 MIT License
   *)

xregexp/lib/addons/unicode-base.js:
  (*!
   * XRegExp Unicode Base 4.0.0
   * <xregexp.com>
   * Steven Levithan (c) 2008-2017 MIT License
   *)

xregexp/lib/addons/unicode-blocks.js:
  (*!
   * XRegExp Unicode Blocks 4.0.0
   * <xregexp.com>
   * Steven Levithan (c) 2010-2017 MIT License
   * Unicode data by Mathias Bynens <mathiasbynens.be>
   *)

xregexp/lib/addons/unicode-categories.js:
  (*!
   * XRegExp Unicode Categories 4.0.0
   * <xregexp.com>
   * Steven Levithan (c) 2010-2017 MIT License
   * Unicode data by Mathias Bynens <mathiasbynens.be>
   *)

xregexp/lib/addons/unicode-properties.js:
  (*!
   * XRegExp Unicode Properties 4.0.0
   * <xregexp.com>
   * Steven Levithan (c) 2012-2017 MIT License
   * Unicode data by Mathias Bynens <mathiasbynens.be>
   *)

xregexp/lib/addons/unicode-scripts.js:
  (*!
   * XRegExp Unicode Scripts 4.0.0
   * <xregexp.com>
   * Steven Levithan (c) 2010-2017 MIT License
   * Unicode data by Mathias Bynens <mathiasbynens.be>
   *)

@jsreport/mingo/dist/mingo.js:
  (*! mingo.js 2.4.0 *)
  (*! Copyright (c) 2019 Francis Asante *)
  (*! MIT *)

@jsreport/jsreport-core/lib/main/store/memoryStoreProvider.js:
  (*!
   * Copyright(c) 2018 Jan Blaha
   *
   * DocumentStore data layer provider using just memory.
   *)

@jsreport/jsreport-core/lib/main/extensions/fileUtils.js:
  (*!
   * Copyright(c) 2014 Jan Blaha
   *
   *)

@jsreport/jsreport-core/lib/main/extensions/extensionsManager.js:
  (*!
   * Copyright(c) 2018 Jan Blaha
   *
   * ExtensionsManager responsible for loading and  registering jsreport extensions.
   *)

@jsreport/jsreport-core/lib/main/settings.js:
  (*!
   * Copyright(c) 2014 Jan Blaha
   *
   * Key-Value persistent store for jsreport using DocumentStore to persist items.
   *)

is-primitive/index.js:
  (*!
   * is-primitive <https://github.com/jonschlinkert/is-primitive>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

isobject/index.js:
  (*!
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-plain-object/index.js:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

set-value/index.js:
  (*!
   * set-value <https://github.com/jonschlinkert/set-value>
   *
   * Copyright (c) Jon Schlinkert (https://github.com/jonschlinkert).
   * Released under the MIT License.
   *)

has-own-deep/index.js:
  (*!
   * has-own-deep <https://github.com/jonschlinkert/has-own-deep>
   *
   * Copyright (c) 2015-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)

isobject/index.cjs.js:
  (*!
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

get-value/index.js:
  (*!
   * get-value <https://github.com/jonschlinkert/get-value>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)

has-values/index.js:
  (*!
   * has-values <https://github.com/jonschlinkert/has-values>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)

has-value/index.js:
  (*!
   * has-value <https://github.com/jonschlinkert/has-value>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)

unset-value/index.js:
  (*!
   * unset-value <https://github.com/jonschlinkert/unset-value>
   *
   * Copyright (c) 2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

bytes/index.js:
  (*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   *)

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)

@jsreport/jsreport-core/lib/main/reporter.js:
  (*!
   * Copyright(c) 2018 Jan Blaha
   *
   * Reporter main class including all methods jsreport-core exposes.
   *)
*/
